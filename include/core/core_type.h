/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
f * core_type.h
 *
 *  Created on: Oct 21, 2014
 *      Author: evank
 */

#ifndef CORE_TYPE_H_
#define CORE_TYPE_H_

#include "core/core_fwd.h"
#include "core/core_kind.h"
#include "ruts/uniform_key.h"

namespace mds {
  namespace core {

    struct managed_type_base : public exportable, with_uniform_id
    {
      const kind type_kind;
      managed_type_base(gc_token &gc, kind k) : exportable{gc}, type_kind{k} {}
      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(managed_type_base)
	  .WITH_SUPER(with_uniform_id)
	  .WITH_FIELD(&managed_type_base::type_kind);
        return d;
      }
      bool same_type_as(const gc_ptr<const managed_type_base> &other) const {
        if (other == this) {
          return true;
        }
        if (other == nullptr || other->type_kind != type_kind) {
          return false;
        }
        return kind_dispatch::lookup(type_kind)->same_type(GC_THIS, other);
      }
    };

    template <kind K> class array_type;

    template <kind K>
    class managed_type : public managed_type_base
    {
      mutable std::atomic<gc_ptr<array_type<K>>> _in_array_type{nullptr};
    public:
      managed_type(gc_token &gc) : managed_type_base{gc, K} {}
      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(managed_type)
	  .template WITH_SUPER(managed_type_base)
	  .template WITH_FIELD(&managed_type::_in_array_type);
        return d;
      }
      gc_ptr<kind_field<K>> field_in(const gc_ptr<record_type> &rt,
                                     const gc_ptr<interned_string> &name,
                                     bool create_if_absent) const;
      gc_ptr<kind_type<K>> downcast() {
        /*
         * We only create kind_type<K>
         */
        return std::static_pointer_cast<kind_type<K>>(GC_THIS);
      }
      gc_ptr<const kind_type<K>> downcast() const {
        /*
         * We only create kind_type<K>
         */
        return std::static_pointer_cast<const kind_type<K>>(GC_THIS);
      }
      bool compare_types(const gc_ptr<const managed_type> &other) const {
        /*
         * By default, if the kinds match, it's the same type.
         */
        return true;
      }
      bool same_type_as(const gc_ptr<const managed_type_base> &other) const {
        if (other == nullptr) { return false; }
        if (other == this) { return true; }
        if (other->type_kind != K) { return false; }
        /*
         * Now we have to get tricky.  We can't use virtual functions, but
         * we have a discriminator and so we know our leaf type.  Cast and
         * delegate.
         */
        gc_ptr<const kind_type<K>> as_leaf = std::static_pointer_cast<const kind_type<K>>(GC_THIS);
        gc_ptr<const kind_type<K>> other_leaf = std::static_pointer_cast<const kind_type<K>>(other);
        return as_leaf->compare_types(other_leaf);
      }

      gc_ptr<array_type<K>> in_array() const;
    };



  }
}



#endif /* CORE_TYPE_H_ */
