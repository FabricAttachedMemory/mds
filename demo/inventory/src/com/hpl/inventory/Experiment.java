/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.inventory;

import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Predicate;

import com.hpl.erk.RandomChoice;
import com.hpl.erk.util.ArrayUtils;

public class Experiment {
	private RandomChoice<Runnable> actions = new RandomChoice<>();
	private Predicate<? super Run> stopTest = null;
	private long delayMeanMillis;
	private long delaySDMillis;
	
	
	public Experiment addAction(double weight, Runnable action) {
		actions.add(action, weight);
		return this;
	}
	public Experiment addAction(Runnable action) {
		actions.add(action);
		return this;
	}
	
	public <U extends Runnable, N extends Number> Experiment addActions(Map<U, N> map) {
		actions.addAll(map);
		return this;
	}
		  
	public <U extends Runnable> Experiment addActions(Collection<U> coll) {
		actions.addAll(coll);
		return this;
	}
	public <U extends Runnable> Experiment addActions(@SuppressWarnings("unchecked") U... array) {
		actions.addAll(array);
		return this;
	}
	
	public Experiment stopWhen(Predicate<? super Run> test) {
		if (stopTest != null) {
			Predicate<? super Run> oldTest = stopTest;
			stopTest = (Run r) -> { return test.test(r) || oldTest.test(r); };
		} else {
			stopTest = test;
		}
		return this;
	}
	
	public Experiment stopAfterN(int n) {
		return stopWhen(r -> {
			int p = r.nPerformed();
			return p >= n; 
		});// r.nPerformed() >= n);
	}
	
	public Experiment stopAfter(Instant t) {
		return stopWhen(r -> Instant.now().isAfter(t));
	}
	
	public Experiment stopAfter(Duration d) {
		return stopWhen(r -> Instant.now().isAfter(r.startTime().plus(d)));
	}
	
	public Experiment setDelay(Duration mean, Duration sd) {
		delayMeanMillis = mean.toMillis();
		delaySDMillis = sd.toMillis();
		return this;
	}
	
	public Run start(int nThreads) {
		return new Run(nThreads);
	}
	class Run {
		final Thread[] threads;
		AtomicBoolean running = new AtomicBoolean(true);
		private final AtomicInteger nPerformed = new AtomicInteger();
		private final Instant startTime = Instant.now();
		public int nPerformed() {
			return nPerformed.get();
		}
		public Instant startTime() {
			return startTime;
		}

		public Run(int nThreads) {
			threads = new Thread[nThreads];
			ArrayUtils.fillWith(() -> new Thread(){
				public void run() {
//					Timer timer = new Timer();
					while (keepRunning()) {
//						TimerTask task = new TimerTask() {
//							@Override public void run() {
//								for (int i=0; i<1_000; i++) {
//									System.out.format("Wedged: Hit suspend%n");
//									try {
//										TimeUnit.MILLISECONDS.sleep(100);
//									} catch (InterruptedException e) {
//										 // ignore
//									}
//								}
//							}
//						};
//						timer.schedule(task, 1000);
						Runnable action = actions.choose();
						action.run();
//						task.cancel();
//						timer.purge();
						nPerformed.incrementAndGet();
						sleepUntilNext();
					}
				};
			}, threads);
//			for (Thread t : threads) {
//				t.start();
//			}
			Arrays.stream(threads).forEach(Thread::start);
			for (Thread t : threads) {
				try {
					t.join();
				} catch (InterruptedException e) {
					// ignore
				}
			}
		}
		
		private boolean keepRunning() {
			if (!running.get()) {
//				System.out.format("Running is false");
				return false;
			}
			if (stopTest == null) {
				return true;
			}
			boolean val = !stopTest.test(this);
			if (!val) {
//				System.out.format("Setting running to false");
				running.set(false);
			}
			return val;
		}
		
	}


	private void sleepUntilNext() {
		double normal = ThreadLocalRandom.current().nextGaussian();
		long delay = (long) (normal * delaySDMillis + delayMeanMillis);
		if (delay > 0) {
			try {
				Thread.sleep(delay);
			} catch (InterruptedException e) {
				// don't care
			}
		}
	}

}
