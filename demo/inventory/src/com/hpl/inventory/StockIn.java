/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */


/** 
 * StockIn
 * Adds new stock to an existing inventory of products
 *
 * In one invocation (one stock update):
 *
 *   if random generation of stock update ok: (any product)
 *     Number of products restocked =
 *       1% of products in inventory (or at least 1 product)
 *     Product numbers used:
 *       generated at random from within range used in populating inventory
 *
 *   if fixed generation of stock update required: (repeatable product)
 *     Number of products restocked =
 *       nbrProducts specified in constructor
 *     Product numbers used:
 *       random generator seed specified in constructor
 *       to generate one repeatable sequence of product numbers
 *
 *
 * author: suspence
 */

package com.hpl.inventory;

import java.util.Random;

import org.apache.log4j.Logger;


public class StockIn extends InventoryChange implements Runnable {
	
	private static final Logger log = Logger.getLogger(StockIn.class);
  
    public StockIn(String inventoryName) {
        super(inventoryName);
    }

    // used by Demo3 - not all names used at start, 
    // productNameTail is highest-numbered product name (at tail of list)
    public StockIn(String inventoryName, int productNameTail, boolean bias) {
    	super(inventoryName, productNameTail, bias);
    }

    // used by Demo2Conflict - use seed to ensure operations on specific product
    public StockIn(String inventoryName, int nbrProducts, long seed) {
        super(inventoryName, nbrProducts, seed);
    }


    public void run() {
        Product product = null;

        String productName = "";
        int    productCount = 0;
        int    productValue = 0;
        int    countIncr = 0;
        int    newCount = 0;
        
        lookupInventory();

        // for each product supplied
        // (where StockIn typically updates no more than 1% of products)
        int productNbr = 0;
        int nbrProductsUpdated = calcNbrProductsUpdated();
        for (int i = 1; i <= nbrProductsUpdated; i++) {
            
            // // Generate name (of product to be updated) using random number
            // // Product name composed of "P" plus nbr
            // // default: pad nbr to six digits (000000-999999) with leading zeros
            // 
            // // small inventory, large productsMax: likelihood of conflict low
            // // productNbr = random.nextInt(productsMax); 
            // // ensure we always update an existing product to increase conflict 
            // productNbr = nameRandom.nextInt(inventorySize); 
            // //if (productNbr == 0) productNbr = 1;  // no zero nbr products
            // productName = 
            //     "P" + Integer.toString(productNbr + productsMax).substring(1);
            productName = generateProductName(bias);

            // Generate count of this product to be added to inventory 
            countIncr = nbrRandom.nextInt(countMax);

            // lookup named product in inventory
            product = inventory.get(productName);
            if (product == null) {
                // create the product if it doesn't already exist
                // (including generating a value for it)
                // add this product to the inventory as a new product
                productCount = countIncr;
                productValue = nbrRandom.nextInt(valueMax);
                product = Product.create.record(productName, productCount, productValue);
                inventory.add(product);

                // Basic demo info to stdout; details to log
                // only using log.error because error level is "higher" than warn level!
                // System.out.println("StockIn: Added new product:" + productName);
                log.fatal("StockIn: Added new product:" + productName);
                log.error("name:  " + productName);
                log.error("count: " + productCount);
                log.error("value: $" + (productValue/100) + "." + (productValue%100));
//                System.out.println("name:  " + productName);
//                System.out.println("count: " + productCount);
//                System.out.format("value: $%d.%02d%n",
//                    (productValue/100),(productValue%100));
            }
            else {
                // update stock of existing product
                // incrementing product count by nbr of product supplied 
                // product.incCount(productCount);
                newCount = product.getCount() + countIncr;
                product.setCount(newCount);

                // report existing value for this product
                productValue = product.getValue();
                // Basic demo info to stdout; details to log
                // only using log.error because error level is "higher" than warn level!
                //System.out.println("StockIn: Increased existing product: " + productName + ": +" + countIncr);
                log.fatal("StockIn: Increased existing product: " + productName + ": +" + countIncr);
                log.error("name:  " + productName);
                log.error("count: " + newCount);
                log.error("value: $" + (productValue/100) + "." + (productValue%100));
//                System.out.println("name:  " + productName);
//                System.out.println("count: " + newCount);
//                System.out.format("value: $%d.%02d%n",
//                    (productValue/100),(productValue%100));
            }
        } 
    }


    // testing: just run this task in the current thread
    public static void runTask() {
        new StockIn("Inventory1").run();
    }

    
    public static void createInventory(String inventoryName) {
        Inventory inventory = Inventory.create.record();
        //NameService.bind(inventoryName, inventory);
        inventory.bindName(inventoryName);
    }


    /**
     * populateInventory
     * Populate inventory with an initial stock of products,
     * with auto-generated product names, counts, values. 
     */
    public static void populateInventory(String inventoryName, int nbrProducts) {
        int nameFrequency = 1;
        populateInventory(inventoryName, nbrProducts, nameFrequency);
    }


    /**
     * populateInventory
     * Populate inventory with an initial stock of products,
     * with auto-generated product names, counts, values.
     * 
     * With a nameFrequency set to one, 
     * productnames will be generated with no gaps in the nameseries
     * (P0001, P0002, P0003, P0004, P0005, P0006, P0007, etc.)
     * 
     * With a nameFrequency set to n, and greater than one,
     * productnames will be generated for every n-th name in the nameseries
     * e.g. where n==3: 
     * (P0003, P0006, P0009, P00012, P00015, etc.)
     *
     */
    public static void populateInventory(
        String inventoryName, int nbrProducts, int nameFrequency) 
    {
        Product product = null;

        String productName = "";
        int    productCount = 0;
        int    productValue = 0;


        Inventory inventory = Inventory.TYPE.lookupName(inventoryName);
        if (inventory == null)
            throw new NullPointerException(
                "inventory " + inventoryName + " not found in NameService");

        Random random = new Random();
        for (int i = 1; i <= nbrProducts; i=i+nameFrequency) {

            // Product name composed of "P" plus nbr
            // default: pad nbr to six digits (000000-999999) with leading zeros
            productName = "P" + Integer.toString( i + productsMax).substring(1);

            // Random.nextInt(n) 
            // Returns a pseudorandom, uniformly distributed int value 
            // between 0 (inclusive) and the specified value (exclusive)
            productCount = random.nextInt(countMax);
            productValue = random.nextInt(valueMax);

            System.out.println("\nname:  " + productName);
            System.out.println("count: " + productCount);
            System.out.format("value: $%d.%02d%n",
                (productValue/100),(productValue%100));

            // products generated in name-order so inventory.append() ok
            product = Product.create.record(productName, productCount, productValue);
            inventory.append(product);
        }
        System.out.println();
    }


    // test StockIn methods standalone
    public static void main(String[] args) {
        // create new inventory 
        createInventory("Inventory1");

        // populate inventory with initial stock of products
        populateInventory("Inventory1", 100);

        // add new stock to existing inventory
        runTask();
    }


} // end class StockIn




