/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */


/**
 * OrderOut
 * Removes order items from existing inventory of products
 * 
 * In one invocation (one order):
 *
 *   if random generation of order ok: (any product)
 *     Number of products ordered = 
 *       1% of products in inventory (or at least 1 product) 
 *     Product numbers used: 
 *       generated at random from within range used in populating inventory
 *   
 *   if fixed generation of order required: (repeatable product)
 *     Number of products ordered = 
 *       nbrProducts specified in constructor
 *     Product numbers used: 
 *       random generator seed specified in constructor
 *       to generate one repeatable sequence of product numbers
 * 
 *
 * author: suspence
 */

package com.hpl.inventory;

import java.util.Random;

import org.apache.log4j.Logger;


public class OrderOut extends InventoryChange implements Runnable {
	
	private static final Logger log = Logger.getLogger(OrderOut.class);
  
    public OrderOut(String inventoryName) {
        super(inventoryName);
    }

    public OrderOut(String inventoryName, int productNameTail, boolean bias) {
        super(inventoryName, productNameTail, bias);
    }

    public OrderOut(String inventoryName, int nbrProducts, long seed) {
        super(inventoryName, nbrProducts, seed);
    }


    public void run() {
        Product product = null;

        String productName = "";
        int    productCount = 0;
        int    productValue = 0;
        int    countDecr = 0;
        int    newCount = 0;
        int    newNbrSold = 0;
        int    newRevenue = 0;

        lookupInventory();

        // for each item in the order...
        int productNbr = 0;
        int nbrProductsUpdated = calcNbrProductsUpdated();
        for (int i = 1; i <= nbrProductsUpdated; i++) {

            // Order an existing product
            // // Generate name (of product to be updated) using random number
            // productNbr = nameRandom.nextInt(inventorySize);
            // // if (productNbr == 0) productNbr = 1;  // no zero nbr products
            // productName =
            //     "P" + Integer.toString(productNbr + productsMax).substring(1);
            productName = generateProductName(bias);
            
            // Generate count of this product to be removed from inventory
            countDecr = nbrRandom.nextInt(countMax);

            // lookup named product in inventory
            product = inventory.get(productName);
            if (product != null) {

                // decrement product count by nbr ordered
                // or to zero if less product in stock than required
                // product.decCount(countDecr);
                productCount = product.getCount();
                if (productCount > 0) {
                    newCount = productCount - countDecr; 
                    if (newCount < 0) {
                        countDecr = productCount;
                        newCount = 0;
                    }
                    product.setCount(newCount);
                    
                    // increment product nbrSold by nbr ordered
                    // product.incNbrSold(countDecr);
                    newNbrSold = product.getNbrSold() + countDecr;
                    product.setNbrSold(newNbrSold);
    
                    // increment product revenue by (nbr*value) 
                    newRevenue = product.getRevenue() + (product.getValue() * countDecr);
                    product.setRevenue(newRevenue);
    
                    // report changes 
                    productValue = product.getValue();
                    // Basic demo info to stdout; details to log
                    // only using log.error because error level is "higher" than warn level!
                    // System.out.println("OrderOut: Decreased existing product: " + productName + ": -" + countDecr);
                    log.fatal("OrderOut: Decreased existing product: " + productName + ": -" + countDecr);
                    log.error("name: " + productName);
                    log.error("count: " + newCount);
                    log.error("value: $" + (productValue/100) + "." + (productValue%100));
                    log.error("nbrSold: " + newNbrSold);
                    log.error("revenue: $" + (newRevenue/100) + "." + (newRevenue%100));
//                    System.out.println("name: " + productName);
//                    System.out.println("count: " + newCount);
//                    System.out.format("value: $%d.%02d%n",
//                        (productValue/100),(productValue%100));
//                    System.out.println("nbrSold: " + newNbrSold);
//                    System.out.format("revenue: $%d.%02d%n",
//                        (newRevenue/100),(newRevenue%100));

                }
                else { // productCount == 0
                    //System.out.println(
                	log.fatal(
                        "No stock of existing product " + productName +
                        " in inventory " + inventoryName);
                }

            }
            else {
                // if nameFrequency > 1 then null product entries likely
                // Log null pointer but don't terminate program execution
                //System.out.println(
            	log.fatal(
                    "No existing product " + productName + " in inventory " + inventoryName);
            }
        }
    }


    // testing: just run this task in the current thread
    public static void runTask() {
        new OrderOut("Inventory1").run(); 
    }


    // testing: run this task as an atomic transaction in the current thread
    public static void runAsAtomicTransaction() {
        new AtomicTransaction( new OrderOut("Inventory1") ).run();
    }


    // testing: run this task as an atomic transaction in its own thread
    public static void runAsAtomicTransactionThread() {
        Runnable tx = new AtomicTransaction( new OrderOut("Inventory1") ); 
        new Thread( tx ).start();
    }


    // test OrderOut methods standalone
    public static void main(String[] args) {
        // create new inventory 
        createInventory("Inventory1");

        // populate inventory with initial stock of specified number of products
        StockIn.populateInventory("Inventory1", 1000);

        // remove products from existing inventory to fulfil order
        runTask();
    }


} // end class OrderOut
