/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * core_kind.cpp
 *
 *  Created on: Nov 13, 2014
 *      Author: evank
 */

#include "core/core_kind.h"
#include "core/core_type.h"
#include "core/core_record.h"
#include "core/core_array.h"

namespace mds {
  namespace core {

    template <kind K>
    struct kd_default : kind_dispatch {
      bool same_type(const gc_ptr<const managed_type_base> &lhs,
                     const gc_ptr<const managed_type_base> &rhs) const {
        /*
         * Precondition is that the kinds both match K.  We've
         * already checked that neither is null and they're not
         * both the same.
         */
        gc_ptr<const kind_type<K>> a = std::static_pointer_cast<const kind_type<K>>(lhs);
        gc_ptr<const kind_type<K>> b = std::static_pointer_cast<const kind_type<K>>(rhs);
        return a->compare_types(b);
      }

    };

    struct kd_record : kd_default<kind::RECORD> {

    };

    struct kd_array : kd_default<kind::ARRAY> {

    };

    const std::array<std::unique_ptr<const kind_dispatch>,n_kinds> &
    kind_dispatch::table() {
      static std::array<std::unique_ptr<const kind_dispatch>,n_kinds> array;
      static std::once_flag once;
      std::call_once(once, []() {
        array[static_cast<std::size_t>(kind::BOOL)].reset(new kd_default<kind::BOOL>);
        array[static_cast<std::size_t>(kind::BYTE)].reset(new kd_default<kind::BYTE>);
        array[static_cast<std::size_t>(kind::UBYTE)].reset(new kd_default<kind::UBYTE>);
        array[static_cast<std::size_t>(kind::SHORT)].reset(new kd_default<kind::SHORT>);
        array[static_cast<std::size_t>(kind::USHORT)].reset(new kd_default<kind::USHORT>);
        array[static_cast<std::size_t>(kind::INT)].reset(new kd_default<kind::INT>);
        array[static_cast<std::size_t>(kind::UINT)].reset(new kd_default<kind::UINT>);
        array[static_cast<std::size_t>(kind::LONG)].reset(new kd_default<kind::LONG>);
        array[static_cast<std::size_t>(kind::ULONG)].reset(new kd_default<kind::ULONG>);
        array[static_cast<std::size_t>(kind::FLOAT)].reset(new kd_default<kind::FLOAT>);
        array[static_cast<std::size_t>(kind::DOUBLE)].reset(new kd_default<kind::DOUBLE>);
        array[static_cast<std::size_t>(kind::STRING)].reset(new kd_default<kind::STRING>);
        array[static_cast<std::size_t>(kind::RECORD)].reset(new kd_record);
        array[static_cast<std::size_t>(kind::ARRAY)].reset(new kd_array);
      });
      return array;
    }

  }
}
