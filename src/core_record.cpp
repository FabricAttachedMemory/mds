/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * core_record.cpp
 *
 *  Created on: Nov 13, 2014
 *      Author: evank
 */

#include "core/core_record.h"

namespace mds {
  namespace core {


    bool
    record_field_base::compatible_with(const gc_ptr<record_field_base> &other) const {
      if (this == other) {
        return true;
      }
      if (other == nullptr) {
        return false;
      }
      if (name != other->name) {
        return false;
      }
      return f_type_base->same_type_as(other->f_type_base);
    }



    gc_ptr<const record_type> record_type::try_to_create() const {
      /*
       * We're not worrying about race conditions, so we can just
       * set _created to true before putting it in.
       */
      if (_created) {
        return GC_THIS;
      }
      _created = true;
      auto r = record_type_table->put_new(_name, GC_THIS);
      if (!r.had_value || r.old_value == this) {
        // The _forward flag is null.
        return nullptr;
      }
      /*
       * Somebody else created it first.  Check to see whether it's compatible.
       * It's okay if all of our fields match as to name and type.  (We don't
       * care if there are extras.)
       */
      _forward = r.old_value;
      try {
        const std::size_t n = _fields.size();
        if (_forward->_fields.size() < n) {
          // It's too small.
          throw incompatible_record_type_ex{};
        }
        for (std::size_t i=0; i<n; i++) {
          gc_ptr<record_field_base> f = _fields[i];
          gc_ptr<record_field_base> ff = _forward->_fields[i];
          if (!f->compatible_with(ff)) {
            throw incompatible_record_type_ex{};
          }
        }
        /*
         * And its super needs to be a superclass of ours.
         */
        if (_super != nullptr) {
          gc_ptr<const record_type> s = _forward->_super;
          if (s == nullptr || !(s->is_super_of(_super))) {
            throw incompatible_record_type_ex{};
          }
        }
      } catch (incompatible_record_type_ex &) {
        _valid = false;
        throw;
      }
      return _forward;
    }

  }
}
