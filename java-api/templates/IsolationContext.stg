/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
import "string.stg"
package() ::= "com.hpl.mds"
class() ::= "IsolationContext"

code(types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$contents(types.primTypes, types.maskedTypes, types)$
>>

comma(f) ::= "$if(f)$, $endif$"


functionals(imprt, tvars, rtype, ftype, tbounds, formals, actuals, apply, return) ::= <<
$if(imprt)$
import $imprt$;
$endif$
// Functions for $ftype$
  default $tvars$ $rtype$ call($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    try (Use use = use()) {
      $return$ fn.$apply$;
    }
  }
  
  default $tvars$ IsolationContext run($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    call(fn$comma(actuals)$$actuals$);
    return this;
  } 
  
  default $tvars$ PubResult runThenPublish($ftype$$tbounds$ fn$comma(formals)$$formals$, PubOption...options) {
    call(fn$comma(actuals)$$actuals$);
    return publish(options);
  } 
  
  default $tvars$ PubResult runThenPublish($ftype$$tbounds$ fn$comma(formals)$$formals$, Collection<PubOption> options) {
    call(fn$comma(actuals)$$actuals$);
    return publish(options);
  }
  
  default $tvars$ $ftype$$tvars$ bind($ftype$$tbounds$ fn) {
    return ($actuals$) -> IsolationContext.this.call(fn$comma(actuals)$$actuals$);
  } 
  
  static $tvars$ $ftype$$tvars$ bindToCurrent($ftype$$tbounds$ fn) {
    return current().bind(fn);
  }

  default $tvars$ $rtype$ callIsolated($ftype$$tbounds$ fn$comma(formals)$$formals$, Collection<? extends PubOption> options) {
    $return$ callIsolated(fn$comma(actuals)$$actuals$, null, options);
  }
  default $tvars$ $rtype$ callIsolated($ftype$$tbounds$ fn$comma(formals)$$formals$, MergeReport success, PubOption... options) {
    $return$ callIsolated(fn$comma(actuals)$$actuals$, success, Arrays.asList(options));
  }
  default $tvars$ $rtype$ callIsolated($ftype$$tbounds$ fn$comma(formals)$$formals$, PubOption... options) {
    $return$ callIsolated(fn$comma(actuals)$$actuals$, null, options);
  }

  static $tvars$ $rtype$ isolated($ftype$$tbounds$ fn$comma(formals)$$formals$, MergeReport success, Collection<? extends PubOption> options) {
    $return$ current().callIsolated(fn$comma(actuals)$$actuals$, success, options);
  }
  static $tvars$ $rtype$ isolated($ftype$$tbounds$ fn$comma(formals)$$formals$, Collection<? extends PubOption> options) {
    $return$ current().callIsolated(fn$comma(actuals)$$actuals$, null, options);
  }
  static $tvars$ $rtype$ isolated($ftype$$tbounds$ fn$comma(formals)$$formals$, MergeReport success, PubOption... options) {
    $return$ current().callIsolated(fn$comma(actuals)$$actuals$, success, options);
  }
  static $tvars$ $rtype$ isolated($ftype$$tbounds$ fn$comma(formals)$$formals$, PubOption... options) {
    $return$ current().callIsolated(fn$comma(actuals)$$actuals$, null, options);
  }


  default $tvars$ $rtype$ callDetached($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ createNestedDetached().call(fn$comma(actuals)$$actuals$);
  }
  static $tvars$ $rtype$ detached($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ current().callDetached(fn$comma(actuals)$$actuals$);
  }

  default $tvars$ $rtype$ callInSnapshot($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ createSnapshot().call(fn$comma(actuals)$$actuals$);
  }
  static $tvars$ $rtype$ inSnapshot($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ current().callInSnapshot(fn$comma(actuals)$$actuals$);
  }

  default $tvars$ $rtype$ callInReadOnlySnapshot($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ createReadOnlySnapshot().call(fn$comma(actuals)$$actuals$);
  }
  static $tvars$ $rtype$ inReadOnlySnapshot($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ current().callInReadOnlySnapshot(fn$comma(actuals)$$actuals$);
  }
>>

contents(prims, masked, types) ::= <<
package $package()$;

import java.util.Arrays;
import java.util.Collection;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

import com.hpl.mds.impl.ChangeBase;
import com.hpl.mds.impl.IsoContextProxy;
import com.hpl.mds.impl.Stub;

import com.hpl.mds.task.Task;


public interface IsolationContext {
  interface Use extends AutoCloseable {
    void close();
  }
  
  enum ViewType {
      Live, Snapshot
  }
  
  enum ModificationType {
      Full, Detached, ReadOnly
  }
  
  boolean isMergeable();
  boolean isReadOnly();
  boolean isSnapshot();
  
  static IsolationContext current() {
    return IsoContextProxy.current();
  }
  
  static IsolationContext global() {
    return IsoContextProxy.global();
  }
  
  static IsolationContext forProcess() {
    return IsoContextProxy.forProcess();
  }
  
  IsolationContext createNested(ViewType vt, ModificationType mt);
  default IsolationContext createNested(ModificationType mt) {
      return createNested(ViewType.Live, mt);
  }
  default IsolationContext createSnapshot(ModificationType mt) {
      return createNested(ViewType.Snapshot, mt);
  }
  default IsolationContext createNested() {
      return createNested(ViewType.Live, ModificationType.Full);
  }
  default IsolationContext createSnapshot() {
      return createNested(ViewType.Snapshot, ModificationType.Full);
  }
  default IsolationContext createNestedDetached() {
      return createNested(ViewType.Live, ModificationType.Detached);
  }
  default IsolationContext createDetachedSnapshot() {
      return createNested(ViewType.Snapshot, ModificationType.Detached);
  }
  default IsolationContext createNestedReadOnly() {
      return createNested(ViewType.Live, ModificationType.ReadOnly);
  }
  default IsolationContext createReadOnlySnapshot() {
      return createNested(ViewType.Snapshot, ModificationType.ReadOnly);
  }
  
  
  static IsolationContext nestedFromCurrent(ViewType vt, ModificationType mt) {
    return current().createNested(vt, mt);
  }
  static IsolationContext nestedFromCurrent(ModificationType mt) {
    return nestedFromCurrent(ViewType.Live, mt);
  }
  static IsolationContext snapshotFromCurrent(ModificationType mt) {
      return nestedFromCurrent(ViewType.Snapshot, mt);
  }
  static IsolationContext nestedFromCurrent() {
    return nestedFromCurrent(ViewType.Live, ModificationType.Full);
  }
  static IsolationContext snapshotFromCurrent() {
      return nestedFromCurrent(ViewType.Snapshot, ModificationType.Full);
  }
  static IsolationContext nestedDetachedFromCurrent() {
    return nestedFromCurrent(ViewType.Live, ModificationType.Detached);
  }
  static IsolationContext detachedSnapshotFromCurrent() {
      return nestedFromCurrent(ViewType.Snapshot, ModificationType.Detached);
  }
  static IsolationContext nestedReadOnlyFromCurrent() {
    return nestedFromCurrent(ViewType.Live, ModificationType.ReadOnly);
  }
  static IsolationContext readOnlySnapshotFromCurrent() {
      return nestedFromCurrent(ViewType.Snapshot, ModificationType.ReadOnly);
  }
  
  IsolationContext parent();
  
  Use use();
  
  PubResult publish(PubOption...options);
  PubResult publish(Collection<? extends PubOption> options);

  static PubResult publishCurrent(PubOption...options) {
    return current().publish(options);
  }
  static PubResult publishCurrent(Collection<? extends PubOption> options) {
    return current().publish(options);
  }



$functionals({java.util.function.Supplier}, {<R>}, {R}, {Supplier}, {<? extends R>}, [], [], {get()}, {return})$    
  <R> R callIsolated(Supplier<? extends R> func, MergeReport success, Collection<? extends PubOption> options);

$functionals({java.util.function.Consumer}, {<T>}, {void}, {Consumer}, {<? super T>}, {T arg}, {arg}, {accept(arg)}, { })$    
  default <T> boolean callIsolated(Consumer<? super T> func, T arg, MergeReport success, Collection<? extends PubOption> options) {
      return callIsolated(()->func.accept(arg), success, options);
  }

$functionals({java.util.function.BiConsumer}, {<T1,T2>}, {void}, {BiConsumer}, {<? super T1, ? super T2>}, {T1 arg1, T2 arg2}, {arg1, arg2}, {accept(arg1, arg2)}, { })$    
  default <T1,T2> boolean callIsolated(BiConsumer<? super T1, ? super T2> func, T1 arg1, T2 arg2, MergeReport success, Collection<? extends PubOption> options) {
      return callIsolated(()->func.accept(arg1, arg2), success, options);
  }

$functionals([], [], {void}, {Runnable}, [], [], [], {run()}, { })$
  default boolean callIsolated(Runnable func, MergeReport success, Collection<? extends PubOption> options) {
import com.hpl.mds.impl.MergeReportImpl;  
      MergeReport bh = success == null ? new MergeReportImpl() : success;
      callIsolated( () -> { func.run(); return null; }, bh, options);
      return bh.succeeded();
  }

$functionals({java.util.function.Predicate}, {<T>}, {boolean}, {Predicate}, {<? super T>}, {T arg}, {arg}, {test(arg)}, {return})$    
  default <T> boolean callIsolated(Predicate<? super T> func, T arg, MergeReport success, Collection<? extends PubOption> options) {
      return callIsolated(() -> func.test(arg), success, options);
  }

$functionals({java.util.function.Function}, {<T,R>}, {R}, {Function}, {<? super T, ? extends R>}, {T arg}, {arg}, {apply(arg)}, {return})$    
  default <T,R> R callIsolated(Function<? super T, ? extends R> func, T arg, MergeReport success, Collection<? extends PubOption> options) {
      return callIsolated(() -> func.apply(arg), success, options);
  }

$functionals({java.util.function.BiFunction}, {<T1,T2,R>}, {R}, {BiFunction}, {<? super T1, ? super T2, ? extends R>}, {T1 arg1, T2 arg2}, {arg1, arg2}, 
             {apply(arg1, arg2)}, {return})$    
  default <T1,T2,R> R callIsolated(BiFunction<? super T1,? super T2, ? extends R> func, T1 arg1, T2 arg2, MergeReport success, Collection<? extends PubOption> options) {
      return callIsolated(() -> func.apply(arg1, arg2), success, options);
  }
  
  
$prims: { type |
$functionals({com.hpl.mds.function.To$type.shortName$Function}, {<T>}, {$val()$}, {To$type.shortName$Function}, {<? super T>}, {T arg}, {arg}, {applyAs$type.shortName$(arg)}, {return})$    
  default <T> $val()$ callIsolated(To$type.shortName$Function<? super T> func, T arg, MergeReport success, Collection<? extends PubOption> options) {
      return callIsolated(() -> func.applyAs$type.shortName$(arg), success, options);
  \}
  
$functionals({com.hpl.mds.function.$type.shortName$Modifier}, [], {$val()$}, {$type.shortName$Modifier}, [], {$arg()$ arg}, {arg}, {apply(arg)}, {return})$    
  default $val()$ callIsolated($type.shortName$Modifier func, $arg()$ arg, MergeReport success, Collection<? extends PubOption> options) {
      return callIsolated(() -> func.apply(arg), success, options);
  \}
  
$functionals({com.hpl.mds.function.$type.shortName$Supplier}, [], {$val()$}, {$type.shortName$Supplier}, [], [], [], {get()}, {return})$
// No callIsolated for $type.shortName$Supplier.  Just delegate to Supplier<$type.shortName$>.    
  
$functionals({com.hpl.mds.function.$type.shortName$Predicate}, [], {boolean}, {$type.shortName$Predicate}, [], {$arg()$ arg}, {arg}, {test(arg)}, {return})$    
  default boolean callIsolated($type.shortName$Predicate func, $arg()$ arg, MergeReport success, Collection<? extends PubOption> options) {
      return callIsolated(() -> func.test(arg), success, options);
  \}
  
  
$functionals({com.hpl.mds.function.$type.shortName$Consumer}, [], {void}, {$type.shortName$Consumer}, [], {$arg()$ arg}, {arg}, {accept(arg)}, { })$    
  default void callIsolated($type.shortName$Consumer func, $arg()$ arg, MergeReport success, Collection<? extends PubOption> options) {
      callIsolated(() -> func.accept(arg), success, options);
  \}
  
  

}$



  

  
// -----  
// These haven't made it into the document yet.
  boolean isPublished();
  
  IsolationContext reset();

  
  <T extends ManagedObject> InContext<T> viewOf(T val);
  
  <T extends ManagedObject> InContext<T> viewOf(Supplier<? extends T> gen);

  static <T extends ManagedObject> InContext<T> currentViewOf(T val) {
    // TODO
    return Stub.notImplemented();
  }

  // Task management

  public void rerunConflictedTasks(PubResult pubResult);

  public static void addTask(Task task) {
    current().add(task);
  }
  public void add(Task task);
  
  public static void addTaskWrite(Task task, ChangeBase write) {
    current().addWrite(task, write);
  }
  public void addWrite(Task task, ChangeBase write);

  public static void addTaskRead(Task task, ChangeBase read) {
    current().addRead(task, read);
  }
  public void addRead(Task task, ChangeBase read);


  public static Task lastWriterTask(ChangeBase change) {
    return current().lastWriter(change);
  }
  public Task lastWriter(ChangeBase change);


  public void clearConflicts(); // tmp solution only

}
>>
