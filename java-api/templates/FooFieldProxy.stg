/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
import "string.stg"
package(type) ::= "com.hpl.mds.impl"
class(type) ::= "$type.fieldName$Proxy"

code(type,types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$body(class(type), type, type.managedName, type.boxedName, type.primName, type.fieldName, type.shortName, type.jniName, types)$
>>                      

body(class, type, managed, boxed, prim, field, short, jni, types) ::= <<
package $package(type)$;

import com.hpl.mds.Caching;
import com.hpl.mds.Holder;
import com.hpl.mds.IsolationContext;
import com.hpl.mds.ManagedRecord;
import com.hpl.mds.NativeLibraryLoader;
import com.hpl.mds.RecordType;
import com.hpl.mds.callbacks.ChangeHandler;
import com.hpl.mds.callbacks.ChangeHandlerRemovalHook;
import com.hpl.mds.callbacks.FieldChange;
import com.hpl.mds.conflicts.FieldConflict;
$unlessString({
import com.hpl.mds.function.To$short$Function;
import com.hpl.mds.function.$short$Consumer;
import com.hpl.mds.holder.$short$Holder;
})$
$whenString({
import java.util.function.Function;
import java.util.function.Consumer;
})$
import com.hpl.mds.$ifString({string},{prim})$.$managed$;
import com.hpl.mds.$ifString({string},{prim.field})$.$field$;
import com.hpl.mds.impl.IsoContextProxy;
import com.hpl.mds.task.Task;

//public class $class$<RT extends ManagedRecord, $managed$> extends FieldProxy<RT, $managed$> implements $field$<RT> {
//public interface $field$<RT extends ManagedRecord> extends Field<RT, $managed$>

public class $class$<RT extends ManagedRecord> extends FieldProxy<RT, $managed$> implements $field$<RT> {

    private static final NativeLibraryLoader NATIVE_LIB_LOADER = NativeLibraryLoader.getInstance();

	protected $class$(long handleIndex, RecordTypeProxy<RT> recType, ManagedStringProxy name) {
		super(handleIndex, recType, name);
	}


    private static native void release(long handle);
    private static native long getNameHandle(long handle);
    private static native long getRecTypeHandle(long handle);
  
	private static native long createFieldIn(long rtHandle, long nameHandle);
    private static native $jniArg()$ setValue$whenString({Handle})$(long handle, long ctxtHandle, long recHandle, $jniArg()$ val);
$if(type.numeric)$
    private static native $jniArg()$ addValue(long handle, long ctxtHandle, long recHandle, $jniArg()$ val);
    private static native $jniArg()$ subValue(long handle, long ctxtHandle, long recHandle, $jniArg()$ val);
    private static native $jniArg()$ mulValue(long handle, long ctxtHandle, long recHandle, $jniArg()$ val);
    private static native $jniArg()$ divValue(long handle, long ctxtHandle, long recHandle, $jniArg()$ val);
$endif$	

  @Override
  void releaseHandleIndex(long index) {
    release(index); 
  }
    
  private static native void setToParent(long handle, long ctxtHandle, long recHandle);
  private static native void rollback(long handle, long ctxtHandle, long recHandle);
      

    
$ifString({    
    private static native boolean changeValue$whenString({Handle})$(long handle, long ctxtHandle, long recHandle, 
                                                         long expectedHandle, long valHandle,
                                              Consumer<? super $above()$> mismatchSink);
    private static native long getValue$whenString({Handle})$(long handle, long ctxtHandle, long recordHandle);
    private static native long peekValue$whenString({Handle})$(long handle, long ctxtHandle, long recordHandle);
},{                                              
    private static native boolean changeValue$whenString({Handle})$(long handle, long ctxtHandle, long recHandle, $arg()$ expected, $arg()$ val,
                                              $short$Consumer mismatchSink);
    private static native $val()$ getValue$whenString({Handle})$(long handle, long ctxtHandle, long recordHandle);
    private static native $val()$ peekValue$whenString({Handle})$(long handle, long ctxtHandle, long recordHandle);
})$                                              

	static <RT extends ManagedRecord> $class$<RT> in(RecordType<RT> recType, CharSequence name) {
	   RecordTypeProxy<RT> rtp = RecordTypeProxy.downcast(recType);
       ManagedStringProxy nameProxy = ManagedStringProxy.valueOf(name);
       long h = createFieldIn(rtp.handleIndex(), nameProxy.handleIndex());
       $class$<RT> p = new $class$<>(h, rtp, nameProxy);
       return p;
	}
	
	public $managed$Type valueType() {
	  return $managed$Type.INSTANCE;
	}
	
	@Override
    public ManagedStringProxy name() {
      if (name_ == null) {
        name_ = ManagedStringProxy.fromHandle(getNameHandle(handleIndex_));
      }
      return name_;
    }

	
	   
    @Override
    public RecordType<RT> recordType() {
      if (recordType_ == null) {
        recordType_ = RecordTypeProxy.<RT>fromHandle(getRecTypeHandle(handleIndex_));
      }
      return recordType_;
    }



$ifString({
    @Override
    public $managed$ get(RT record) {
	Task.addRead(record, this);
        long h = $class$.<RT>getValueHandle(handleIndex_, IsoContextProxy.current().handleIndex(), 
                                                     ManagedRecordProxy.handleOf(record));
       return ManagedStringProxy.fromHandle(h);
    \}
    public $managed$ peek(RT record) {
        long h = $class$.<RT>peekValueHandle(handleIndex_, IsoContextProxy.current().handleIndex(), 
                                                     ManagedRecordProxy.handleOf(record));
       return ManagedStringProxy.fromHandle(h);
    \}
},{
    @Override
    public $val()$ get$short$(RT record) {
        Task.addRead(record, this);
        $val()$ val = $class$.<RT>getValue(handleIndex_, IsoContextProxy.current().handleIndex(), 
                                                     ManagedRecordProxy.handleOf(record));
       return val;                         
    \}
    @Override
    public $val()$ peek$short$(RT record) {
        $val()$ val = $class$.<RT>peekValue(handleIndex_, IsoContextProxy.current().handleIndex(), 
                                                     ManagedRecordProxy.handleOf(record));
       return val;                         
    \}
})$
  @Override
  public void setToParent(RT rec) {
      setToParent(handleIndex_, IsoContextProxy.current().handleIndex(),
                      ManagedRecordProxy.handleOf(rec));
  }
  
  public void rollback(RT rec) {
      rollback(handleIndex_, IsoContextProxy.current().handleIndex(),
                      ManagedRecordProxy.handleOf(rec));
  }

  @Override
  public final boolean change(RT rec, $arg()$ expected, $arg()$ value) {
    return Stub.notImplemented();
  }
  @Override
  public final boolean change(RT rec, Holder<$boxed$> holdsExpected, $arg()$ value) {
    return Stub.notImplemented();
  }
$unlessString({  
  @Override
  public final boolean change(RT rec, $short$Holder holdsExpected, $arg()$ value) {
    return Stub.notImplemented();
  \}
})$  

$ifString({
	@Override
	public $managed$ set(RT rec, $managed$ val) {
		Task.addWrite(rec, this);
		setValueHandle(handleIndex_,
		                        IsoContextProxy.current().handleIndex(),
		                        ManagedRecordProxy.handleOf(rec),
					ManagedStringProxy.handleOf(val));
                return val;
	\}
	@Override
	public $managed$ getAndSet(RT rec, $managed$ val) {
		Task.addReadWrite(rec, this);
		long h = setValueHandle(handleIndex_,
		                        IsoContextProxy.current().handleIndex(),
		                        ManagedRecordProxy.handleOf(rec),
					ManagedStringProxy.handleOf(val));
                return ManagedStringProxy.fromHandle(h);					
	\}
},{
	@Override
	public $val()$ set(RT rec, $arg()$ val) {
		Task.addWrite(rec, this);
		setValue$whenString({Handle})$(handleIndex_, IsoContextProxy.current().handleIndex(),
		                ManagedRecordProxy.handleOf(rec), $toJNI({val})$);
                return val;
	\}
	@Override
	public $val()$ getAndSet(RT rec, $arg()$ val) {
		Task.addReadWrite(rec, this);
		return $fromJNI({setValue$whenString({Handle})$(handleIndex_, IsoContextProxy.current().handleIndex(),
		                ManagedRecordProxy.handleOf(rec), $toJNI({val})$)})$;
	\}
})$

$if(type.numeric)$
	@Override
	public $val()$ getAndInc(RT rec, $arg()$ by) {
		Task.addReadWrite(rec, this);
		return addValue$whenString({Handle})$(handleIndex_, IsoContextProxy.current().handleIndex(),
		                ManagedRecordProxy.handleOf(rec), $toJNI({by})$);
	}
	@Override
	public $val()$ inc(RT rec, $arg()$ by) {
                return $fromInt({getAndInc(rec, by)+by})$;
	}

	@Override
	public $val()$ getAndDec(RT rec, $arg()$ by) {
		Task.addReadWrite(rec, this);
		return subValue$whenString({Handle})$(handleIndex_, IsoContextProxy.current().handleIndex(),
		                ManagedRecordProxy.handleOf(rec), $toJNI({by})$);
	}
	@Override
	public $val()$ dec(RT rec, $arg()$ by) {
		return $fromInt({getAndDec(rec, by)-by})$;
	}

	@Override
	public $val()$ getAndMult(RT rec, $arg()$ by) {
		Task.addReadWrite(rec, this);
		return mulValue$whenString({Handle})$(handleIndex_, IsoContextProxy.current().handleIndex(),
		                ManagedRecordProxy.handleOf(rec), $toJNI({by})$);
	}
	@Override
	public $val()$ mult(RT rec, $arg()$ by) {
                return $fromInt({getAndMult(rec, by)*by})$;
	}

	@Override
	public $val()$ getAndDiv(RT rec, $arg()$ by) {
		Task.addReadWrite(rec, this);
		return divValue$whenString({Handle})$(handleIndex_, IsoContextProxy.current().handleIndex(),
		                ManagedRecordProxy.handleOf(rec), $toJNI({by})$);
	}
	@Override
	public $val()$ div(RT rec, $arg()$ by) {
                return $fromInt({getAndDiv(rec, by)/by})$;
	}
$endif$	

}

>>
