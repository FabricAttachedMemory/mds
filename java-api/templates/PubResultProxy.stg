/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
package() ::= "com.hpl.mds.impl"
class() ::= "PubResultProxy"

code(types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$contents(types.primTypes, types.maskedTypes, types)$
>>

addFieldConflict(t) ::= <<
private void add$t$FieldConflict(long recHandle, long fieldHandle) {
  log.debug("PubResultProxy.add$t$FieldConflict");
  FieldProxy.Change<ManagedRecord, ManagedObject> conflict = new FieldProxy.Change<>(recHandle, fieldHandle);
  conflicts.add(conflict);
}    
>>

addArrayConflict(t,params) ::= <<
private void add$t$ArrayConflict(long arrayHandle, long index) {
  log.debug("PubResultProxy.add$t$ArrayConflict");
  $t$ArrayProxy.Change$if(params)$<$params;separator={,}$>$endif$ conflict = new $t$ArrayProxy.Change$if(params)$<>$endif$(arrayHandle, index);
  conflicts.add(conflict);
}    
>>

addConflicts(t,params) ::= <<
$addFieldConflict(t)$

$addArrayConflict(t,params)$
>>

contents(prims, masked, types) ::= <<
package $package()$;

import java.util.HashSet;
import java.util.Set;
import org.apache.log4j.Logger;
import com.hpl.mds.PubResult;
import com.hpl.mds.ManagedRecord;
import com.hpl.mds.ManagedObject;
import com.hpl.mds.NativeLibraryLoader;

public class $class()$ extends Proxy implements PubResult {

  private static final NativeLibraryLoader NATIVE_LIB_LOADER = NativeLibraryLoader.getInstance();
  
  private static final Logger log = Logger.getLogger($class()$.class);

  IsoContextProxy sourceContext;
  IsoContextProxy targetContext;
  IsoContextProxy sourceSnapshotAtMerge;
  IsoContextProxy targetSnapshotAtMerge;
  IsoContextProxy lastCommonSnapshot;

  private Set<ChangeBase> conflicts;

  private static native long constructMergeResult();
  private static native long initializeMergeResult(PubResultProxy pubResultProxyObj, long hindex);
  private static native void destroyMergeResult(long hindex);
  private static native long sourceContextIndex(long hindex);
  private static native long targetContextIndex(long hindex);
  private static native long sourceSnapshotAtMergeIndex(long hindex);
  private static native long targetSnapshotAtMergeIndex(long hindex);
  private static native long lastCommonSnapshotIndex(long hindex);
  private static native boolean succeeded(long hindex);
  private static native int  numConflictsRemaining(long hindex);


  public PubResultProxy() {
    super(constructMergeResult());
    conflicts = new HashSet<>();
  }

  // associate new PubResultProxy java object with pr_merge_result
  public void initialize(long index) {
    initializeMergeResult(this, index);
  }

  @Override
  void releaseHandleIndex(long index) {
    destroyMergeResult(index);
  }

  @Override
  public IsoContextProxy sourceContext() {
    if (sourceContext == null) {
      sourceContext = IsoContextProxy.fromHandle(sourceContextIndex(handleIndex_));
    }
    return sourceContext;
  }

  @Override
  public IsoContextProxy targetContext() {
    if (targetContext == null) {
      targetContext = IsoContextProxy.fromHandle(targetContextIndex(handleIndex_));
    }
    return targetContext;
  }

  @Override
  public IsoContextProxy sourceSnapshotAtMerge() {
    if (sourceSnapshotAtMerge == null) {
      sourceSnapshotAtMerge = IsoContextProxy.fromHandle(sourceSnapshotAtMergeIndex(handleIndex_));
    }
    return sourceSnapshotAtMerge;
  }

  @Override
  public IsoContextProxy targetSnapshotAtMerge() {
    if (targetSnapshotAtMerge == null) {
      targetSnapshotAtMerge = IsoContextProxy.fromHandle(targetSnapshotAtMergeIndex(handleIndex_));
    }
    return targetSnapshotAtMerge;
  }

  @Override
  public IsoContextProxy lastCommonSnapshot() {
    if (lastCommonSnapshot == null) {
      lastCommonSnapshot = IsoContextProxy.fromHandle(lastCommonSnapshotIndex(handleIndex_));
    }
    return lastCommonSnapshot;
  }

  @Override
  public boolean succeeded() {
    return succeeded(handleIndex_);
  }

  public int numConflicts() {
    return numConflictsRemaining(handleIndex_);
    // or should we just do a flat count of conflicts size, resolved or not?
  }
  
  @Override
  public int numConflictsResolved() {
    // TODO
    return Stub.notImplemented();
  }

  @Override
  public int numConflictsRemaining() {
    return numConflictsRemaining(handleIndex_);
  }
  

  public Set<ChangeBase> conflicts() {
    return conflicts;
  }
  
  /**
   * 
   * @return true if all conflicts were resolved.
   */
  boolean resolve() {
    // TODO
    return Stub.notImplemented();
  }

  private void addNamespaceConflict(long nsHandle, long nameHandle) {
    log.debug("PubResultProxy.addNamespaceConflict");
    HNameImpl.Change conflict = new HNameImpl.Change(nsHandle, nameHandle);
    conflicts.add(conflict);
  }    

$masked: { type |
  $addConflicts(type.shortName,[])$
}
$
  $addConflicts({Record},{ManagedRecord})$
  $addFieldConflict({Array})$
}
>>
