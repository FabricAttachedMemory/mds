/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.generator;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroup;
import org.stringtemplate.v4.STGroupFile;

import com.hpl.erk.AutoFill;
import com.hpl.erk.PatternSwitch;
import com.hpl.erk.config.ConfigParam;
import com.hpl.erk.config.RunConfig;
import com.hpl.erk.formatters.SeqFormatter;
import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.util.CollUtils;
import com.hpl.erk.util.Patterns;
import com.hpl.erk.util.Strings;
import com.hpl.mds.generator.Types.ValueType;

public class Template implements AutoCloseable {
  final STGroup templateGroup;
  final String templateName;
  PrintWriter makefile;
  
  static ConfigParam<Set<FileType>> ttgP = RunConfig.setParam(FileType.class, "types")
      .defaultVal(CollUtils.setOf(FileType.values()));

  enum FileType {
    JAVA {
      final Path codeBase = Paths.get("generated-src");

      @Override
      public Path dir(Bound bound) {
        String pkg = bound.pkg();
        Path codeDir = codeBase.resolve(pkg.replaceAll("\\.", "/"));
        return codeDir;
      }

      @Override
      public String fileName(Bound bound, String className) {
        return className+".java";
      }
      @Override public boolean generateMakefile() {
        return false;
      }
      
    },
    CPP {
      final Path codeBase = Paths.get("jni/generated-src");

      @Override
      public Path dir(Bound bound) {
        return codeBase;
      }

      @Override
      public String fileName(Bound bound, String className) {
        return className+".cpp";
      }
      @Override public boolean generateMakefile() {
        return true;
      }

      
    },
    CPPH {
      final Path codeBase = Paths.get("jni/generated-src");

      @Override
      public Path dir(Bound bound) {
        return codeBase;
      }

      @Override
      public String fileName(Bound bound, String className) {
        return className+".h";
      }
      @Override public boolean generateMakefile() {
        return true;
      }
    };
    abstract Path dir(Bound bound);
    abstract String fileName(Bound bound, String className);
    abstract boolean generateMakefile();
    boolean used() {
      return ttgP.getVal().contains(this);
    }
  }

  static class NoOutput extends OutputStream {
    public void write(int b) {}
  }

  class Bound {
    public String className() {
      ST st = templateGroup.getInstanceOf("class");
      addTemplateArgs(st);
      String result = st.render();
      return result;
    }
    
    public FileType fileType() {
      ST st = templateGroup.getInstanceOf("lang");
      if (st == null) {
        return FileType.JAVA;
      }
      String s = st.render().toLowerCase();
      switch (s) {
      case "cpp":
      case "c++":
        return FileType.CPP;
      case "c++h":
      case "cpphh":
        return FileType.CPPH;
      default:
        return FileType.JAVA;
      }
    }


    public PrintWriter makefile() {
      if (makefile == null) {
        FileType ftype = fileType();
        if (ftype.generateMakefile()) {
          Path dir = ftype.dir(this);
          String fileName = String.format("%s.d", templateName);
          Path mf = dir.resolve(fileName);
          try {
            Files.createDirectories(dir);
            makefile = new PrintWriter(Files.newOutputStream(mf));
          } catch (IOException ex) {
            System.out.format("Couldn't write to %s, ignoring", mf);
          }
        }
        if (makefile == null) {
          makefile = new PrintWriter(new NoOutput());
        }
      }
      return makefile;
    }
    public String code() {
      ST st = templateGroup.getInstanceOf("code");
      addTemplateArgs(st);
      st.add("types", Types.types);
      String result = st.render();
      result = fixIncludes(result);
      return result;
    }
    protected void addTemplateArgs(ST st) {}

    public void generate() throws IOException {
      FileType ftype = fileType();
      if (!ftype.used()) {
        return;
      }
      String className = className();
      Path dir = ftype.dir(this);
      Files.createDirectories(dir);
      String fileName = ftype.fileName(this, className);
      Path outFile = dir.resolve(fileName);
      Path absFile = outFile.toAbsolutePath();
      System.out.format("Writing to %s%n", absFile);
      String code = code();
      try (BufferedWriter out = Files.newBufferedWriter(outFile, StandardCharsets.UTF_8)) {
        out.write(code);
      }
      PrintWriter mf = makefile();
      mf.format("$(generated_src_dir)/%s: $(generated_src_dir)/%s.d%n%n",
                fileName, templateName);
    }
    
    public String pkg() {
      ST st = templateGroup.getInstanceOf("package");
      addTemplateArgs(st);
      String result = st.render();
      return result;
    }


  }
  
  public static class ForType extends Template {
    public ForType(String name) {
      super(name);
    }
    
    Bound bind(ValueType type) {
      return new Bound() {
        @Override
        protected void addTemplateArgs(ST st) {
          st.add("type", type);
        }
      };
    }

    public void generate(ValueType type) throws IOException {
      bind(type).generate();
    }
    
    @Override
    public void generate() throws IOException {
      throw new UnsupportedOperationException("Must provide a type parameter");
    }
    

    
  }
  
  protected Template(String name) {
    templateName = name;
    Path templateFile = Generator.templateBase.resolve(name+".stg");
    templateGroup = new STGroupFile(templateFile.toString());
  }

  public void close() {
    if (makefile != null) {
        makefile.close();
    }
  }
  

  static final Pattern importRE = Pattern.compile("^\\s*import\\s+(.+)\\.(.+);");
  public String fixIncludes(String code) {
    List<String> beforeImports = new ArrayList<>();
    List<String> afterImports = new ArrayList<>();
    List<String> whitespace = new ArrayList<>();
    Map<String, Set<String>> imports = AutoFill.hashMapToHashSet();
    UnaryFunc<String,Void> rules = PatternSwitch.noVal()
    .onFind(importRE, (s, m) -> {
      whitespace.clear();
      final String pkg = m.group(1);
      final String className = m.group(2);
      imports.get(pkg).add(className);
    })
    .onMatch(Patterns.WS_PATTERN, (s) -> whitespace.add(s))
    .otherwise(s -> {
      if (imports.isEmpty()) {
        beforeImports.add(s);
      } else {
        afterImports.addAll(whitespace);
        afterImports.add(s);
        whitespace.clear();
      }
    });
    
//    Chain.from(Strings.intoLines(code))
//    .forEach(rules::call);
    
    for (String s : Strings.intoLines(code)) {
      rules.call(s);
    }

    String val = SeqFormatter.lines()
        .addAll(beforeImports)
        .addAll(reorder(imports))
        .addAll(afterImports)
        .toString();

    return val;
  }


  private static List<String> reorder(Map<String, Set<String>> imports) {
    final Function<? super Entry<String, Set<String>>, ? extends Stream<String>> sortClasses =
        e -> {
          String pkg = e.getKey();
          Set<String> classes = e.getValue();
          return Stream.concat(classes.stream()
                               .sorted()
                               .map(c -> String.format("import %s.%s;", pkg, c)),
                               Stream.of(""));
        };
    return imports.entrySet().stream()
      .sorted(Comparator.comparing(Entry::getKey))
      .flatMap(sortClasses)
      .collect(Collectors.toList());
  }


  public void generate() throws IOException {
    new Bound().generate();
  }
}
