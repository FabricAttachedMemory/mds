/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.mash;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInput;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.TreeSet;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import com.hpl.erk.impl_helper.CompareToImpl;
import com.hpl.erk.util.Strings;

public class UniformTableTitleMatcher extends MASH_Algorithm64 {
  public static boolean TRACE = false; 
  private static int CLASS_ID = 0x7641f740;
  private static int DUMP_VERSION = 6;

  
  private final UniformLookupTable table;
  private final HashSet<Long> stopwordHashes;

  public static class Match implements Comparable<Match> {
    private final String string;
    private final long hash;
    private final int length;
    private final int index;
    private final int data;
    Match(String s, int nWords, long h, int i, int d) {
      length = nWords;
      string = s;
      hash = h;
      index = i;
      data = d;
    }
    public String getString() {
      return string;
    }
    @Override
    public String toString() {
      return String.format("#Match(%d: \"%s\" #%,d %016x [%,d]", length, string, index, hash, data);
    }
    public long getHash() {
      return hash;
    }
    public int getLength() {
      return length;
    }
    public int getIndex() {
      return index;
    }
    public int getData() {
      return data;
    }
    /**
     * Prefer the largest number of words, then the longest string
     */
    public int compareTo(Match other) {
      return CompareToImpl.notNull(this, other)
          .compare(other.length, length)
          .compare(other.string, string, Strings.length())
          .compare(string, other.string)
          .value();
    }
    @Override
    public int hashCode() {
      return string.hashCode();
    }
  }

 /* public static class MatchSet implements Iterable<Match> {
    private final Set<Match> set = new TreeSet<Match>();
    @Override
    public Iterator<Match> iterator() {
      return new Iterator<String>() {
        final Iterator<Match> iter = set.iterator();
        @Override
        public boolean hasNext() {
          return iter.hasNext();
        }

        @Override
        public String next() {
          return iter.next().string;
        }

        @Override
        public void remove() {
          iter.remove();
        }
      };
    }
    public String[] toArray() {
      String[] strings = new String[set.size()];
      int i=0;
      for (Match ms : set) {
        strings[i++] = ms.string;
      }
      return strings;
    }
    void add(Match ms) {
      set.add(ms);
    }
  }
  */

  public UniformTableTitleMatcher(UniformLookupTable t, Collection<Long> sw, long[] charMap) {
    super(charMap);
    table = t;
    stopwordHashes = new HashSet<Long>(sw);
  }
  public UniformTableTitleMatcher(DataInput in, int nKeyBytes) throws IOException {
    super(in);
    table = UniformLookupTable.fromDump(nKeyBytes, in);
    int nStopwords = in.readInt();
    if (nStopwords > 0) {
      stopwordHashes = new HashSet<Long>();
      for (int i=0; i<nStopwords; i++) {
        long h = in.readLong();
        stopwordHashes.add(h);
      }
    } else {
      stopwordHashes = null;
    }

  }
  public static UniformTableTitleMatcher fromDumpFile(File f) throws IOException {
    return fromDumpFile(f, -1);
  }

  public static UniformTableTitleMatcher fromDumpFile(File f, int nKeyBytes) throws IOException {
    final FileInputStream fis = new FileInputStream(f);
    return fromDumpStream(fis, nKeyBytes);
  }
  
  public static UniformTableTitleMatcher fromDumpStream(InputStream fis) throws IOException {
    return fromDumpStream(fis, -1);
  }
  public static UniformTableTitleMatcher fromDumpStream(InputStream fis, int nKeyBytes) throws IOException {
    final GZIPInputStream gis = new GZIPInputStream(fis);
    final DataInputStream in = new DataInputStream(new BufferedInputStream(gis));
    int cid = in.readInt();
    if (cid != CLASS_ID) {
      throw new IOException(String.format("Wrong class id.  Expected %08x, got %08x", CLASS_ID, cid));
    }
    int v = in.readInt();
    if (v != DUMP_VERSION) {
      throw new IOException(String.format("Wrong dump format version.  Expected %08x, got %08x", 
          DUMP_VERSION, v));
    }
    return new UniformTableTitleMatcher(in, nKeyBytes);
  }
  
  public int size() {
	return table.size();
  }

  @Override
protected final boolean isStopword(long hash) {
    return stopwordHashes != null && stopwordHashes.contains(hash);
  }
  
  public Match checkWholeString(CharSequence str) {
	  ArrayList<Word> words = words(str);
	  long hash = mash(words);
      int index = table.lookup(hash);
      if (index < 0) {
    	  return null;
      }
      return new Match(str.toString(), words.size(), hash, index, table.valAt(index));
  }
  
  public <T extends CharSequence>Set<Match> checkAll(Iterable<T> strings) {
    Set<Match> matches = new TreeSet<Match>();
    for (T s : strings) {
      ArrayList<Word> words = words(s);
      int len = words.size();
      int coveredThrough = -1;
      OUTER:
      for (int i=0; i<len; i++) {
        long hash = 0;
        int lastMatchTo = 0;
        long lastMatchHash = 0;
        int lastMatchIndex = -1;
        for (int j=i; j<len; j++) {
          Word w = words.get(j);
          if (!w.isStopword) {
            hash = (hash >> 1) ^ w.hash;
            if (hash != 0 && j>coveredThrough) {
              int index = table.lookup(hash);
              if (index >= 0) {
                lastMatchTo = words.get(j).to;
                lastMatchHash = hash;
                lastMatchIndex = index;
                coveredThrough = j;
                if (TRACE) {
                  int from = words.get(i).from;
                  String sub = s.subSequence(from, lastMatchTo).toString();
                  System.out.format("> [%016x] %s%n", lastMatchHash, sub);
                }
              }
            }
          } else if (j==i) {
            continue OUTER;
          }
        }
        if (lastMatchHash != 0) {
          int from = words.get(i).from;
          String sub = s.subSequence(from, lastMatchTo).toString();
          matches.add(new Match(sub, coveredThrough-i+1, lastMatchHash, lastMatchIndex, table.valAt(lastMatchIndex)));
        }
      }
    }
    return matches;
  }
  public Set<Match> check(String s) {
    return checkAll(Collections.singleton(s));
  }
  
  
  
  @Override
  public void dumpTo(DataOutput out) throws IOException {
    super.dumpTo(out);
    table.dumpTo(out);
    if (stopwordHashes == null) {
      out.writeInt(0);
    } else {
      out.writeInt(stopwordHashes.size());
      for (long h : stopwordHashes) {
        out.writeLong(h);
      }
    }
  }
  
  public void dumpTo(File f) throws IOException {
    final FileOutputStream fos = new FileOutputStream(f);
    final GZIPOutputStream gos = new GZIPOutputStream(fos);
    final BufferedOutputStream bos = new BufferedOutputStream(gos);
    DataOutput out = new DataOutputStream(bos);
    out.writeInt(CLASS_ID);
    out.writeInt(DUMP_VERSION);
    dumpTo(out);
    bos.close();
    fos.close();
  }

}
