/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/**
 * 
 */
package com.hpl.erk.mash;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;

import com.hpl.erk.mash.UniformLookupTable.KeyValPair;

public final class ClosedLongHashMap {
  private static final double LOAD_FACTOR = 0.75;
//private static final int DOTFREQ = 1024*1024;
  @SuppressWarnings("unused")
  private static final int DOTFREQ = 64*1024;
  private int capacity;
  private int size = 0;
  private int mask;
  private long[] keys;
  private IntSubtypeArray vals;
  private int threshold;


  public ClosedLongHashMap(int expected, int nValBytes) {
    capacity = roomFor(expected);
    keys = new long[capacity];
    vals = new IntSubtypeArray(nValBytes, capacity);
    mask = capacity-1;
    threshold = (int)(capacity*LOAD_FACTOR);
  }
  

  public ClosedLongHashMap(DataInput in) throws IOException {
    capacity = in.readInt();
    int nElts = in.readInt();
    int nValBytes = in.readInt();
    mask = capacity-1;
    threshold = (int)(capacity*LOAD_FACTOR);
    keys = new long[capacity];
    vals = new IntSubtypeArray(nValBytes, capacity);
    for (int i=0; i<nElts; i++) {
      long key = in.readLong();
      int val = nValBytes == 0 ? -1 : in.readInt();
      put(key, val);
    }
  }

  public void dumpTo(DataOutput out) throws IOException {
    out.writeInt(capacity);
    out.writeInt(size);
    final int valSize = vals.bytesPerElt();
    out.writeInt(valSize);
    for (int i=0; i<capacity; i++) {
      final long key = keys[i];
      if (key != 0) {
        out.writeLong(key);
        vals.writeValTo(out, i);
      }
    }
  }
  private int findIndex(long hash) {
    long key;
    for (int i=(int) (hash & mask); (key = keys[i]) != 0; i = (i+1) & mask) {
      if (key == hash) {
        return i;
      }
    }
    return -1;
  }
  public boolean containsKey(long hash) {
    int index = findIndex(hash);
    return index >= 0;
  }
  public int get(long hash) {
    int index = findIndex(hash);
    if (index >= 0) {
      return vals.val(index);
    }
    return -1;
  }
  
  public void put(long k, int val) {
    long key;
    int i;
    for (i=(int) (k & mask); (key = keys[i]) != 0; i = (i+1) & mask) {
      if (key == k) {
    	vals.setVal(i, val);
        return;
      }
    }
    keys[i] = k;
    vals.setVal(i, val);
    if (++size > threshold) {
      resizeTo(capacity*2);
    }
  }
  public void add(long k) {
    
    long key;
    int i;
    for (i=(int) (k & mask); (key = keys[i]) != 0; i = (i+1) & mask) {
      if (key == k) {
        return;
      }
      i = (i+1) & mask;
    }
    keys[i] = k;
    if (++size > threshold) {
      resizeTo(capacity*2);
    }
  }
  private void resizeTo(int newCap) {
    if (capacity == newCap) {
      return;
    }
    int oldCap = capacity;
    capacity = newCap;
    mask = capacity-1;
    threshold = (int)(capacity*LOAD_FACTOR);
    long[] oldKeys = keys;
    keys = new long[capacity];
    for (int i=0; i<oldCap; i++) {
      long k = oldKeys[i];
      if (k != 0) {
        add(k);
      }
    }
  }

  public void compact() {
    resizeTo(roomFor(size));
  }
  private static int roomFor(int n) {
    n /= LOAD_FACTOR;
    int cap;
    for (cap=1; cap<n; cap<<=1) {}
    return cap;
  }
  public int size() {
    return size;
  }
  
  public static interface Filter {
	  boolean keep(long hash, int val);
  }
  
  public UniformLookupTable toLookupTable(int nKeyBytes, int nValBytes, Filter filter) {
    long[] keysArray = new long[size];
    int[] valsArray = new int[size];
    int next = 0;
    for (int i=0; i<capacity; i++) {
      long k = keys[i];
      if (k != 0) {
    	int val = vals.val(i);
		if (filter != null && !filter.keep(k, val)) {
    		continue;
    	}
        keysArray[next] = k;
        valsArray[next] = val;
        next++;
      }
    }
    final Iterable<KeyValPair> iterable = new UniformLookupTable.PairedArrayIterator(keysArray, valsArray);
    return new UniformLookupTable(nKeyBytes, nValBytes, iterable, size);
  }
  public UniformLookupTable toLookupTable(int nKeyBytes) {
	  return toLookupTable(nKeyBytes, vals.bytesPerElt(), null);
  }  
  public long[] toArray(long[] array) {
    if (array == null || array.length < size) {
      array = new long[size];
    }
    int next = 0;
    for (int i=0; i<capacity; i++) {
      long k = keys[i];
      if (k != 0) {
        array[next++] = k;
      }
    }
    return array;
  }
  public long[] toArray() {
    return toArray((long[])null);
  }
  
  
  final public int nMatching(Filter filter) {
	  int count = 0;
	  for (int i=0; i<capacity; i++) {
		  long k = keys[i];
		  int val = vals.val(i);
		  if (k != 0 && filter.keep(k, val)) {
			  count++;
		  }
	  }
	  return count;
  }
  public long[] matchingKeys(Filter filter) {
	  int n = nMatching(filter);
	  long[] array = new long[n];
	  int next = 0;
	  for (int i=0; i<capacity; i++) {
		  long k = keys[i];
		  if (k != 0 && filter.keep(k, vals.val(i))) {
			  array[next++] = k;
		  }
	  }
	  return array;
  }
}