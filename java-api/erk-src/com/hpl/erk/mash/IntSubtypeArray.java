/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/**
 * 
 */
package com.hpl.erk.mash;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;

public final class IntSubtypeArray {
  private final byte[] bytes;
  private final int bytesPerElt;
  private final int nElts;
  
  public IntSubtypeArray(int b, int n) {
    bytesPerElt = b;
    nElts = n;
    bytes = new byte[b*n];
  }
  
  public int size() {
    return nElts;
  }
  public int bytesPerElt() {
    return bytesPerElt;
  }
  public int val(int pos) {
    int v = 0;
    final int bpe = bytesPerElt;
    int b = pos*bpe;
    final byte[] bytes = this.bytes;
    for (int i=0; i<bpe; i++) {
      v = (v<<8) | (bytes[b++] & 0xFF);
    }
    return v;
  }
  
  public boolean matches(int pos, int n) {
    final int bpe = bytesPerElt;
    final byte[] bytes = this.bytes;
    int bp = (pos+1)*bpe-1;
    for (int i=0; i<bpe; i++) {
      byte nb = (byte)(n & 0xFF);
      n >>= 8;
      byte vb = bytes[bp--];
      if (nb != vb) {
        return false;
      }
    }
    return true;
  }
  
  public void setVal(int pos, int v) {
    final int bpe = bytesPerElt;
    int bp = (pos+1)*bpe-1;
    final byte[] bytes = this.bytes;
    for (int i=0; i<bpe; i++) {
      byte b = (byte) (v & 0xFF);
      bytes[bp--] = b;
      v >>= 8;
    }
  }
  public static int readSingleVal(DataInput in, int bytesPerElt) throws IOException {
    int v = 0;
    final int bpe = bytesPerElt;
    for (int i=0; i<bpe; i++) {
      int b = in.readByte() & 0xFF;
      v = (v<<8) | b;
    }
    return v;
  }
  public void writeValTo(DataOutput out, int pos) throws IOException {
    out.write(bytes, pos*bytesPerElt, bytesPerElt);
  }
  public void readValFrom(DataInput in, int pos) throws IOException {
    in.readFully(bytes, pos*bytesPerElt, bytesPerElt);
  }
  public void writeTo(DataOutput out) throws IOException {
    out.write(bytes);
  }
  public void readFrom(DataInput in) throws IOException {
    in.readFully(bytes);
  }
}

