/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/**
 * 
 */
package com.hpl.erk.mash;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import com.hpl.erk.text.Normalizer;

public class CharMapGenerator64 {
  public static int DEFAULT_SEED = "Palo Alto".hashCode();
  
  public static class Descriptor {
    public final long seed;
    public final boolean allowDigits;
    public final boolean lowerCase;
    public final char[] ignored;
    public final char[] omitted;
    public final char[] allowed;
    public final char[] mapped;
    public final char[] mappedTo;
    
    private static class Normal extends CharMapGenerator64 {
      private final boolean allowDigits;
      private final boolean lowerCase;
      public Normal(boolean allowDigits, boolean lowerCase) {
        this.allowDigits = allowDigits;
        this.lowerCase = lowerCase;
      }
      
      @Override
      public boolean allowDigits() {
        return allowDigits;
      }
      @Override
      public boolean lowerCaseLetters() {
        return lowerCase;
      }
    }
    
    public Descriptor(CharMapGenerator64 gen) {
      seed = gen.getSeed();
      allowDigits = gen.allowDigits();
      lowerCase = gen.lowerCaseLetters();
      ArrayList<Character> ignoredList = new ArrayList<Character>();
      ArrayList<Character> allowedList = new ArrayList<Character>();
      ArrayList<Character> omittedList = new ArrayList<Character>();
      ArrayList<Character> mappedList = new ArrayList<Character>();
      ArrayList<Character> mappedToList = new ArrayList<Character>();
      Normal normal = new Normal(allowDigits, lowerCase);

      for (int i = Character.MIN_CODE_POINT; i < 0xFFFF; i++) {
        char c = (char) i;
        if (gen.ignore(c)) {
          ignoredList.add(c);
        } else {
          char normalized = gen.normalize(c);
          char expected = normal.normalize(c);
          if (normalized != expected) {
            if (normalized == 0) {
              omittedList.add(c);
            } else if (expected == 0 & normalized == c) {
              allowedList.add(c);
            } else {
              mappedList.add(c);
              mappedToList.add(normalized);
            }
          }
        }
      }
      allowed = freeze(allowedList);
      ignored = freeze(ignoredList);
      omitted = freeze(omittedList);
      mapped = freeze(mappedList);
      mappedTo = freeze(mappedToList);
    }
    
    
    
    private Descriptor(long seed, boolean allowDigits, boolean lowerCase,
        char[] ignored, char[] omitted, char[] allowed, char[] mapped,
        char[] mappedTo) {
      super();
      this.seed = seed;
      this.allowDigits = allowDigits;
      this.lowerCase = lowerCase;
      this.ignored = ignored;
      this.omitted = omitted;
      this.allowed = allowed;
      this.mapped = mapped;
      this.mappedTo = mappedTo;
    }



    public Generic generator() {
      Generic g = new Generic(seed, allowDigits, lowerCase,
          thaw(ignored), thaw(omitted), thaw(allowed), thaw(mapped, mappedTo));
      return g;
    }
    
    @Override
    public String toString() {
      String lc = lowerCase ? ", lc" : "";
      String ad = allowDigits ? ", dig"  : "";
      String ign = describe("ignore", ignored);
      String omit = describe("omit", omitted);
      String allow = describe("allow", allowed);
      String map = describe("map", mapped, mappedTo);
      return String.format("#CMap[%d%s%s%s%s%s%s]", seed, lc, ad, ign, omit, allow, map);
    }

    private static String describe(String tag, char[] from, char[] to) {
      if (from == null) {
        return "";
      }
      StringBuilder bldr = new StringBuilder();
      bldr.append(", ");
      bldr.append(tag);
      bldr.append(": <");
      for (int i=0; i<from.length; i++) {
        bldr.append(' ');
        bldr.append(from[i]);
        bldr.append(':');
        bldr.append(to[i]);
      }
      bldr.append(" >");
      return bldr.toString();
    }

    private static String describe(String tag, char[] array) {
      if (array == null) {
        return "";
      }
      StringBuilder bldr = new StringBuilder();
      bldr.append(", ");
      bldr.append(tag);
      bldr.append(": <");
      for (char c : array) {
        bldr.append(' ');
        bldr.append(c);
      }
      bldr.append(" >");
      return bldr.toString();
    }

    private static Set<Character> thaw(char[] array) {
      if (array == null) {
        return Collections.emptySet();
      }
      int length = array.length;
      if (length == 0) {
        return Collections.emptySet();
      }
      final Set<Character> val = new HashSet<Character>(length);
      for (char c : array) {
        val.add(c);
      }
      return val;
    }

    private static Map<Character, Character> thaw(char[] from, char[] to) {
      if (from == null) {
        return Collections.emptyMap();
      }
      int length = from.length;
      if (length == 0) {
        return Collections.emptyMap();
      }
      final Map<Character,Character> val = new HashMap<Character,Character>(length);
      for (int i=0; i<length; i++) {
        val.put(from[i], to[i]);
      }
      return val;
    }

    private static char[] freeze(ArrayList<Character> list) {
      int len = list.size();
      if (len == 0) {
        return null;
      }
      char[] array = new char[len];
      for (int i=0; i<len; i++) {
        array[i] = list.get(i);
      }
      return array;
    }
    
    public void dumpTo(DataOutput out) throws IOException {
      out.writeLong(seed);
      out.writeBoolean(allowDigits);
      out.writeBoolean(lowerCase);
      dumpTo(out, allowed);
      dumpTo(out, ignored);
      dumpTo(out, omitted);
      dumpTo(out, mapped);
      dumpTo(out, mappedTo);
    }
    
    public static Descriptor loadFrom(DataInput in) throws IOException {
      long seed = in.readLong();
      boolean allowDigits = in.readBoolean();
      boolean lowerCase = in.readBoolean();
      char[] allowed = readArray(in);
      char[] ignored = readArray(in);
      char[] omitted = readArray(in);
      char[] mapped = readArray(in);
      char[] mappedTo = readArray(in);
      Descriptor d = new Descriptor(seed, allowDigits, lowerCase, ignored, omitted, allowed, mapped, mappedTo);
      return d;
    }

    private static char[] readArray(DataInput in) throws IOException {
      int len = in.readInt();
      if (len == 0) {
        return null;
      }
      char[] array = new char[len];
      for (int i=0; i<len; i++) {
        array[i] = in.readChar();
      }
      return array;
    }



    private static void dumpTo(DataOutput out, char[] array) throws IOException {
      if (array == null) {
        out.writeInt(0);
        return;
      }
      out.writeInt(array.length);
      for (char c : array) {
        out.writeChar(c);
      }
    }
  }
  
  public static class Generic extends CharMapGenerator64 {
    private final long seed;
    private final boolean allowDigits;
    private final boolean lowerCase;
    private final Set<Character> ignored;
    private final Set<Character> omitted;
    private final Set<Character> allowed;
    private final Map<Character, Character> mapped;
    public Generic(long seed, boolean allowDigits, boolean lowerCase,
        Set<Character> ignored, Set<Character> omitted, Set<Character> allowed,
        Map<Character, Character> mapped) {
      super();
      this.seed = seed;
      this.allowDigits = allowDigits;
      this.lowerCase = lowerCase;
      this.ignored = ignored;
      this.omitted = omitted;
      this.allowed = allowed;
      this.mapped = mapped;
    }
    
    @Override
    public long getSeed() {
      return seed;
    }
    @Override
    public boolean allowDigits() {
      return allowDigits;
    }
    @Override
    public boolean lowerCaseLetters() {
      return lowerCase;
    }
    @Override
    public boolean omit(char c) {
      return omitted.contains(c);
    }
    @Override
    public boolean ignore(char c) {
      return ignored.contains(c);
    }
    @Override
    public boolean allow(char c) {
      return allowed.contains(c);
    }
    @Override
    public char normalize(char c) {
      Character nc = mapped.get(c);
      if (nc != null) {
        return nc;
      }
      return super.normalize(c);
    }
  }

  /** A version that hashes *all* String characters together into one hash (never makes word breaks).  Useful for String hash codes, as long as the string isn't too long (<64 chars). */
  public static class AllChars extends CharMapGenerator64 {
	@Override
	public boolean lowerCaseLetters() {
		return false;
	}
	@Override
	public char normalize(char c) {
	  if (Character.isLetter(c)) {
		return normalizeLetter(c);
	  } else {
		return c;
	  }
	}
	@Override
	public long[] generate() {
		final long[] rr = super.generate();
		rr[0] = new Random(47).nextLong();// just finish by plugging the NULL character hole
		return rr;
	}
  }
  
  /** A version that hashes all *lowercased* String characters *with accents removed* and never makes a word break.  Useful for String hash codes, as long as the string isn't too long (<64 chars). */
  public static class AllFoldedChars extends AllChars {
	@Override
	public boolean lowerCaseLetters() {
		return true;
	}
	@Override
	public boolean mapAccents() {
		return true;
	}
  }
  
  public static class Seeded extends CharMapGenerator64 {
	  private long seed;
	  public Seeded(long seed) {
		  this.seed = seed;
	  }
	  @Override
	  public long getSeed() {
		  return seed;
	  }
  }
  
  public long[] generate() {
    Random rnd = new Random(getSeed());
    final int nChars = 1<<16;
    long[] randomTable = new long[nChars];
    for (int i=0; i<nChars; i++) {
      randomTable[i] = rnd.nextLong();
    }
    long[] map = new long[nChars];
    for (int i=0; i<nChars; i++) {
      char chr = (char)i;
      if (ignore(chr)) {
        map[i] = MASH_Algorithm64.IGNORE_CHAR;
      } else {
        char c = normalize(chr);
        if (c != 0 && !omit(c)) {
          map[i] = randomTable[c];
        }
      }
    }
    return map;
  }
  
  public boolean omit(char c) {
    return false;
  }

  public  boolean lowerCaseLetters() {
    return true;
  }

  public boolean allowDigits() {
    return true;
  }
  
  public boolean mapAccents() {
    return false;
  }

  public char normalize(char c) {
    if (Character.isLetter(c)) {
      return normalizeLetter(c);
    } else if (allowDigits() && Character.isDigit(c)) {
      return normalizeDigit(c);
    } else if (allow(c)) {
      return c;
    } else {
      return 0;
    }
  }

  public char normalizeLetter(char c) {
    if (lowerCaseLetters()) {
      c = Character.toLowerCase(c);
    }
    if (mapAccents()) {
      c = mapAccents(c);
    }
    return c;
  }
  
  public boolean ignore(char c) {
    return false;
  }
  
  public boolean allow(char c) {
    return false;
  }

  protected char mapAccents(final char c) {
	  return Normalizer.mapAccentsAway(c);
  }

  protected char normalizeDigit(char c) {
    return c;
  }

  public long getSeed() {
    return DEFAULT_SEED;
  }
}
