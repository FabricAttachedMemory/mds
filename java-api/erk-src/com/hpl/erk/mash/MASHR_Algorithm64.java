/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.mash;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import cern.colt.list.LongArrayList;

import com.hpl.erk.util.Strings;

public class MASHR_Algorithm64 {

  /** a public singleton high-quality short-String hasher that hashes all characters together.  Clients may wish to call mashString(). */
  public static final MASHR_Algorithm64 hashall = new MASHR_Algorithm64(new CharMapGenerator64.AllChars());
  
  /**
   * a character with this mapping will be completely ignored by the algorithm.
   */
  public static final long IGNORE_CHAR = 1L;

  private final long[] charMap;
//  protected Handler addTargetHandler;
//  protected Handler checkStringHandler;

  /**
   * A string handler, easily customizable by the subclass.
   * 
   * Note: the extend(long,long) call is only to extend whole word results, not for extending each character.
   * First of all, we don't want the overhead.  Line 44 is called on every word character. It needs to be fixed.  
   * extend() is used to combine successive words and the reason that it's not fixed is that different applications might want to have different rules for doing this.  The default implementation is a bit different from line 37 (an XOR rather than an addition).  This is to make a single-character word different from just adding that character to the preceding word (e.g., "3.5" different from "35", which is the example that caused me to realize that we probably wanted them to be different).  If you want it to be the same, you'd redefine extend() (or simply not call it).  If you want word order to not be significant, you could just do an addition or XOR without doing the shift.  Etc.
   */
  public abstract class Handler {
    public CharSequence start(CharSequence s) {
      return s;
    }
    public void end() {}
    public abstract boolean see(long hash, int from, int to);
    public void process(final CharSequence sOrig) {
      final long[] map = charMap;
      final CharSequence s = start(sOrig);
      final int len = s.length();
      long hash = 0;
      int start = 0;
      for (int i=0; i<len; i++) {
        char c = s.charAt(i);
        long mapped = map[c];
        if (mapped == 0) {
          if (hash != 0) {
            final boolean keepGoing = see(hash, start, i);
            hash = 0;
            if (!keepGoing) {
              break;
            }
          }
          start = i+1;
        } else if (mapped != IGNORE_CHAR) {
          long lob = hash & 1;
          hash = ((hash >>> 1) ^ (lob<<63)) + mapped;
        }
      }
      if (hash != 0) {
        see(hash, start, len);
      }
      end();
    }
    public long extend(long oldHash, long newHash) {
      long lob = oldHash & 1;
      return ((oldHash >>> 1) ^ (lob<<63)) ^ newHash;
    }
  }

  protected static class Word {
    public final long hash;
    public final int from;
    public final int to;
    public final boolean isStopword;
    Word(long h, int from, int to, boolean swp) {
      hash = h;   
      this.from = from;
      this.to = to;
      isStopword = swp;
    }
    @Override
    public String toString() {
      return String.format("#{%016x %d-%d%s}", hash, from, to, Strings.flagWhen(isStopword, "!"));
    }
  }

  public MASHR_Algorithm64(long[] map) {
    charMap = map;
  }
  
  public MASHR_Algorithm64(CharMapGenerator64 gen) {
    charMap = gen.generate();
  }
  
  public MASHR_Algorithm64(DataInput in) throws IOException {
    int tableSize = in.readInt();
    charMap = new long[tableSize];
    for (int i=0; i<tableSize; i++) {
      charMap[i] = in.readLong();
    }
  }
  
//  public abstract Handler addTargetHandler();
//  public abstract Handler checkStringHandler();
  
//  public Handler getAddTargetHandler() {
//    if (addTargetHandler == null) {
//      addTargetHandler = addTargetHandler();
//    }
//    return addTargetHandler;
//  }
//  public Handler getCheckStringHandler() {
//    if (checkStringHandler == null) {
//      checkStringHandler = checkStringHandler();
//    }
//    return checkStringHandler;
//  }
  
  public long[] getCharMap() {
    return charMap;
  }
  
  public void dumpTo(DataOutput out) throws IOException {
    out.writeInt(charMap.length);
    for (int i=0; i<charMap.length; i++) {
      out.writeLong(charMap[i]);
    }
  }
  
  /** Clients may override this for their title-word recognition applications.  Not needed if you juse use mashString,mashChars, or mashSequence. */
  protected boolean isStopword(long hash) {
	  return false;
  }

  protected ArrayList<Word> words(final CharSequence s) {
    final ArrayList<Word> list = new ArrayList<Word>();
    Handler h = new Handler() {
      @Override
      public boolean see(long hash, int from, int to) {
        Word w = new Word(hash, from, to, isStopword(hash));
        list.add(w);
        return true;
      }
    };
    h.process(s);
    return list;
  }

  /** @return MASH hash value for the string/title */
  public long mash(CharSequence s) {// 11-11-08 gforman factored
	    ArrayList<Word> words = words(s);
	    return mash(words);
  }
  
  public long mash(List<Word> words) {
	    long hash = 0;
	    for (Word w : words) {
	      if (!w.isStopword) {
	        long lob = hash & 1;
	        hash = ((hash >>> 1) ^ (lob<<63)) ^ w.hash;
	      }
	    }
	    return hash;
  }

  public long mash(List<Word> words, int from, int to) {
    long hash = 0;
    if (from == 0 && to == words.size()) {
      return mash(words);
    }
    for (Word w : words.subList(from, to)) {
      if (!w.isStopword) {
        long lob = hash & 1;
        hash = ((hash >>> 1) ^ (lob<<63)) ^ w.hash;
      }
    }
    return hash;
  }

  public long mash(Word[] words, int from, int to) {
    long hash = 0;
    for (int i=from; i<to; i++) {
      Word w = words[i];
      if (!w.isStopword) {
        long lob = hash & 1;
        hash = ((hash >>> 1) ^ (lob<<63)) ^ w.hash;
      }
    }
    return hash;
  }

  public long mashString(String s) {
	char[] buf = new char[s.length()];
	s.getChars(0, s.length(), buf, 0);
	return mashChars(buf);
  }

  public long mashChars(char[] buf) {
	final long[] map = charMap;
	long hash = 0;
	for (char c: buf) {
		long mapped = map[c];
		if (mapped == IGNORE_CHAR) {
		  continue;
		}
		long lob = hash & 1;
		hash = ((hash >>> 1) ^ (lob<<63)) + mapped;
	}
	return hash;
  }

  public long mashSequence(CharSequence s) {
	if (s instanceof String) {
		return mashString((String)s);
	}
	final long[] map = charMap;
	final int len = s.length();
	long hash = 0;
	for (int i=0; i<len; i++) {
		char c = s.charAt(i);
		long mapped = map[c];
		if (mapped == IGNORE_CHAR) {
		  continue;
		}
		long lob = hash & 1;
		hash = ((hash >>> 1) ^ (lob<<63)) + mapped;
	}
	return hash;
  }
  
  public final long updateHash(char c, long hash) {
    long mapped = charMap[c];
    return updateHash(mapped, hash);
  }
  
  public static long updateHash(long mapped, long oldHash) {
    if (mapped == IGNORE_CHAR) {
      return oldHash;
    }
    final long lob = oldHash & 1;
    final long newHash = ((oldHash >>> 1) ^ (lob<<63)) + mapped;
    return newHash;
  }
  
  public boolean ignored(char c) {
    return charMap[c] == IGNORE_CHAR;
  }
  
  public static boolean ignored(long mapped) {
    return mapped == IGNORE_CHAR;
  }
  
  public long mappedChar(char c) {
    return charMap[c];
  }

  public static boolean isSeparator(long mapped) {
    return mapped == 0;
  }
  
  public boolean isSeparator(char c) {
    long mapped = charMap[c];
    return isSeparator(mapped);
  }
  
  public long[] codes(char[] chars) {
    LongArrayList list = new LongArrayList(chars.length);
    final long[] map = charMap;
    for (char c : chars) {
      long mapped = map[c];
      if (mapped != IGNORE_CHAR) {
        list.add(mapped);
      }
    }
    list.trimToSize();
    return list.elements();
  }

  public long[] codes(String s) {
    char[] buf = new char[s.length()];
    s.getChars(0, s.length(), buf, 0);
    return codes(buf);
  }

  public long[] codes(CharSequence s) {
    if (s instanceof String) {
        return codes((String)s);
    }
    final long[] map = charMap;
    final int len = s.length();
    LongArrayList list = new LongArrayList(len);
    for (int i=0; i<len; i++) {
      char c = s.charAt(i);
      long mapped = map[c];
      if (mapped != IGNORE_CHAR) {
        list.add(mapped);
      }
    }
    list.trimToSize();
    return list.elements();
  }
  
}
