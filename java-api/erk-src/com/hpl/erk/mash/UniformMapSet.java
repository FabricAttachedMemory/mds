/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.mash;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import com.hpl.erk.mash.UniformMap.Decoder;
import com.hpl.erk.mash.UniformMap.Encoder;

public class UniformMapSet<T> {
  private final UniformMap<T>[] maps;

  private UniformMapSet(UniformMap<T>[] maps) {
    this.maps = maps;
  }
  
  public int nMaps() {
    return maps.length;
  }
  
  public int size(int which) {
    return map(which).size();
  }
  
  public int size() {
    int s = 0;
    for (UniformMap<T> map : maps) {
      s += map.size();
    }
    return s;
  }
  
  public int index(int which, long hash) {
    return map(which).index(hash);
  }

  public UniformMap<T> map(int which) {
    return maps[which];
  }
  
  public boolean containsKey(int which, long hash) {
    return map(which).containsKey(hash);
  }
  
  public T get(int which, long hash) {
    return map(which).get(hash);
  }
  
  public T indexValue(int which, int index) {
    return map(which).indexValue(index);
  }
  
  public void dumpTo(DataOutput out) throws IOException {
    /*
     * TODO add in version number
     */
    out.writeInt(maps.length);
    maps[0].decoder().dumpTo(out);
    for (UniformMap<T> map : maps) {
      map.table().dumpTo(out);
    }
  }
  
  public void dumpTo(File outFile) throws IOException {
    FileOutputStream fout = new FileOutputStream(outFile);
    DataOutput out = new DataOutputStream(fout);
    dumpTo(out);
    fout.close();
  }

  
  @SuppressWarnings("unchecked")
  public static <T> UniformMapSet<T> loadFrom(DataInput in, Decoder.Loader<T> loader) throws IOException {
    int nMaps = in.readInt();
    UniformMap<T>[] maps = new UniformMap[nMaps];
    Decoder<T> decoder = loader.load(in);
    for (int i=0; i<nMaps; i++) {
      UniformLookupTable table = UniformLookupTable.fromDump(in);
      maps[i] = new UniformMap<T>(table, decoder);
    }
    UniformMapSet<T> mapSet = new UniformMapSet<T>(maps); 
    return mapSet;
  }

  public static class Builder<T> {
    private final UniformMap.Builder<T>[] builders;
    
    @SuppressWarnings("unchecked")
    public Builder(int nMaps, int nKeyBytes, int capEstimate) {
      builders = new UniformMap.Builder[nMaps];
      for (int i=0; i<nMaps; i++) {
        builders[i] = new UniformMap.Builder<T>(nKeyBytes, capEstimate/nMaps);
      }
    }
    
    public int size() {
      int s = 0;
      for (UniformMap.Builder<T> builder : builders) {
        s += builder.size();
      }
      return s;
    }
    
    public int size(int which) {
      return builders[which].size();
    }

    
    @SuppressWarnings("unchecked")
    public UniformMapSet<T> freeze(final Encoder<T> encoder) {
      final int nMaps = builders.length;
      UniformLookupTable[] tables = new UniformLookupTable[nMaps];
      for (int i=0; i<nMaps; i++) {
        tables[i] = builders[i].freezeTable(encoder);
      }
      Decoder<T> decoder = encoder.decoder();
      UniformMap<T>[] maps = new UniformMap[nMaps];
      for (int i=0; i<nMaps; i++) {
        maps[i] = new UniformMap<T>(tables[i], decoder);
      }
      UniformMapSet<T> mapSet = new UniformMapSet<T>(maps);
      return mapSet;
    }

    
    public void add(int which, long hash, T value) {
      builders[which].add(hash, value);
    }

  }


}
