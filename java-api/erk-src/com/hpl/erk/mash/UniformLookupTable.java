/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.mash;

import java.io.DataInput;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Random;

import com.hpl.erk.iter.ConstIterator;

public class UniformLookupTable {   
  private final int[] first4;
  private final IntSubtypeArray extension;
  private final IntSubtypeArray vals;
  private final int mask;
  private final int extMask;
  private final int shift;
  private final int nKeyBytes;
  private final int nValBytes;
  
  public static class KeyValPair {
    public final long key;
    public final int val;
    public KeyValPair(long k, int v) {
      key = k;
      val = v;
    }
  }
  
  private static final class DataInputIterator implements Iterable<KeyValPair> {
    private final DataInput in;
    private final int size;
    private final int nKeyBytes;
    private final int nValBytes;

    private DataInputIterator(DataInput in, int size, int nkb, int nvb) {
      this.in = in;
      this.size = size;
      this.nValBytes = nvb;
      this.nKeyBytes = nkb;
    }


    public Iterator<KeyValPair> iterator() {
      return new ConstIterator<KeyValPair>() {
        int remaining = size;
        
        public boolean hasNext() {
          return remaining > 0;
        }

        public KeyValPair next() {
          if (remaining<=0) {
            throw new IllegalStateException("Read past end");
          }
          remaining--;
          try {
            long k = 0;
            int shift = 0;
            for (int i=0; i<nKeyBytes; i++) {
              long b = in.readByte() & 0xFF;
              k |= (b<<shift);
              shift += 8;
            }
            k <<= 8*(8-nKeyBytes);
            int v = IntSubtypeArray.readSingleVal(in, nValBytes);
            return new KeyValPair(k, v);
          } catch (IOException e) {
            throw new IllegalStateException("Couldn't key-val pair", e);
          }
        }};
    }
  }
  
  public static class PairedArrayIterator implements Iterable<KeyValPair> {
    private final long[] keys;
    private final int[] vals;
    private final int[] indices;
    private final int len;
    private int next = 0;
    
    public PairedArrayIterator(final long[] keys, int[] vals) {
      this.keys = keys;
      this.vals = vals;
      len = keys.length;
      assert len == vals.length;
      indices = new int[len];
      for (int i=0; i<len; i++) {
        indices[i] = i;
      }
      sort(indices, keys, 0, len-1);
    }
    private static void sort(int[] indices, long[] keys, int low, int high) {
      if (low >= high) {
        return;
      }
      int p = (low+high)/2;
      int newP = partition(indices, keys, low, high, p);
      sort(indices, keys, low, newP-1);
      sort(indices, keys, newP+1, high);
    }
    private static int partition(int[] indices, long[] keys, int low, int high, int p) {
      long pivot = keys[indices[p]];
      swap(indices, p, high);
      int finalPosition = low;
      for (int i=low; i<high; i++) {
        if (keys[indices[i]] < pivot) {
          swap(indices, i, finalPosition);
          finalPosition++;
        }
      }
      swap(indices, high, finalPosition);
      return finalPosition;
    }
    private static void swap(int[] indices, int a, int b) {
      int tmp = indices[a];
      indices[a] = indices[b];
      indices[b] = tmp;
    }
    
    public Iterator<KeyValPair> iterator() {
      return new ConstIterator<KeyValPair>() {

        public boolean hasNext() {
          return next < len;
        }

        public KeyValPair next() {
          int index = indices[next++];
          return new KeyValPair(keys[index], vals[index]);
        }};
    }
    
  }
  
  
  

  public static UniformLookupTable fromDump(final DataInput in) throws IOException {
    return fromDump(-1, in);
  }
  public static UniformLookupTable fromDump(int nkb, final DataInput in) throws IOException {
    return new UniformLookupTable(in, nkb);
  }
  public static UniformLookupTable oldfromDump(int nkb, final DataInput in) throws IOException {
    final int size = in.readInt();
    int nKeyBytes = in.readInt();
    if (nkb < 0) {
      nkb = nKeyBytes;
    }
    if (nkb > nKeyBytes) {
      System.err.format("Warning: Table dumped with %d bytes, reading as %d bytes%n", nKeyBytes, nkb);
    }
    int nValBytes = in.readInt();
    final Iterable<KeyValPair> iterable = new DataInputIterator(in, size, nKeyBytes, nValBytes);
    return new UniformLookupTable(nkb, nValBytes, iterable, size);
  }
  public static UniformLookupTable fromDump(File f) throws IOException {
    return fromDump(new DataInputStream(new FileInputStream(f)));
  }
  
  public UniformLookupTable(DataInput in, int nkb) throws IOException {
    final int size = in.readInt();
    int fileNKB = in.readInt();
    if (nkb < 0) {
      nKeyBytes = fileNKB;
    } else {
      nKeyBytes = nkb;
    }
    if (nKeyBytes > fileNKB) {
      System.err.format("Warning: Table dumped with %d bytes, reading as %d bytes%n", nKeyBytes, nkb);
    }
    nValBytes = in.readInt();
//    System.err.format("Reading table of size %,d (%d / %d)%n", size, fileNKB, nValBytes);

    first4 = new int[size];
    extension = new IntSubtypeArray(nKeyBytes < 4 ? 0 : nKeyBytes-4, size);
    vals = new IntSubtypeArray(nValBytes, size);
    mask = (nKeyBytes < 4) ? (~0<<(32-nKeyBytes*8)) : ~0;
    shift = 64-nKeyBytes*8;
    extMask = (nKeyBytes < 4) ? 0 : nKeyBytes==8 ? ~0 :(1<<(nKeyBytes*8-32))-1;
    for (int i=0; i<size; i++) {
      long k = 0;
      int shift = 0;
      for (int j=0; j<fileNKB; j++) {
        long b = in.readByte() & 0xFF;
        k |= (b<<shift);
        shift += 8;
      }
      k <<= 8*(8-fileNKB);
      int v = IntSubtypeArray.readSingleVal(in, nValBytes);
      int first = (int)((k >> 32) & mask);
      first4[i] = first;
      final int ext = (int)((k>>this.shift) & extMask);
      extension.setVal(i, ext);
      vals.setVal(i, v);
    }
  }
  
  public UniformLookupTable(int nkb, int nvb, Iterable<KeyValPair> kvps, int size) {
    //System.out.println("Reading lookup table");
    //long start = System.currentTimeMillis();
    nKeyBytes = nkb;
    nValBytes = nvb;
    first4 = new int[size];
    extension = new IntSubtypeArray(nkb < 4 ? 0 : nkb-4, size);
    vals = new IntSubtypeArray(nvb, size);
    mask = (nkb < 4) ? (~0<<(32-nkb*8)) : ~0;
    shift = 64-nkb*8;
    extMask = (nkb < 4) ? 0 : nkb==8 ? ~0 :(1<<(nkb*8-32))-1;
    int pos = 0;
    for (KeyValPair kvp : kvps) {
      long k = kvp.key;
      int first = (int)((k >> 32) & mask);
      first4[pos] = first;
      final int ext = (int)((k>>shift) & extMask);
      extension.setVal(pos, ext);
      vals.setVal(pos, kvp.val);
      pos++;
    }
    //long elapsed = System.currentTimeMillis()-start;
    //System.out.format("Done: %4.3f%n", elapsed/1000.0);
    //System.out.format("%,d elements (size was %,d)%n", pos, size);
  }
  
  public void dumpTo(DataOutput out) throws IOException {
    final int size = first4.length;
    out.writeInt(size);
    out.writeInt(nKeyBytes);
    out.writeInt(nValBytes);
//    System.err.format("Writing table of size %,d (%d / %d)%n", size, nKeyBytes, nValBytes);

    for (int i=0; i<size; i++) {
      long k = first4[i];
      k <<= 32;
      long ext = extension.val(i) & 0xFFFFFFFFL;
      ext <<= shift;
      k |= ext;
      k >>= 8*(8-nKeyBytes);
      for (int b=0; b<nKeyBytes;b++) {
        out.writeByte((int)(k & 0xFF));
        k >>= 8;
      }
      vals.writeValTo(out, i);
    }
  }
  
  public boolean contains(long n) {
    return lookup(n) >= 0;
  }
  
  public int valAt(int pos) {
    return vals.val(pos);
  }
  
  public int valOf(long n) {
    int index = lookup(n);
    if (index >= 0) {
      return vals.val(index);
    } else {
      return -1;
    }
  }
  
  public int lookup(long n) {
    final int[] first = first4;
    final int length = first.length;
    if (length == 0) {
      return -1;
    }
    long topTarget = ((n >> 32) & mask);
    int from = 0;
    int to = length-1;
    long min = first[from];
    long max = first[to];
    if (topTarget < min || topTarget>max) {
      return -1; 
    }
    while (from<=to) {
      double target = topTarget -(double) min;// conversion to double must precede subtraction, else could wrap negative
      double span = max -(double) min;
      int len = to-from;
      int probe = span==0 ? (to+from)/2 : (int)((target/span)*len)+from;
      long mid = first[probe];
      if (topTarget == mid) {
        if (extension != null) {
          int extTarget = (int)((n>>shift) & extMask); 
          if (extension.val(probe) == extTarget) {
            return probe;
          }
          for (int i=probe+1; i<length && first[i]==mid; i++) {
            if (extension.val(i) == extTarget) {
              return i;
            }
          }
          for (int i=probe-1; i>=0 && first[i]==mid; i--) {
            if (extension.val(i) == extTarget) {
              return i;
            }
          }
          return -1;
        } else {
          return probe;
        }
      } else if (topTarget < mid) {
        to = probe-1;
        max = mid;
      } else {
        from = probe+1;
        min = mid;
      }
    }
    return -1;
  }


  @SuppressWarnings("unused")
  private static long[] iterableToArray(Iterable<Long> f, int size) {
    long[] array = new long[size];
    int next = 0;
    for (long n : f) {
      array[next++] = n;
    }
    return array;
  }
  
  public static void main(String[] args) {
    int nHashes = 1656625;
//    int nHashes = 1<<26;
    int bits = 40;
    long range = 1L<<bits;
    long mask = range-1;
    long[] hashes = new long[nHashes];
    Random rnd = new Random();
    for (int i=0; i<nHashes; i++) {
      hashes[i] = rnd.nextLong() & mask;
    }
    Arrays.sort(hashes);
    int totalProbes = 0;
    for (int i=0; i<nHashes; i++) {
      int probes = probesNeeded(hashes[i], hashes, 0, nHashes-1, 1);
      totalProbes += probes;
    }
    double avg = totalProbes/(double)nHashes;
    System.out.format("%,d hashes of %d bits resulted in an average of %5.3f probes per hash%n", 
        nHashes, bits, avg);
    int nNegative = 1000000;
    int totNegProbes = 0;
    for (int i=0; i<nNegative; i++) {
      long neg = rnd.nextLong() & mask;
      int probes = probesNeeded(neg, hashes, 0, nHashes-1, 1);
      totNegProbes += probes;
    }
    avg = totNegProbes/(double)nNegative;
    System.out.format("%,d negatives resulted in an average of %5.3f probes per hash%n", 
        nNegative, avg);
  }
  private static int probesNeeded(long n, long[] hashes, int from, int to, int minSpan) {
    return proportionalProbesNeeded(n, hashes, from, to, minSpan);
  }
  private static int proportionalProbesNeeded(long n, long[] hashes, int from, int to, int minSpan) {
    long min = hashes[from];
    long max = hashes[to];
    if (n < min || n>max) {
      return 0; 
    }
    int nProbes = 0;
    while (from<to) {
      nProbes++;
      long target = n-min;
      double span = max-min;
      int len = to-from;
      int probe = (int)((target/span)*len)+from;
      long mid = hashes[probe];
      if (n == mid) {
        return nProbes;
      } else if (n < mid) {
        to = probe-1;
        max = mid;
      } else {
        from = probe+1;
        min = mid;
      }
    }
    return nProbes;
  }
  @SuppressWarnings("unused")
  private static int binaryProbesNeeded(long n, long[] hashes, int from, int to, int minSpan) {
    int nProbes = 0;
    while (from<to) {
      nProbes++;
      int probe = (to+from)/2;
      long mid = hashes[probe];
      if (n == mid) {
        return nProbes;
      } else if (n < mid) {
        to = probe-1;
      } else {
        from = probe+1;
      }
    }
    return nProbes;
  }
  @SuppressWarnings("unused")
  private static int scanProbesNeeded(long n, long[] hashes, int from, int to, int minSpan) {
    long min = hashes[from];
    long max = hashes[to];
    if (n<min || n>max) {
      return 0;
    }
    int nProbes = 1;
    long target = n-min;
    double span = max-min;
    int len = to-from;
    int probe = (int)((target/span)*len)+from;
    long mid = hashes[probe];
    if (n < mid) {
      while (n < mid & probe > from) {
        nProbes++;
        mid = hashes[--probe];
      }
    } else {
      while (n > mid && probe <to) {
        nProbes++;
        mid = hashes[++probe];
      }
    }
    return nProbes;
  }
  
  public int size() {
	return first4.length;
  }
}
