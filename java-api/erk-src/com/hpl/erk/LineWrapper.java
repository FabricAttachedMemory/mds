/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.hpl.erk.formatters.SeqFormatter;
import com.hpl.erk.util.Strings;

public class LineWrapper {
  private int lineWidth;
  private String prefix;
  private String firstPrefix;
  private String suffix;
  private String lastSuffix;
  private boolean alignSuffixes = false;
  private int indent = 0;
  
  public class Line {
    final String text;
    final int width;
    boolean first;
    boolean last = true;
    protected Line(String text, int width, boolean first) {
      this.text = text;
      this.width = width;
      this.first = first;
    }
    
    @Override
    public String toString() {
      final String p = Strings.notNull(first ? firstPrefix : prefix);
      final String s = Strings.notNull(last ? lastSuffix : suffix);
      String pad = "";
      final int padLength = width-text.length();
      if (alignSuffixes && padLength > 0) {
        pad = Strings.spaces(padLength); 
      }
      String indent = "";
      if (!first && LineWrapper.this.indent > 0) {
        indent = Strings.spaces(LineWrapper.this.indent);
      }
      return indent+p+text+pad+s;
    }

  }
  
  public class Lines extends LinkedList<Line> {
    private static final long serialVersionUID = 7807083610952125533L;
    void add(String text, int width) {
      final boolean firstLine = isEmpty();
      if (!firstLine) {
        getLast().last = false;
      }
      add(new Line(text, width, firstLine));
    }
    @Override
    public String toString() {
      return SeqFormatter.lines().format(this);
    }
  }
  
  public LineWrapper(int lineWidth) {
    this.lineWidth = lineWidth;
  }
  
  public LineWrapper(int lineWidth, String prefix) {
    this(lineWidth);
    this.prefix = prefix;
  }
  
  public LineWrapper width(int w) {
    lineWidth = w;
    return this;
  }
  
  public LineWrapper indent(int n) {
    indent = n;
    return this;
  }
  
  public LineWrapper wrapPrefix(String p) {
    prefix = p;
    return this;
  }
  
  public LineWrapper firstPrefix(String p) {
    firstPrefix = p;
    return this;
  }
  
  public LineWrapper prefixes(String each, String first) {
    return firstPrefix(first).wrapPrefix(each);
  }
  
  public LineWrapper prefix(String p) {
    return prefixes(p, p);
  }
  
  public LineWrapper notLastSuffix(String s, boolean align) {
    return notLastSuffix(s).alignSuffixes(align);
  }
  
  public LineWrapper notLastSuffix(String s) {
    suffix = s;
    return this;
  }
  
  public LineWrapper lastSuffix(String s) {
    lastSuffix = s;
    return this;
  }
  
  public LineWrapper alignSuffixes(boolean align) {
    alignSuffixes = align;
    return this;
  }
  
  public LineWrapper alignSuffixes() {
    return alignSuffixes(true);
  }
  
  public LineWrapper suffixes(String each, String last, boolean align) {
    return suffixes(each, last).alignSuffixes(align);
  }
  public LineWrapper suffixes(String each, String last) {
    return notLastSuffix(each).lastSuffix(last);
  }
  public LineWrapper suffix(String s, boolean align) {
    return suffixes(s, s, align);
  }
  public LineWrapper suffix(String s) {
    return suffixes(s, s);
  }
  
  
  private Lines wrapParagraphs(List<String> paragraphs, int flPos) {
    Lines lines = new Lines();
    int firstLineWidth = lineWidth-Strings.notNull(firstPrefix).length()-Strings.notNull(suffix).length()-flPos;
    int normalWidth = lineWidth-Strings.notNull(prefix).length()-indent-Strings.notNull(suffix).length();
    for (String para : paragraphs) {
      if (!lines.isEmpty()) {
        lines.add("", normalWidth);
        firstLineWidth = normalWidth;
      }
      wrapParagraph(para, lines, firstLineWidth, normalWidth);
    }
    return lines;
    
  }
  
  
  private static void wrapParagraph(String s, Lines lines, int firstLineWidth, int normalWidth) 
  {
    int thisLineWidth = firstLineWidth;
    while (s.length() > thisLineWidth) {
      if (spaceAt(s, thisLineWidth)) {
        // we're at a natural break
        int i = thisLineWidth-1;
        while (i >= 0 && spaceAt(s, i)) {
          i--;
        }
        lines.add(s.substring(0, i+1), thisLineWidth);
        i = thisLineWidth;
        while (i<s.length() && spaceAt(s, i)) {
          i++;
        }
        s = s.substring(i);
      } else {
        int i = thisLineWidth-1;
        while (i >= 0 && !spaceAt(s, i)) {
          i--;
        }
        if (i == 0) {
          // there were no spaces
          lines.add(s.substring(0, thisLineWidth), thisLineWidth);
          s = s.substring(thisLineWidth);
        } else {
          String next = s.substring(i+1);
          while (i >= 0 && spaceAt(s, i)) {
            i--;
          }
          lines.add(s.substring(0, i+1), thisLineWidth);
          s = next;
        }
      }
      thisLineWidth = normalWidth;
    }
    lines.add(s, thisLineWidth);
  }

  public Lines wrap(String s) {
    return wrap(s, 0);
  }
  
  private static final Pattern paragraph = Pattern.compile("((?:.|\\n)*?)\\s*(?:$|(?:\\n\\s*)+\\n|\\n(?=\\s+\\S))");
//  private static final Pattern paragraph = Pattern.compile("((?:.|\\n)*)\\s*");
  private static final Pattern lineBreaks = Pattern.compile("\\s*\\n");
  public Lines wrap(String s, int pos) {
    List<String> paragraphs = new ArrayList<>();
    Matcher m = paragraph.matcher(s);
    while (m.find()) {
      String p = m.group(1);
      p = lineBreaks.matcher(p).replaceAll(" ");
      if (!p.isEmpty()) {
        paragraphs.add(p);
      }
    }
    return wrapParagraphs(paragraphs, pos);
  }
  
  public static String wrapLines(String s, int width, String introducer) {
    LineWrapper w = new LineWrapper(width).prefixes(Strings.spaces(introducer.length()), introducer);
    return w.wrap(s).toString();
  }
  
  public static String wrapLines(String s, int width) {
    return wrapLines(s, width, "");
  }

  private static boolean spaceAt(String s, final int p) {
    return Character.isSpaceChar(s.charAt(p));
  }


  public static void main(String[] args) {
    String a = "Hi there.  This is long text with\n" +
    		"newlines in it and some very long lines that will have to be wrapped" +
    		"\n  \n\n" +
    		"It also has a paragraph break";
    LineWrapper w = new LineWrapper(20).prefix("[").suffix("]").alignSuffixes();
    System.out.format("%s%n%n", w.wrap(a));
    String p = "Text = ";
    LineWrapper w2 = new LineWrapper(30).indent(p.length());
    System.out.format("%s%s%n%n", p, w2.wrap(a, p.length()));
    LineWrapper w3 = new LineWrapper(30).prefixes(" * ", "/* ").suffixes(" *", " */").alignSuffixes();
    System.out.format("%s%n%n", w3.wrap(a));
    System.out.format("%s%n%n", LineWrapper.wrapLines(a, 30, "Test = "));
    System.out.format("%s%n%n", LineWrapper.wrapLines(a, 30));
  }
}
