/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.RandomAccess;

public class RandomSample<T> implements Iterable<T>
{

	final int maxSize;
	final ArrayList<T> contents;
	static final Random rnd = new Random();
	int sourceSize = 0;
	
	public RandomSample(int max) {
		maxSize = max;
		// should we worry about figuring out a good size for the list?
		contents = new ArrayList<T>(); 
	}
	
	private static class SelectionTree<T> {

		public int sourceSize;
		private final List<RandomSample<T>> samples;
		private final int[] cuts;

		public SelectionTree(List<RandomSample<T>> colls) {
			samples = colls;
			cuts = new int[samples.size()];
			for (int i=0; i<samples.size(); i++) {
				sourceSize += samples.get(i).sourceSize;
				cuts[i] = sourceSize;
			}
		}

		public RandomSample<T> pick() {
			int rnd = random(sourceSize);
			int which = Arrays.binarySearch(cuts, rnd);
			if (which < 0) {
				which = -(which+1);
			}
			return samples.get(which);
		}
	}

	private RandomSample(RandomSample<T> other) {
		contents = new ArrayList<T>(other.contents);
		maxSize = other.maxSize;
		sourceSize = other.sourceSize;
	}
	
	public static <T> RandomSample<T> combineOld(List<RandomSample<T>> colls) {
		if (colls.isEmpty()) {
			throw new IllegalArgumentException("Can't get sample size from empty list");
		}
		if (colls.size() == 1) {
			return new RandomSample<T>(colls.get(1));
		}
		if (colls.size() == 2) {
			RandomSample<T> s = new RandomSample<T>(colls.get(1));
			s.addSample(colls.get(2));
			return s;
		}
		SelectionTree<T> t = new SelectionTree<T>(colls);
		int maxSize = colls.get(1).maxSize;
		RandomSample<T> s = new RandomSample<T>(maxSize);
		s.sourceSize = t.sourceSize;
		s.contents.ensureCapacity(maxSize);
		for (int i=0; i<maxSize; i++) {
			s.contents.set(i, t.pick().contents.get(i));
		}
		return s;
	}
	
	public static <T> RandomSample<T> combine(Collection<RandomSample<T>> samples) {
		if (samples.isEmpty()) {
			throw new IllegalArgumentException("Can't get sample size from empty list");
		}
		RandomSample<T> small = null;
		List<RandomSample<T>> fullSamples = new ArrayList<RandomSample<T>>(samples.size());
		int maxSize = 0;
		for (RandomSample<T> sample : samples) {
			maxSize = sample.maxSize;
			if (sample.isFull()) {
				fullSamples.add(sample);
			} else {
				if (small == null) {
					small = new RandomSample<T>(sample);
				} else {
					small.addSample(sample);
				}
			}
		}
		if (fullSamples.isEmpty()) {
			return small != null ? small : new RandomSample<T>(maxSize);
		}
		if (fullSamples.size() == 1) {
			RandomSample<T> only = fullSamples.get(0);
			if (small == null) {
				return new RandomSample<T>(only);
			}
			small.addSample(only);
			return small;
		}
		if (small != null && small.isFull()) {
			fullSamples.add(small);
		}
		RandomSample<T> s = combineFull(fullSamples, maxSize);
		if (small != null && !small.isFull()) {
			s.addSample(small);
		}
		return s;
	}

	private static <T> RandomSample<T> combineFull(List<RandomSample<T>> fullSamples, int maxSize) {
		SelectionTree<T> t = new SelectionTree<T>(fullSamples);
		RandomSample<T> s = new RandomSample<T>(maxSize);
		s.sourceSize = t.sourceSize;
		s.contents.ensureCapacity(maxSize);
		for (int i=0; i<maxSize; i++) {
			s.contents.add(t.pick().contents.get(i));
		}
		return s;
	}
	
	public int capacity() {
		return maxSize;
	}
	public int size() {
		return contents.size();
	}
	public void add(T elt) {
//		if ("callback=portal".equals(elt)) {
//			System.out.println("Here we are");
//		}

		sourceSize++;
		if (contents.size() < maxSize) {
			contents.add(elt);
			return;
		}
		int which = random(sourceSize);
		if (which < maxSize) {
			contents.set(which, elt);
		}
	}
	
	public void add(DelayedValue<T> dv) {
		sourceSize++;
		if (contents.size() < maxSize) {
			T val = dv.value();
			contents.add(val);
			return;
		}
		int which = random(sourceSize);
		if (which < maxSize) {
			T val = dv.value();
			contents.set(which, val);
		}
	}
	
	public boolean isFull() {
		return contents.size() == maxSize;
	}
	
	public void addSample(RandomSample<T> other) {
		if (maxSize != other.maxSize) {
			throw new IllegalArgumentException("Cannot combine samples of different sizes");
		}
		if (size() == 0) {
			contents.addAll(other.contents);
			sourceSize = other.sourceSize;
			return;
		} 
		if (!other.isFull()) {
			for (T e : other) {
				add(e);
			}
			return;
		}
		if (isFull()) {
			double p = ((double)other.sourceSize)/(sourceSize+other.sourceSize);
			for (int i=0; i<maxSize; i++) {
				if (withProb(p)) {
					contents.set(i, other.contents.get(i));
				}
			}
			sourceSize += other.sourceSize;
		} else {
			ArrayList<T> oldContents = new ArrayList<T>(contents);
			contents.clear();
			contents.addAll(other.contents);
			sourceSize = other.size();
			addAll(oldContents);
		}
	}
	
	public void addAll(Collection<? extends T> elts) {
		for (T e : elts) {
			add(e);
		}
	}
	
	@Override
	public Iterator<T> iterator() {
		return contents.iterator();
	}
	
	private static int random(int max) {
		synchronized (rnd) {
			return rnd.nextInt(max);
		}
	}
	
	private static boolean withProb(double p) {
		synchronized (rnd) {
			return rnd.nextDouble() < p;
		}
	}
	
	public T pick() {
	  int which = random(size());
	  return contents.get(which);
	}
	
	public boolean pick(int k, T[] array) {
	  return pick(k, contents, array);
	}
	
	private static final double cutoff = (Math.E-1)/Math.E;
	public static <U, T extends U> boolean pick(int k, List<T> coll, U[] array) {
	  int n = coll.size();
	  if (k > n) {
	    return false;
	  }
	  /*
	   * Okay.  This probably warrants a comment.  If you do the math, picking and checking winds up costing
	   * n(H(n)-H(n-k)).  By Knuth (v1p74eq3), H(n) is approx. ln n, so this is basically n ln(n/(n-k)).  Which 
	   * means that it will be faster than the single-pass algorithm (O(n)) when k < ((e-1)/e) n.
	   */
	  if ((coll instanceof RandomAccess) && (k < cutoff*n)) {
	    pickAndCheck(k,n,coll,array);
	  } else {
	    walkAndPick(k,n,coll, array);
	  }
	  return true;
	}
	
    public static <U, T extends U> boolean pick(int k, List<T> coll, Collection<U> sample) {
      int n = coll.size();
      if (k > n) {
        return false;
      }
      /*
       * Okay.  This probably warrants a comment.  If you do the math, picking and checking winds up costing
       * n(H(n)-H(n-k)).  By Knuth (v1p74eq3), H(n) is approx. ln n, so this is basically n ln(n/(n-k)).  Which 
       * means that it will be faster than the single-pass algorithm (O(n)) when k < ((e-1)/e) n.
       */
      if ((coll instanceof RandomAccess) && (k < cutoff*n)) {
        pickAndCheck(k,n,coll,sample);
      } else {
        walkAndPick(k,n,coll, sample);
      }
      return true;
    }
    
	public static <U, T extends U> boolean pick(int k, Collection<T> coll, U[] array) {
	  if (coll instanceof List) {
	    List<T> list = (List<T>)coll;
	    return pick(k, list, array);
	  }
      int n = coll.size();
      if (k > n) {
        return false;
      }
      walkAndPick(k, coll.size(), coll, array);
      return true;
	}
	
    public static <U, T extends U> boolean pick(int k, Collection<T> coll, Collection<U> sample) {
      if (coll instanceof List) {
        List<T> list = (List<T>)coll;
        return pick(k, list, sample);
      }
      int n = coll.size();
      if (k > n) {
        return false;
      }
      walkAndPick(k, coll.size(), coll, sample);
      return true;
    }
    

	private static <U, T extends U> void pickAndCheck(int k, int n, List<T> list, U[] array) {
	  int[] chosen = new int[k];
	  OUTER:
	    for (int i=0; i<k; ) {
	      int which = random(n);
	      
	      for (int j=0; j<i; j++) {
	        if (which == chosen[j]) {
	          continue OUTER;
	        }
	      }
	      chosen[i++] = which;
	    }
	  for (int i=0; i<k; i++) {
	    array[i] = list.get(chosen[i]);
	  }
	}
	
    private static <U, T extends U> void pickAndCheck(int k, int n, List<T> list, Collection<U> sample) {
      int[] chosen = new int[k];
      OUTER:
        for (int i=0; i<k; ) {
          int which = random(n);
          
          for (int j=0; j<i; j++) {
            if (which == chosen[j]) {
              continue OUTER;
            }
          }
          chosen[i++] = which;
        }
      for (int i=0; i<k; i++) {
        sample.add(list.get(chosen[i]));
      }
    }
    
    private static <U, T extends U> void walkAndPick(int k, int n, Collection<T> list, U[] array) {
      int i = 0;
      for (T elt : list) {
        if (random(n) < k) {
          array[i++] = elt;
          k--;
          if (k==0) {
            return;
          }
        }
        n--;
      }
    }
    private static <U, T extends U> void walkAndPick(int k, int n, Collection<T> coll, Collection<U> sample) {
      for (T elt : coll) {
        if (random(n) < k) {
          sample.add(elt);
          k--;
          if (k==0) {
            return;
          }
        }
        n--;
      }
    }
}
