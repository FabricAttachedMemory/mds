/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/**
 * 
 */
package com.hpl.erk.adt;

import java.util.Iterator;
import java.util.Map;
import java.util.Random;

import com.hpl.erk.mash.MASHR_Algorithm64;

/**
 * An efficient map (but not {@link Map}) whose keys are reasonably uniform 64-bit integers (such as those generated by
 * {@link MASHR_Algorithm64} or {@link Random} and whose values are of an arbitrary type {@code T}.
 * It's slightly more space efficient (two bytes less per element on average) than LongKeyMap, but things can go badly wrong if any of your keys are zero or one.
 */
public final class UniformHashMap<T> extends AbstractUniformHashMap {
  private T[] vals;

  /**
   * An entry in a {@link UniformHashMap}{@code<T>}, retrievable via its {@link entries}() method. 
   */
  public static class Entry<T> {
    private final long key;
    private final T val;
    private Entry(long key, T val) {
      this.key = key;
      this.val = val;
    }
    /**
     * @return the value associated with the current entry.
     */
    public T getVal() {
      return val;
    }
    /**
     * @return the key associated with the current entry.
     */
    public long getKey() {
      return key;
    }
  }
  
  
  private class EntryIterator extends Iter<Entry<T>> {
    @Override
    protected Entry<T> element(long key, int index) {
      return new Entry<T>(key, vals[index]);
    }
  }
  
  private class ValueIterator extends Iter<T> {
    @Override
    protected T element(long key, int index) {
      return vals[index];
    }
  }

  /**
   * A {@link UniformHashMap} with a capacity sufficient for the estimate.
   * 
   * @param expected a capacity estimate
   */
  public UniformHashMap(int expected) {
    super(expected);
    vals = createValueArray(capacity);
  }
  
  /**
   * A {@link UniformHashMap} with a default capacity of 16 elements.
   */
  public UniformHashMap() {
    this(DEFAULT_INITIAL_CAPACITY);
  }
  
  @SuppressWarnings({ "unchecked", "static-method" })
  private T[] createValueArray(int size) {
    return (T[]) new Object[size];
  }
  
  /**
   * 
   * @param hash the key
   * @return the value associated with the key, or {@code null} if no such value exists.
   */
  public T get(long hash) {
    int index = findIndex(hash);
    if (index >= 0) {
      return vals[index];
    }
    return null;
  }
  
  private class CB implements PutCallBack {
    final T newVal;
    T oldVal = null;
    CB(T val) {
      newVal = val;
    }
    @Override
    public boolean replace(int oldIndex, int newIndex) {
      if (oldIndex >= 0) {
        oldVal = vals[oldIndex];
      }
      vals[newIndex] = newVal;
      return newVal != oldVal;
    }
    
  }
  
  /**
   * Associate a new value with a key.
   * @param k the key
   * @param val the new value
   * @return the old value associated with the key or {@code null} if no such value existed.
   */
  public T put(long k, T val) {
    CB cb = new CB(val);
    put(k, cb);
    return cb.oldVal;
  }
  
  private class RCB implements RemoveCallBack {
    T oldVal = null;

    @Override
    public void removedFrom(int index) {
      oldVal = vals[index];
    }
  }
  
  /**
   * Remove the value, if any, associated with a key.
   * @param k the key
   * @return the old value associated with the key, or {@code null} if no such value existed.
   */
  public T remove(long k) {
    RCB cb = new RCB();
    remove(k, cb);
    return cb.oldVal;
  }
  
  /**
   * 
   * @return an object to use for iterating over the {@link Entry} objects corresponding to the associations
   * in the map.  No guarantee is made as to the order entries are returned.
   *  Associations may be deleted by using the {@link Iterator}'s {@code remove}() method.
   */
  public Iterable<Entry<T>> entries() {
    return new Iterable<Entry<T>>() {
      @Override
      public Iterator<Entry<T>> iterator() {
        return new EntryIterator();
      }};
  }

  /**
   * 
   * @return an object to use for iterating over the values of the associations in the map.  If a value occurs more
   * than once in the map, it will occur more than once in the iteration.  No guarantee is made as to the 
   * order values are returned. 
   *  Associations may be deleted by using the {@link Iterator}'s {@code remove}() method.
   */
  public Iterable<T> values() {
    return new Iterable<T>() {
      @Override
      public Iterator<T> iterator() {
        return new ValueIterator();
      }};
  }
  
  public static interface Filter<T> {
	  boolean keep(long hash, T val);
  }

  @Override
  protected void removeAtIndex(int index) {
    vals[index] = null;
  }

  @Override
  protected void resizeValues(int size) {
    vals = createValueArray(size);
    
  }

  @Override
  protected Resizer resizer() {
    return new Resizer() {
      T[] oldVals = vals;
      @Override
      public void copyFrom(long key, int index) {
        T val = oldVals[index];
        put(key, val);
      }
    };
  }
  
}
