/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.adt;

import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.Arrays;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import com.hpl.erk.util.ObjUtils;

public class SmallIntMap<V> extends AbstractMap<Integer, V> {
  public static final int DEFAULT_INITIAL_SIZE = 10;
  public static final int DEFAULT_MAX_COMPACT_SIZE = 256;
  private static final Object NULL_VAL = new Object();
  
  private int initialSize;
  private int maxCompactSize;
  private Object[] vals;
  private IntKeyMap<V> fullMap = null;
  private int size = 0;
  transient private int modCount = 0;
  
  public static abstract class Auto<V> extends SmallIntMap<V> {
    protected abstract V newVal(int key);

    protected Auto() {
    }

    protected Auto(int initialSize, int maxCompactSize) {
      super(initialSize, maxCompactSize);
    }

    protected Auto(int initialSize) {
      super(initialSize);
    }
    
    @Override
    public V get(int key) {
      if (containsKey(key)) {
        return super.get(key);
      }
      V val = newVal(key);
      put(key, val);
      return val;
    }
  }
  
  public static abstract class SynchroAuto<V> extends Auto<V> {

    protected SynchroAuto() {
    }

    protected SynchroAuto(int initialSize, int maxCompactSize) {
      super(initialSize, maxCompactSize);
    }

    protected SynchroAuto(int initialSize) {
      super(initialSize);
    }
    
    @Override
    synchronized public V get(int key) {
      return super.get(key);
    }
    
    @Override
    synchronized public V put(int key, V value) {
      return super.put(key, value);
    };
    
    @Override
    synchronized public boolean containsKey(int key) {
      return super.containsKey(key);
    }
    
    @Override
    synchronized public boolean containsValue(Object value) {
      return super.containsValue(value);
    }
    
    @Override
    synchronized public void clear() {
      super.clear();
    }
    
    @Override
    synchronized public int size() {
      return super.size();
    }
    
  }
  
  
  
  public SmallIntMap(int initialSize, int maxCompactSize) {
    if (initialSize < 1) {
      throw new IllegalArgumentException(String.format("Initial size was %,d, must be at least 1", initialSize));
    }
    this.initialSize = initialSize;
    vals = new Object[initialSize];
    this.maxCompactSize = maxCompactSize;
  }
  
  public SmallIntMap(int initialSize) {
    this(initialSize, DEFAULT_MAX_COMPACT_SIZE);
  }
  
  public SmallIntMap() {
    this(DEFAULT_INITIAL_SIZE, DEFAULT_MAX_COMPACT_SIZE);
  }


  private class E implements Entry<Integer, V> {
    final int key;
    
    protected E(int key) {
      this.key = key;
    }

    @Override
    public Integer getKey() {
      return key;
    }

    @Override
    public V getValue() {
      return getLocal(key);
    }

    @Override
    public V setValue(V value) {
      return putLocal(key, value);
    }
    
  }
  
  private class ESet extends AbstractSet<Entry<Integer, V>> {

    @Override
    public Iterator<java.util.Map.Entry<Integer, V>> iterator() {
      return new Iterator<Map.Entry<Integer,V>>() {
        final int expectedModCount = modCount;
        final int len = vals == null ? 0 : vals.length;
        
        int lastKey = -1;
        int nextKey = nextEntryKey();
        
        private int nextEntryKey() {
          for (int i=lastKey+1; i<len; i++) {
            if (vals[i] != null) {
              return i;
            }
          }
          return len;
        }
        
        @Override
        public boolean hasNext() {
          if (expectedModCount != modCount) {
            throw new ConcurrentModificationException();
          }
          return nextKey < len;
        }


        @Override
        public Entry<Integer, V> next() {
          if (nextKey >= len) {
            throw new IllegalStateException();
          }
          lastKey = nextKey;
          nextKey = nextEntryKey();
          return new E(lastKey);
        }

        @Override
        public void remove() {
          if (lastKey < 0) {
            throw new IllegalStateException();
          }
          if (expectedModCount != modCount) {
            throw new ConcurrentModificationException();
          }
          vals[lastKey] = null;
          size--;
        }
      };
    }
    
    @Override
    public boolean remove(Object o) {
      if (o == null || !(o instanceof SmallIntMap.E)) {
        return false;
      }
      @SuppressWarnings("unchecked")
      E entry = (E)o;
      int key = entry.key;
      if (key < 0 || key > vals.length) {
        return false;
      }
      return vals[key] != null;
    }

    @Override
    public int size() {
      return size;
    }
    
    @Override
    public void clear() {
      SmallIntMap.this.clear();
    }
    
  }
  
  @Override
  public Set<Entry<Integer, V>> entrySet() {
    if (fullMap != null) {
      return fullMap.entrySet();
    }
    return new ESet();
  }



  @Override
  public int size() {
    return fullMap == null ? size : fullMap.size();
  }



  @Override
  public boolean containsValue(Object value) {
    if (fullMap != null) {
      return fullMap.containsValue(value);
    }
    return super.containsValue(value);
  }


  public boolean containsKey(int key) {
    if (fullMap != null) {
      return fullMap.containsKey(key);
    }
    if (key < 0 || key >= vals.length) {
      return false;
    }
    return vals[key] != null;
  }

  @Override
  public boolean containsKey(Object key) {
    if (fullMap != null) {
      return fullMap.containsKey(key);
    }
    if (key == null) {
      throw new IllegalArgumentException("Null key");
    }

    if (!(key instanceof Integer)) {
      throw new IllegalArgumentException(String.format("Not an integer: %s", key));
    }
    return containsKey((int)key);
  }



  public V get(int key) {
    if (fullMap != null) {
      return fullMap.get(key);
    }
    if (key < 0 || key >= vals.length) {
      return null;
    }
    return getLocal(key);
  }

  private V getLocal(int key) {
    Object v = vals[key];
    if (v == NULL_VAL) {
      return null;
    }
    @SuppressWarnings("unchecked")
    V downcast = (V)v;
    return downcast;
  }
  
  @Override
  public V get(Object key) {
    if (key == null) {
      throw new IllegalArgumentException("Null key");
    }

    if (!(key instanceof Integer)) {
      throw new IllegalArgumentException(String.format("Not an integer: %s", key));
    }
    return get((int)key);
  }


  public V put(int key, V value) {
    modCount++;
    if (fullMap != null) {
      return fullMap.put(key, value);
    }
    if (key < 0 || key >= maxCompactSize) {
      convertToFull();
      return fullMap.put(key, value);
    }
    if (vals == null || key >= vals.length) {
      int len = vals == null ? initialSize : vals.length;

      while (key >= len) {
        len += (len+1) >> 1;
        if (len >= maxCompactSize) {
          len = maxCompactSize;
        }
      }
      Object[] newArray = Arrays.copyOf(vals, len);
      vals = newArray;
    }
    return putLocal(key, value);
  }

  private V putLocal(int key, V value) {
    Object old = vals[key];
    Object v = value == null ? NULL_VAL : value;
    vals[key] = v;
    if (old == null) {
      size++;
    }
    if (old == NULL_VAL) {
      return null;
    }
    @SuppressWarnings("unchecked")
    V downcast = (V)old;
    return downcast;
  }

  @Override
  public V put(Integer key, V value) {
    if (key == null) {
      throw new IllegalArgumentException("Null key");
    }
    return put((int)key, value);
  }

  private void convertToFull() {
    fullMap = new IntKeyMap<>(size);
    int n = vals.length;
    for (int i=0; i<n; i++) {
      Object val = vals[i];
      if (val != null) {
        @SuppressWarnings("unchecked")
        V dcv = val == NULL_VAL ? null : (V)val;
        fullMap.put(i, dcv);
      }
    }
    vals = null;
    size = 0;
  }
  
  public V remove(int key) {
    modCount++;
    if (fullMap != null) {
      return fullMap.remove(key);
    }
    if (key < 0 || key >= vals.length) {
      return null;
    }
    Object v = vals[key];
    if (v == null) {
      return null;
    }
    size--;
    vals[key] = null;
    if (v == NULL_VAL) {
      return null;
    }
    @SuppressWarnings("unchecked")
    V downcast = (V)v;
    return downcast;
  }

  @Override
  public V remove(Object key) {
    if (key == null) {
      throw new IllegalArgumentException("Null key");
    }

    if (!(key instanceof Integer)) {
      throw new IllegalArgumentException(String.format("Not an integer: %s", key));
    }
    return remove((int)key);
  }




  @Override
  public void clear() {
    fullMap = null;
    vals = null;
    size = 0;
  }



  @Override
  protected SmallIntMap<V> clone() throws CloneNotSupportedException {
    SmallIntMap<V> result = ObjUtils.castClone(this, super.clone());
    result.fullMap = fullMap == null ? null : (IntKeyMap<V>)fullMap.clone();
    result.vals = vals == null ? null : Arrays.copyOf(vals, vals.length);
    result.initialSize = initialSize;
    result.maxCompactSize = maxCompactSize;
    result.size = size;
    return result;
  }

}
