/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.adt;

import java.util.NoSuchElementException;
import java.util.concurrent.ThreadLocalRandom;

public class IndexDeck extends Deck<Integer> {
  final int[] indices;
  int initializedTo = 0;

  public IndexDeck(int max) {
    super(max);
    indices = new int[max];
    for (int i=0; i<max; i++) {
      indices[i] = i;
    }
  }

  @Override
  protected Integer get(int i) {
    return indices[i];
  }
  
  @Override
  protected Integer swap(int i, int j) {
    return swapInt(i, j);
  }

  protected int swapInt(int i, int j) {
    int tmp = indices[j];
    indices[j] = indices[i];
    indices[i] = tmp;
    return tmp;
  }

  public int dealInt(OnEmpty action) {
    if (dealtTo < shuffledTo) {
      return get(dealtTo++);
    }
    if (shuffledTo >= size) {
      switch (action) {
      case SHUFFLE:
        shuffle();
        return dealInt(OnEmpty.THROW);
      case RETURN_NULL:
        return -1;
      case THROW:
        throw new NoSuchElementException();
      }
    }
    int which = ThreadLocalRandom.current().nextInt(shuffledTo, size);
    int val = swapInt(shuffledTo, which);
    shuffledTo++;
    dealtTo++;
    return val;
  }
  
  public int dealInto(int[] array, int from, int to, OnEmpty action) {
    ThreadLocalRandom rnd = null;
    if (size == 0) {
      return 0;
    }
    for (int i=from; i<to; i++) {
      if (dealtTo < shuffledTo) {
        array[i] = get(dealtTo++);
      } else {
        if (shuffledTo >= size) {
          switch (action) {
          case SHUFFLE:
            shuffle();
            break;
          case RETURN_NULL:
            return i-from;
          case THROW:
            throw new NoSuchElementException();
          }
        }
        if (rnd == null) {
          rnd = ThreadLocalRandom.current();
        }
        int which = rnd.nextInt(shuffledTo, size);
        int val = swapInt(shuffledTo, which);
        shuffledTo++;
        dealtTo++;
        array[i] = val;
      }
    }
    return to-from;
  }
  
  public int dealInto(int[] array, OnEmpty action) {
    return dealInto(array, 0, array.length, action);
  }

}
