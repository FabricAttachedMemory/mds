/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.adt;

import java.util.AbstractCollection;
import java.util.AbstractSet;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import com.hpl.erk.func.Predicate;
import com.hpl.erk.impl_helper.EqualsImpl;


public class SmallMap<K, V> implements Map<K, V> {
  private static abstract class EBase {
    protected final int index;
    
    protected abstract SmallMap<?,?> map();

    protected EBase(int index) {
      this.index = index;
    }
    @Override
    public boolean equals(Object obj) {
      return EqualsImpl.check(this, obj, EBase.class, new Predicate<EBase>() {
        @Override
        public boolean test(EBase val) {
          return index == val.index && map() == val.map();
        }
      });
    }
    @Override
    public int hashCode() {
      return index;
    }
  }
  private final class SmallSetEntry extends EBase implements Entry<K, V> {
    private SmallSetEntry(int index) {
      super(index);
    }

    @Override
    public K getKey() {
      return compactKey(index);
    }

    @Override
    public V getValue() {
      return compactValue(index);
    }

    @Override
    public V setValue(V value) {
      V oldVal = getValue();
      vals[index] = value;
      return oldVal;
    }

    @Override
    protected SmallMap<?, ?> map() {
      return SmallMap.this;
    }
  }
  
  private abstract class Iter<T> implements Iterator<T> {
    protected int next = 0;
    
    protected abstract T element(int index);
    
    @Override
    public boolean hasNext() {
      return next < size;
    }
    
    @Override
    public T next() {
      if (next >= size) {
        throw new NoSuchElementException();
      }
      return element(next++); 
    }

    @Override
    public void remove() {
      // next-1 is the index of the one just handed out.
      removeElement(next-1);
      next--;
    }
  }
  
  private abstract class Contents<T> extends AbstractSet<T> {
    protected abstract T elementAt(int index);

    @Override
    public Iterator<T> iterator() {
      return new Iter<T>() {
        @Override
        protected T element(int index) {
          return elementAt(index);
        }
      };
    }

    @Override
    public int size() {
      return size;
    }

    @Override
    public void clear() {
      SmallMap.this.clear();
    }

  }
  
  private final class Entries extends Contents<Entry<K, V>> {
    @Override
    public boolean remove(Object o) {
      if (!(o instanceof SmallMap.SmallSetEntry)) {
        return false;
      }
      @SuppressWarnings("unchecked")
      SmallSetEntry e = (SmallSetEntry)o;
      removeElement(e.index);
      return true;
    }

    @Override
    protected Entry<K, V> elementAt(int index) {
      return new SmallSetEntry(index);
    }
  }

  private final class Keys extends Contents<K> {
    @Override
    protected K elementAt(int index) {
      return compactKey(index);
    }

    @Override
    public boolean remove(Object o) {
      int i = compactIndex(o);
      if (i < 0) {
        return false;
      }
      removeElement(i);
      return true;
    }
  }
  private final class Values extends AbstractCollection<V> {

    @Override
    public Iterator<V> iterator() {
      return new Iter<V>() {
        @Override
        protected V element(int index) {
          return compactValue(index);
        }
      };
    }

    @Override
    public int size() {
      return size;
    }

    @Override
    public void clear() {
      SmallMap.this.clear();
    }

  }



  private static final int DEFAULT_MAX_COMPACT = 5;



  private Map<K, V> fullMap = null;
  private Object[] keys;
  private Object[] vals;
  private int size = 0;
  private final int maxCompact;

  public SmallMap(int maxCompact) {
    this.maxCompact = maxCompact;
  }
  
  public SmallMap() {
    this(DEFAULT_MAX_COMPACT);
  }
  
  public SmallMap(int maxCompact, Map<? extends K, ? extends V> map) {
    this.maxCompact = maxCompact;
    if (map != null) {
      if (map.size() > maxCompact) {
        fullMap = new HashMap<>(map);
      } else {
        for (Entry<? extends K, ? extends V> entry : map.entrySet()) {
          put(entry.getKey(), entry.getValue());
        }
      }
    }
  }
  public SmallMap(Map<? extends K, ? extends V> map) {
    this(DEFAULT_MAX_COMPACT, map);
  }
  @Override
  public int size() {
    if (fullMap != null) {
      return fullMap.size();
    }
    return size;
  }

  @Override
  public boolean isEmpty() {
    if (fullMap != null) {
      return fullMap.isEmpty();
    }
    return size == 0;
  }

  @Override
  public boolean containsKey(Object key) {
    if (fullMap != null) {
      return fullMap.containsKey(key);
    }
    int index = compactIndex(key);
    return index >= 0;
  }

  @Override
  public boolean containsValue(Object value) {
    if (fullMap != null) {
      return fullMap.containsValue(value);
    }
    for (int i=0; i<size; i++) {
      final Object oldVal = vals[i];
      if (value == null ? oldVal==null : value.equals(oldVal)) {
        return true;
      }
    }
    return false;
  }

  @Override
  public V get(Object key) {
    if (fullMap != null) {
      return fullMap.get(key);
    }
    int i = compactIndex(key);
    return i < 0 ? null : compactValue(i);
  }

  @Override
  public V put(K key, V value) {
    if (fullMap != null) {
      return fullMap.put(key, value);
    }
    int i = compactIndex(key);
    if (i >= 0) {
      V oldVal = compactValue(i);
      vals[i] = value;
      return oldVal;
    }
    if (keys == null || size == keys.length-1) {
      if (size == maxCompact) {
        fullMap = new HashMap<>(this);
        return fullMap.put(key, value);
      }
      int newSize = growSize(size);
      if (newSize > maxCompact) {
        newSize = maxCompact;
      }
      keys = Arrays.copyOf(keys, newSize);
      vals = Arrays.copyOf(vals, newSize);
    }
    keys[size] = key;
    vals[size] = value;
    size++;
    return null;
  }

  protected int growSize(int current) {
    switch (current) {
    case 0:
      return 1;
    case 1:
      return 2;
    default:
      return (current+1) << 1;
    }
  }

  @Override
  public V remove(Object key) {
    if (fullMap != null) {
      return fullMap.remove(key);
    }
    int i = compactIndex(key);
    if (i < 0) {
      return null;
    }
    V oldVal = compactValue(i);
    removeElement(i);
    return oldVal;
  }

  @Override
  public void putAll(Map<? extends K, ? extends V> m) {
    for (Entry<? extends K, ? extends V> entry : m.entrySet()) {
      put(entry.getKey(), entry.getValue());
    }
  }

  @Override
  public void clear() {
    if (fullMap != null) {
      fullMap.clear();
    }
    if (size > 0) {
      Arrays.fill(keys, 0, size, null);
      Arrays.fill(vals, 0, size, null);
    }
    size = 0;
  }

  @Override
  public Set<K> keySet() {
    if (fullMap != null) {
      return fullMap.keySet();
    }
    if (size == 0) {
      return Collections.emptySet();
    }
    return new Keys();
  }

  @Override
  public Collection<V> values() {
    if (fullMap != null) {
      return fullMap.values();
    }
    if (size == 0) {
      return Collections.emptyList();
    }
    return new Values();
  }

  
  
  @Override
  public Set<Entry<K, V>> entrySet() {
    if (fullMap != null) {
      return fullMap.entrySet();
    }
    if (size == 0) {
      return Collections.emptySet();
    }
    return new Entries();
  }

  private void removeElement(int i) {
    if (i < 0 || i >= size) {
      throw new IllegalStateException();
    }
    final int lastIndex = size-1;
    if (i < lastIndex) {
      keys[i] = keys[lastIndex];
      vals[i] = vals[lastIndex];
      keys[lastIndex] = null;
      vals[lastIndex] = null;
    }
    size--;
  }
  
  private int compactIndex(Object key) {
    for (int i=0; i<size; i++) {
      if (key.equals(keys[i])) {
       return i;
      }
    }
    return -1;
  }
  
  @SuppressWarnings("unchecked")
  private V compactValue(int i) {
    return (V)vals[i];
  }
  @SuppressWarnings("unchecked")
  private K compactKey(int i) {
    return (K)keys[i];
  }
}
