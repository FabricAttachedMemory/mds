/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.adt;

import java.util.Iterator;

import com.hpl.erk.func.Consumer;
import com.hpl.erk.iter.ConstIterator;
import com.hpl.erk.util.ArrayUtils;

public class RingBuffer<T> implements Consumer<T>, Iterable<T> {
  private final int capacity;
  private final T[] elts;
  private int size = 0;
  private int next = 0;

  public RingBuffer(Class<T> cls, int capacity) {
    this(ArrayUtils.newArray(cls, capacity));
  }
  
  public RingBuffer(T[] buffer) {
    this.elts = buffer;
    this.capacity = buffer.length;
  }

  
  public int capacity() {
    return capacity;
  }
  
  public int size() {
    return size;
  }
  
  public T add(T elt) {
    T dropped = elts[next];
    elts[next++] = elt;
    if (next == capacity) {
      next = 0;
    }
    if (size < capacity) {
      size++;
      return null;
    } else {
      return dropped;
    }
  }

  public boolean isFull() {
    return size == capacity;
  }
  
  public boolean isEmpty() {
    return size == 0;
  }


  public int copyMostRecent(int n, T[] array) {
    if (n > size) {
      n = size;
    }
    if (size < capacity) {
      System.arraycopy(elts, 0, array, 0, n);
      return n;
    }
    int end = next==0 ? capacity : next;
    if (end >= n) {
      System.arraycopy(elts, end-n, array, 0, n);
      return n;
    }
    System.arraycopy(elts, capacity-n+next, array, 0, n-next);
    System.arraycopy(elts, 0, array, n-next, next);
    return n;
  }
  
  @Override
  public Iterator<T> iterator() {
    final int start = size < capacity ? 0 : next;
    final int n = size;
    return new ConstIterator<T>() {
      int i = 0;
      @Override
      public boolean hasNext() {
        return i >= n;
      }

      @Override
      public T next() {
        return elts[(start+(i++))%capacity];
      }
    };
  }

  @Override
  public boolean see(T val) {
    add(val);
    return true;
  }
  
  public static <T> RingBuffer<T> holding(Class<T> clss, int size) {
    return new RingBuffer<>(clss, size);
  }
  
  public static <T> RingBuffer<T> filling(T[] array) {
    return new RingBuffer<>(array);
  }
}
