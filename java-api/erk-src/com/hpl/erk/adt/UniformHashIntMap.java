/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/**
 * 
 */
package com.hpl.erk.adt;

import java.util.Iterator;
import java.util.Map;
import java.util.Random;

import com.hpl.erk.mash.MASHR_Algorithm64;


/**
 * An efficient map (but not {@link Map}) whose keys are reasonably uniform 64-bit integers (such as those generated by
 * {@link MASHR_Algorithm64} or {@link Random} and ints.  This is particularly suited for maintaining counts of values
 * that can be represented by good hashes or randomly-generated keys.
 */
public final class UniformHashIntMap extends AbstractUniformHashMap {
  private int[] vals;

  /**
   * An entry in a {@link UniformHashIntMap}, retrievable via its {@link entries}() method. 
   */
  public static class Entry {
    private final long key;
    private final int val;
    private Entry(long key, int val) {
      this.key = key;
      this.val = val;
    }
    /**
     * @return the value associated with the entry.
     */
    public int getVal() {
      return val;
    }
    /**
     * @return the key associated with the entry.
     */
    public long getKey() {
      return key;
    }
  }
  
  
  private class EntryIterator extends Iter<Entry> {
    @Override
    protected Entry element(long key, int index) {
      return new Entry(key, vals[index]);
    }
  }
  
  private class ValueIterator extends Iter<Integer> {
    @Override
    protected Integer element(long key, int index) {
      return vals[index];
    }
  }

  /**
   * A {@link UniformHashIntMap} with a capacity sufficient for the estimate.
   * 
   * @param expected a capacity estimate
   */
  public UniformHashIntMap(int expected) {
    super(expected);
    vals = new int[capacity];
  }
  
  /**
   * A {@link UniformHashIntMap} with a default capacity of 16 elements.
   */
  public UniformHashIntMap() {
    this(DEFAULT_INITIAL_CAPACITY);
  }
  
  /**
   * 
   * @param hash the key
   * @return the value associated with the key, or {@code 0} if no such value exists.
   */
  public int get(long hash) {
    int index = findIndex(hash);
    if (index >= 0) {
      return vals[index];
    }
    return 0;
  }
  
  private class CB implements PutCallBack {
    final int newVal;
    int oldVal = 0;
    CB(int val) {
      newVal = val;
    }
    @Override
    public boolean replace(int oldIndex, int newIndex) {
      if (oldIndex >= 0) {
        oldVal = vals[oldIndex];
      }
      vals[newIndex] = newVal;
      return newVal != oldVal;
    }
    
  }
  /**
   * Associate a new value with a key.
   * @param k the key
   * @param val the new value
   * @return the old value associated with the key or {@code 0} if no such value existed.
   */
  public int put(long k, int val) {
    CB cb = new CB(val);
    put(k, cb);
    return cb.oldVal;
  }
  
  private class RCB implements RemoveCallBack {
    int oldVal = 0;

    @Override
    public void removedFrom(int index) {
      oldVal = vals[index];
    }
  }
  /**
   * Remove the value, if any, associated with a key.
   * @param k the key
   * @return the old value associated with the key, or {@code 0} if no such value existed.
   */
  public int remove(long k) {
    RCB cb = new RCB();
    remove(k, cb);
    return cb.oldVal;
  }
  
  /**
   * 
   * @return an object to use for iterating over the {@link Entry} objects corresponding to the associations
   * in the map.  No guarantee is made as to the order entries are returned.
   *  Associations may be deleted by using the {@link Iterator}'s {@code remove}() method.
   */
  public Iterable<Entry> entries() {
    return new Iterable<Entry>() {
      @Override
      public Iterator<Entry> iterator() {
        return new EntryIterator();
      }};
  }

  /**
   * 
   * @return an object to use for iterating over the values of the associations in the map.  If a value occurs more
   * than once in the map, it will occur more than once in the iteration.  No guarantee is made as to the 
   * order values are returned. 
   *  Associations may be deleted by using the {@link Iterator}'s {@code remove}() method.
   */
  public Iterable<Integer> values() {
    return new Iterable<Integer>() {
      @Override
      public Iterator<Integer> iterator() {
        return new ValueIterator();
      }};
  }
  
  public static interface Filter<T> {
      boolean keep(long hash, T val);
  }

  @Override
  protected void removeAtIndex(int index) {
  }

  @Override
  protected void resizeValues(int size) {
    vals = new int[size];
    
  }

  @Override
  protected Resizer resizer() {
    return new Resizer() {
      final int[] oldVals = vals;
      @Override
      public void copyFrom(long key, int index) {
        int val = oldVals[index];
        put(key, val);
      }
    };
  }
}