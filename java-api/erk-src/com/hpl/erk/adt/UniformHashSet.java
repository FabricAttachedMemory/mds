/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.adt;

import java.util.AbstractSet;
import java.util.Collection;
import java.util.Iterator;
import java.util.Random;
import java.util.Set;

import cern.colt.function.LongProcedure;

import com.hpl.erk.adt.AbstractUniformHashMap.PutCallBack;
import com.hpl.erk.adt.AbstractUniformHashMap.RemoveCallBack;
import com.hpl.erk.mash.MASHR_Algorithm64;

/**
 * A set (and {@link Set}) that efficiently contains reasonably-uniform 64-bit numbers,
 * as generated by {@link MASHR_Algorithm64} or {@link Random}.
 *
 */
public class UniformHashSet extends AbstractSet<Long>{
  private final InternalMap map;
  
  private static class InternalMap extends AbstractUniformHashMap {
    public InternalMap(int expected) {
      super(expected);
    }

    @Override
    protected void removeAtIndex(int index) {}

    @Override
    protected void resizeValues(int size) {}

    @Override
    protected Resizer resizer() {
      return new Resizer() {
        @Override
        public void copyFrom(long key, int index) {
          put(key, new CB());
        }
      };
    }
    
  }
  
  /**
   * A new {@link UniformHashSet} with a capacity sufficient for the estimate.
   * @param initialCap a capacity estimate.
   */
  public UniformHashSet(int initialCap) {
    map = new InternalMap(initialCap); 
  }
  
  /**
   * A new {@link UniformHashSet} with a default capacity of 16 elements.
   */
  public UniformHashSet() {
    this(AbstractUniformHashMap.DEFAULT_INITIAL_CAPACITY);
  }
  
  /**
   * A new {@link UniformHashSet} containing only the elements in {@code initialContents}.
   * @param initialContents an array of longs.  May be null and may contain duplicates.
   */
  public UniformHashSet(long[] initialContents) {
    this(initialContents == null ? AbstractUniformHashMap.DEFAULT_INITIAL_CAPACITY : initialContents.length);
    if (initialContents != null) {
      addAll(initialContents);
    }
  }
  /**
   * A new {@link UniformHashSet} containing only the elements in {@code initialContents}.
   * @param initialContents a {@link Collection} of {@link Long}s.  May be null and may contain duplicates.
   */
  public UniformHashSet(Collection<? extends Long> initialContents) {
    this(initialContents == null ? AbstractUniformHashMap.DEFAULT_INITIAL_CAPACITY : initialContents.size());
    if (initialContents != null) {
      addAll(initialContents);
    }
  }

  /**
   * An iterator over the contents.  May be used to iterate over the {@link UniformHashSet}.
   *  Associations may be deleted by using the {@link Iterator}'s {@code remove}() method.
   */
  @Override
  public Iterator<Long> iterator() {
    return map.keys().iterator();
  }

  @Override
  public int size() {
    return map.size();
  }
  
  @Override
  public boolean contains(Object o) {
    if (!(o instanceof Long)) {
      return false;
    }
    Long n = (Long)o;
    return contains((long)n);
  }
  
  /**
   * 
   * @param n a reasonably-uniform number
   * @return {@code true} iff the set contains the number.
   */
  public boolean contains(long n) {
    return map.containsKey(n);
  }
  
  @Override
  public boolean add(Long e) {
    return add((long)e);
  }

  private static class CB implements PutCallBack, RemoveCallBack {
    boolean isNew = true;
    @Override
    public boolean replace(int oldIndex, int newIndex) {
      isNew = oldIndex < 0;
      return isNew;
    }
    @Override
    public void removedFrom(int index) {
      isNew = false;
    }
    
  }
  
  /**
   * Add a number to the set
   * @param n a reasonably-uniform number
   * @return {@code true} if the set did not previously contain the number. 
   */
  public boolean add(long n) {
    CB cb = new CB();
    map.put(n, cb);
    return cb.isNew;
  }
  
  @Override
  public boolean addAll(Collection<? extends Long> c) {
    boolean modified = false;
    for (long n : c) {
      if (add(n)) {
        modified = true;
      }
    }
    return modified;
  }
  
  /**
   * Add numbers to the set.
   * @param array an array of reasonably-uniform numbers
   * @return {@code true} if at least one of the elements of the array was not previously in the set.
   */
  public boolean addAll(long[] array) {
    boolean modified = false;
    final int n = array.length;
    for (int i=0; i<n; i++) {
      if (add(array[i])) {
        modified = true;
      }
    }
    return modified;
  }
  
  /**
   * Remove a number from the set.
   * @param n a reasonably-uniform number
   * @return true if the set contained the number prior to removal.
   */
  public boolean remove(long n) {
    CB cb = new CB();
    map.remove(n, cb);
    return !cb.isNew;
  }
  
  @Override
  public boolean remove(Object o) {
    if (!(o instanceof Long)) {
      return false;
    }
    Long n = (Long)o;
    return remove((long)n);
  }
  
  /**
   * 
   * @return an array containing the numbers in the set.  This array is newly created and may be modified.
   */
  public long[] toHashArray() {
    return map.keysArray();
  }
  
  /**
   * Invoke a procedure for each element in the set in some order.  If the procedure returns {@code false}, the
   * iteration is terminated.
   * @param proc the procedure
   */
  public void forEach(LongProcedure proc) {
    map.forEachKey(proc);
  }
  
}
