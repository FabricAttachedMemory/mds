/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.adt;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.RandomAccess;
import java.util.concurrent.ThreadLocalRandom;

import com.hpl.erk.chain.Chain;
import com.hpl.erk.chain.RandomAccessSource;
import com.hpl.erk.func.Functions;
import com.hpl.erk.iter.ConstIterator;

/**
 * Like a deck of cards, provides random permutations of a collection of objects.  Shuffling (resetting to begin
 * a new permutation) takes constant time.  Decks are created by calling the static functions {@link Deck#of(Object[])}, 
 * {@link Deck#of(Collection)}, {@link Deck#of(Iterable)}, and {@link Deck#of(Chain)}.  There is also {@link Deck#ofIntsTo(int max)}, 
 * which returns an {@link IndexDeck}, which adds a {@link IndexDeck#dealInt()} method that returns an unboxed <code>int</code>.
 * <p/>
 * Each of these takes an optional 
 * final argument of type {@link Use}, which specifies what to do with that collection.  If this is {@link Use#IN_PLACE} (the default), 
 * the collection will, if possible, be used in-place, with elements swapped between positions.  If it is {@link Use#INDEX}, 
 * values will be taken from the collection, but the elements will be left in place and a side array of indices will be
 * created and used.  If it is {@link Use#COPY}, the collection will be copied.  Which to choose depends on whether it
 * matters whether the collection is modified by the permutation (in which case {@link Use#IN_PLACE} should not be chosen) or
 * whether the values are likely to change while the deck is active (in which case it is probably a good idea not to use
 * {@link Use#INDEX}).  If the collection is not random-access, this argument is ignored and {@link Use#COPY} is assumed.
 * <p/>
 * Elements are selected by calling {@link #deal(OnEmpty action)}.  The action specifies what to do when the deck is empty.  
 * If this is {@link OnEmpty#THROW}, a {@link NoSuchElementException} is thrown.  If it is {@link OnEmpty#RETURN_NULL}, 
 * <code>null</code> is returned.  If it is {@link OnEmpty#SHUFFLE}, the deck is reshuffled and the first element drawn 
 * from the deck is returned.
 * <p/>
 * Decks implement {@link Iterable}.  When an iterator is constructed, the deck is shuffled, and the iterator returns elements
 * until the deck is empty.  Note that if others shuffle or draw from the deck, this will affect the iteration.
 * <p/>
 * Unlike collections {@link #size()} and {@link #isEmpty()} are decoupled for decks.  size() returns the overall size of the
 * deck, while isEmpty() returns <code>true</code> when there are no more elements to hand out in the current deal.
 * 
 * @author Evan Kirshenbaum
 *
 * @param <T> the element type
 */
public abstract class Deck<T> implements Iterable<T> {
  /**
   * Specifies the action to be performed when drawing from an empty deck.  Options are {@link OnEmpty#SHUFFLE},
   * {@link OnEmpty#RETURN_NULL}, and {@link OnEmpty#THROW}.
   */
  public enum OnEmpty {
    /**
     * When the deck is empty, reshuffle and return the first element drawn from the newly shuffled deck.
     */
    SHUFFLE, 
    /**
     * When the deck is empty, return <code>null</code>.
     */
    RETURN_NULL, 
    /**
     * When the deck is empty, throw a {@link NoSuchElementException}.
     */
    THROW 
  };
  /**
   * Specifies what to do with the collection argument when creating a deck. 
   * Options are {@link Use#IN_PLACE}, {@link Use#INDEX}, and {@link Use#COPY}. 
   */
  public enum Use {
    /**
     * Use the collection as is, permuting the values in-place.
     */
    IN_PLACE, 
    /**
     * Use the collection as is, but don't permute the values.
     */
    INDEX, 
    /**
     * Copy the collection before use.
     */
    COPY 
  }
  protected final int size;
  protected int dealtTo = 0;
  protected int shuffledTo;
    
  protected abstract T get(int i);
  protected abstract T swap(int i, int j);

  protected Deck(int size) {
    this.size = size;
    shuffledTo = 0;
    dealtTo = 0;
  }

  public boolean isEmpty() {
    return dealtTo >= size;
  }
  
  public int size() {
    return size;
  }
  
  public T deal(OnEmpty action) {
    if (dealtTo < shuffledTo) {
      return get(dealtTo++);
    }
    if (shuffledTo >= size) {
      switch (action) {
      case SHUFFLE:
        shuffle();
        return deal(OnEmpty.THROW);
      case RETURN_NULL:
        return null;
      case THROW:
        throw new NoSuchElementException();
      }
    }
    int which = ThreadLocalRandom.current().nextInt(shuffledTo, size);
    T val = swap(shuffledTo, which);
    shuffledTo++;
    dealtTo++;
    return val;
  }
  
  public int dealInto(T[] array, int from, int to, OnEmpty action) {
    ThreadLocalRandom rnd = null;
    if (size == 0) {
      return 0;
    }
    for (int i=from; i<to; i++) {
      if (dealtTo < shuffledTo) {
        array[i] = get(dealtTo++);
      } else {
        if (shuffledTo >= size) {
          switch (action) {
          case SHUFFLE:
            shuffle();
            break;
          case RETURN_NULL:
            return i-from;
          case THROW:
            throw new NoSuchElementException();
          }
        }
        if (rnd == null) {
          rnd = ThreadLocalRandom.current();
        }
        int which = rnd.nextInt(shuffledTo, size);
        T val = swap(shuffledTo, which);
        shuffledTo++;
        dealtTo++;
        array[i] = val;
      }
    }
    return to-from;
  }

  public int dealInto(T[] array, OnEmpty action) {
    return dealInto(array, 0, array.length, action);
  }

  
  public void shuffle() {
    shuffledTo = 0;
    dealtTo = 0;
  }
  
  public static Deck<Integer> ints(int max) {
    return new IndexDeck(max);
  }
  
  public static <T, U extends T> Deck<T> of(final U[] array) {
    return of(array, Use.IN_PLACE);
  }
  public static <T, U extends T> Deck<T> of(final U[] array, Use mode) {
    switch (mode) {
    case INDEX:
      return new IndexedDeck<T>(array.length) {
        @Override
        protected T getUnderlying(int i) {
          return array[i];
        }
      };
    case COPY:
      U[] clone = array.clone();
      return Deck.of(clone, Use.IN_PLACE);
    case IN_PLACE:
      return new Deck<T>(array.length) {
        @Override
        protected T get(int i) {
          return array[i];
        }

        @Override
        protected T swap(int i, int j) {
          U val = array[j];
          array[j] = array[i];
          array[i] = val;
          return val;
        }
      };
    default:
      throw new IllegalStateException();  
    }
  }
  
  public static <T> Deck<T> of(final Iterable<? extends T> iterable) {
    return Deck.of(iterable, Use.IN_PLACE);
  }
  public static <T> Deck<T> of(final Iterable<? extends T> iterable, Use mode) {
    if (iterable instanceof Collection) {
      return Deck.of((Collection<? extends T>)iterable, mode);
    }
    if (iterable instanceof Chain) {
      @SuppressWarnings("unchecked")
      final Chain<?, ? extends T> chain = (Chain<?, ? extends T>)iterable;
      return Deck.of(chain, mode);
    }
    return Deck.ofRAList(Chain.from(iterable).asList(), Use.IN_PLACE);
  }
  
  public static <T> Deck<T> of(final Collection<? extends T> collection) {
    return Deck.of(collection, Use.IN_PLACE);
  }
  public static <T> Deck<T> of(final Collection<? extends T> collection, Use mode) {
    if (mode != Use.COPY && (collection instanceof List) && collection instanceof RandomAccess) {
      return Deck.ofRAList((List<? extends T>)collection, mode);
    }
    ArrayList<? extends T> clone = new ArrayList<>(collection);
    return Deck.ofRAList(clone, Use.IN_PLACE);
  }
  
  public static <T> Deck<T> of(final Chain<?, ? extends T> chain) {
    return Deck.of(chain, Use.IN_PLACE);
  }
  public static <T> Deck<T> of(final Chain<?, ? extends T> chain, Use mode) {
    final RandomAccessSource<? extends T> ra = chain.randomAccess();
    if (ra == null || mode == Use.COPY) {
      int size = chain.expectedSize();
      if (size == Integer.MAX_VALUE) {
        return Deck.ofRAList(chain.asList(), Use.IN_PLACE);
      } else {
        ArrayList<T> clone = new ArrayList<>(size);
        chain.into(clone);
        return Deck.ofRAList(clone, Use.IN_PLACE);
      }
    }
    return new IndexedDeck<T>(ra.size()) {
      @Override
      protected T getUnderlying(int i) {
        return ra.get(i);
      }
    };
  }
  
  private static <T> Deck<T> ofRAList(final List<? extends T> list, Use mode) {
    switch (mode) {
    case INDEX:
      return new IndexedDeck<T>(list.size()) {
        @Override
        protected T getUnderlying(int i) {
          return list.get(i);
        }
      };
    case COPY:
      ArrayList<? extends T> clone = new ArrayList<>(list);
      return Deck.ofRAList(clone, Use.IN_PLACE);
    case IN_PLACE:
      return new Deck<T>(list.size()) {
        @Override
        protected T get(int i) {
          return list.get(i);
        }

        @Override
        protected T swap(int i, int j) {
          Collections.swap(list, i, j);
          return list.get(i);
        }
      };
    default:
      throw new IllegalStateException();  
    }
  }
  
  public static IndexDeck ofIntsTo(int max) {
    return new IndexDeck(max);
  }

  
  @Override
  public Iterator<T> iterator() {
    return new ConstIterator<T>() {
      {
        shuffle();
      }

      @Override
      public boolean hasNext() {
        return !isEmpty();
      }

      @Override
      public T next() {
        return deal(OnEmpty.THROW);
      }};
  }

  public static void main(String[] args) {
    Deck<Integer> ints = Deck.ints(20);
    for (int i=0; i<20; i++) {
      System.out.println(Chain.from(ints).asString().reduce(Functions.join(",")).val());
    }
  }
}
