/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk;



/*
 * Allowing a test for equality and getting at the underlying type gets to the point that
 * there's a problem with relying on superclass types: If the parameter is a type variable,
 * as it would be in a generic method, you get the same Type every time, regardless of what it's
 * bound to.  So we're probably better just using this class as a syntactic marker.
 */
public abstract class Marker<T> {
  private static final Marker<?> inst = new Marker<Object>() {};
//  Type type = null;
  private Marker() {}
  
  @SuppressWarnings("unchecked")
  public static <T> Marker<T>inst() {
    return (Marker<T>)inst;
//    return new Marker<T>() {};
  }
  
//  public Type type() {
//    if (type == null) {
//      type = getClass().getGenericSuperclass();
//    }
//    return type;
//  }
//  
//  @Override
//  public String toString() {
//    return type().toString();
//  }
//  
//  @Override
//  public boolean equals(Object obj) {
//    if (obj == this) {
//      return true;
//    }
//    if (obj == null) {
//      return false;
//    }
//    if (!(obj instanceof Marker)) {
//      return false;
//    }
//    return type() == ((Marker<?>)obj).type();
//  }
  
//  @Override
//  public int hashCode() {
//    return type().hashCode();
//  }
  
//  public static void main(String[] args) {
//    Marker<Integer> m1 = new Marker<Integer>() {};
//    Marker<List<String>> m2 = new Marker<List<String>>() {};
//    Marker<List<String>> m2b = new Marker<List<Integer>>() {};
//    Marker<Integer> m3 = Marker.<Integer>inst();
//    Marker<List<String>> m4 = Marker.<List<String>>inst();
//    m2.type();
//    m2b.type();
//    m3.type();
//    m4.type();
//    System.out.println(m2.equals(m2b));
//    System.out.println(SeqFormatter.list().addAll(Arrays.asList(m1, m2, m3, m4)));
//  }

}
