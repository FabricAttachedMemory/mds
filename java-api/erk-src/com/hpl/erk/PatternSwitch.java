/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.hpl.erk.func.BinaryProc;
import com.hpl.erk.func.Functions;
import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.func.UnaryProc;
import com.hpl.erk.util.Strings;

public abstract class PatternSwitch<T> implements UnaryFunc<String, T> {
  public static interface Action<T> {
    T compute(String s, Matcher m);
  }
  protected final List<Case<T>> cases;
  
  protected abstract UnaryFunc<? super String, ? extends T> defaultAction();
  
  private static final class Case<T> {
    final Test test;
    final Action<? extends T> action;
    protected Case(Test test, Action<? extends T> action) {
      this.action = action;
      this.test = test;
    }
  }
  
  private enum TestType {
    MATCH {
      @Override
      public boolean perform(Matcher m) {
        return m.matches();
      }
    },
    FIND {
      @Override
      public boolean perform(Matcher m) {
        return m.find();
      }
    };

    public abstract boolean perform(Matcher m);
    public Test test(Pattern pattern) {
      return new Test(this, pattern);
    }
    
  }
  
  private static final class Test {
    
    private final TestType type;
    private final Pattern pattern;

    protected Test(TestType type, Pattern pattern) {
      this.type = type;
      this.pattern = pattern;
    }
    @Override
    public String toString() {
      return String.format("%s %s", type, pattern);
    }
    public Matcher check(String s) {
      Matcher m = pattern.matcher(s);
      if (type.perform(m)) {
        return m;
      } 
      return null;
    }
  }
  
  protected PatternSwitch(List<Case<T>> cases) {
    this.cases = cases;
  }

  public static class SwitchWithoutDefault<T> extends PatternSwitch<T> {
    protected SwitchWithoutDefault() {
      super(new ArrayList<Case<T>>());
    }
    
    public InTest onMatch(Pattern... patterns) {
      return new InTest().orMatch(patterns);
    }
    public SwitchWithoutDefault<T> onMatch(Pattern pattern, Action<? extends T> action) {
      return onMatch(pattern).yield(action);
    }
    public SwitchWithoutDefault<T> onMatch(Pattern pattern, final T val) {
      return onMatch(pattern).yield(val);
    }
    public SwitchWithoutDefault<T> onMatch(Pattern pattern, final UnaryFunc<? super String, ? extends T> transformer) {
      return onMatch(pattern).yield(transformer);
    }

    public InTest onFind(Pattern... patterns) {
      return new InTest().orFind(patterns);
    }
    public SwitchWithoutDefault<T> onFind(Pattern pattern, Action<? extends T> action) {
      return onFind(pattern).yield(action);
    }
    public SwitchWithoutDefault<T> onFind(Pattern pattern, final T val) {
      return onFind(pattern).yield(val);
    }
    public SwitchWithoutDefault<T> onFind(Pattern pattern, final UnaryFunc<? super String, ? extends T> transformer) {
      return onFind(pattern).yield(transformer);
    }

    public SwitchWithDefault<T> otherwise(UnaryFunc<? super String, ? extends T> action) {
      return new SwitchWithDefault<>(cases, action);
    }
    public SwitchWithDefault<T> otherwise(final T constant) {
      return new SwitchWithDefault<>(cases, new UnaryFunc<String, T>() {
        @Override
        public T call(String val) {
          return constant;
        }});
    }

    @Override
    protected UnaryFunc<String, T> defaultAction() {
      return null;
    }
    public class InTest {
      private final List<Test> tests = new ArrayList<>();
      
      public InTest orMatch(Pattern...patterns) {
        for (Pattern p : patterns) {
          this.tests.add(TestType.MATCH.test(p));
        }
        return this;
      }
      public InTest orFind(Pattern...patterns) {
        for (Pattern p : patterns) {
          this.tests.add(TestType.FIND.test(p));
        }
        return this;
      }
      
      public SwitchWithoutDefault<T> yield(Action<? extends T> action) {
        for (Test test : tests) {
          Case<T> c = new Case<>(test, action);
          cases.add(c);
        }
        return SwitchWithoutDefault.this;
      }
      public SwitchWithoutDefault<T> yield(final T constant) {
        return yield(new Action<T>() {
          @Override
          public T compute(String s, Matcher m) {
            return constant;
          }});
      }
      public SwitchWithoutDefault<T> yield(final UnaryFunc<? super String, ? extends T> transformer) {
        return yield(new Action<T>() {
          @Override
          public T compute(String s, Matcher m) {
            return transformer.call(s);
          }});
      }
      
    }

  }
  
  public static class SwitchWithDefault<T> extends PatternSwitch<T> {
    private final UnaryFunc<? super String, ? extends T> defaultAction;
    protected SwitchWithDefault(List<Case<T>> cases,
                                UnaryFunc<? super String, ? extends T> defaultAction) {
      super(cases);
      this.defaultAction = defaultAction;
    }
    @Override
    protected UnaryFunc<? super String, ? extends T> defaultAction() {
      return defaultAction;
    }
    
  }
  
  public static class NoValSwitchWithoutDefault extends PatternSwitch<Void> {
    protected NoValSwitchWithoutDefault() {
      super(new ArrayList<Case<Void>>());
    }
    
    public InTest onMatch(Pattern... patterns) {
      return new InTest().orMatch(patterns);
    }
    public NoValSwitchWithoutDefault onMatch(Pattern pattern, BinaryProc<? super String, ? super Matcher> action) {
      return onMatch(pattern).perform(action);
    }
    public NoValSwitchWithoutDefault onMatch(Pattern pattern, final UnaryProc<? super String> action) {
      return onMatch(pattern).perform(action);
    }

    public InTest onFind(Pattern... patterns) {
      return new InTest().orFind(patterns);
    }
    public NoValSwitchWithoutDefault onFind(Pattern pattern, BinaryProc<? super String, ? super Matcher> action) {
      return onFind(pattern).perform(action);
    }
    public NoValSwitchWithoutDefault onFind(Pattern pattern, final UnaryProc<? super String> action) {
      return onFind(pattern).perform(action);
    }

    public NoValSwitchWithDefault otherwise(UnaryProc<? super String> action) {
      return new NoValSwitchWithDefault(cases, action);
    }

    @Override
    protected UnaryFunc<? super String, ? extends Void> defaultAction() {
      return null;
    }
    public class InTest {
      private final List<Test> tests = new ArrayList<>();
      
      public InTest orMatch(Pattern...patterns) {
        for (Pattern p : patterns) {
          this.tests.add(TestType.MATCH.test(p));
        }
        return this;
      }
      public InTest orFind(Pattern...patterns) {
        for (Pattern p : patterns) {
          this.tests.add(TestType.FIND.test(p));
        }
        return this;
      }
      
      public NoValSwitchWithoutDefault perform(final BinaryProc<? super String, ? super Matcher> action) {
        for (Test test : tests) {
          Case<Void> c = new Case<>(test, new Action<Void>() {
            @Override
            public Void compute(String s, Matcher m) {
              action.call(s, m);
              return null;
            }
          });
          cases.add(c);
        }
        return NoValSwitchWithoutDefault.this;
      }
      public NoValSwitchWithoutDefault perform(final UnaryProc<? super String> action) {
        return perform(new BinaryProc<String, Matcher>() {
          @Override
          public void call(String a, Matcher b) {
            action.call(a);
          }});
      }
      
    }
  }
  
  public static class NoValSwitchWithDefault extends PatternSwitch<Void> {
    private final UnaryProc<? super String> defaultAction;
    protected NoValSwitchWithDefault(List<Case<Void>> cases,
                                     UnaryProc<? super String> defaultAction) {
      super(cases);
      this.defaultAction = defaultAction;
    }
    @Override
    protected UnaryFunc<? super String, ? extends Void> defaultAction() {
      return new UnaryFunc<String, Void>() {
        @Override
        public Void call(String val) {
          defaultAction.call(val);
          return null;
        }
      };
    }
    
  }
  
  @Override
  public T call(String s) {
    for (Case<? extends T> c : cases) {
      Matcher m = c.test.check(s);
      if (m != null) {
        return c.action.compute(s, m);
      }
    }
    UnaryFunc<? super String, ? extends T> da = defaultAction();
    if (da == null) {
      return null;
    }
    return da.call(s);
  }
  
  public T switchOn(String s) {
    return call(s);
  }
  
  public static <T> SwitchWithoutDefault<T> yielding() {
    return new SwitchWithoutDefault<>();
  }
  public static <T> SwitchWithoutDefault<T> yielding(Class<T> c) {
    return new SwitchWithoutDefault<>();
  }
  public static NoValSwitchWithoutDefault noVal() {
    return new NoValSwitchWithoutDefault();
  }
  
  
  public static void main(String[] args) {
    String x = "Test";
    Pattern p=null;
    @SuppressWarnings("unused")
    String v = PatternSwitch.yielding(String.class)
        .onMatch(Pattern.compile("foo"), new Action<String>() {
          @Override
          public String compute(String s, Matcher m) {
            // TODO Auto-generated method stub
            return null;
          }
        })
        .onFind(p, "something")
        .onMatch(p, Strings.toLowerCase())
        .onMatch(p,p).orFind(p).yield("s")
        .otherwise(Functions.<String>identity())
        .call(x);

  }

  
}
