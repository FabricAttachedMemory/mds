/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.formatters;

import java.math.BigInteger;

import com.hpl.erk.formatters.IntFormatter.MagnitudeFormatter;
import com.hpl.erk.util.Strings;

public class EnglishWordsMagFormatter extends MagnitudeFormatter {
  
  @Override
  public String formatMagnitude(long u, IntFormatter fmtr) {
    if (u > fmtr.maxAsWords()) {
      return DigitStringMagFormatter.DECIMAL.formatMagnitude(u, fmtr);
    }
    String ungrouped = ungroupedString(u);
    SeqFormatter<String> formatter = SeqFormatter.spaceSep();
    spellInto(formatter, ungrouped, fmtr.isOrdinal(), 0, ungrouped.length());
    return formatter.toString();
  }


  @Override
  public boolean defaultSigned() {
    return true;
  }
  private static String ungroupedString(long u) {
    if (u < 0) {
      byte[] bytes = byteArray(u);
      BigInteger big = new BigInteger(1, bytes);
      return big.toString();
    }
    return Long.toString(u);
  }
  
  private static byte[] byteArray(long u) {
    final int nBytes = Long.SIZE/8;
    byte[] bytes = new byte[nBytes];
    for (int i=nBytes-1; i>=0; i--, u>>>=8) {
      bytes[i] = (byte)(u & 0xFF);
    }
    return bytes;
  }


  public static final String[] base = { "zero", "one", "two", "three", "four", 
    "five", "six", "seven", "eight", "nine",
    "ten", "eleven", "twelve", "thirteen", "fourteen",
    "fifteen", "sixteen", "seventeen", "eighteen", "nineteen" };
  public static final String[] ordinals = { "zeroth", "first", "second", "third", "fourth", 
    "fifth", "sixth", "seventh", "eighth", "ninth", 
    "tenth", "eleventh", "twelfth" };
  public static final String[] tens = { "", "", "twenty", "thirty", "forty", 
    "fifty", "sixty", "seventy", "eighty", "ninety" };
  public static final String[] thousands = { "", "thousand", "million", "billion", "trillion", "quadrillion", "quintillion", 
    "sextillion", "septillion" };

  private boolean spellInto(SeqFormatter<String> formatter, String ungrouped, boolean ordinal, int thousandsLevel, int end) {
    final int nextLevelEnd = Math.max(0, end-3);
    boolean actionAtNextLevel = false;
    if (nextLevelEnd > 0) {
      actionAtNextLevel = spellInto(formatter, ungrouped, ordinal, thousandsLevel+1, nextLevelEnd);
    }
    String block;
    switch (end) {
    case 1:
      block = "00"+ungrouped.substring(0,1);
      break;
    case 2:
      block = "0"+ungrouped.substring(0,2);
      break;
    default:
      block = ungrouped.substring(nextLevelEnd, end);
    }
    if (nextLevelEnd > 0 && block.equals("000")) {
      if (ordinal && actionAtNextLevel) {
        formatter.suffix("th");
      }
      return false;
    }
    int hundreds= Character.digit(block.charAt(0), 10);
    int tens= Character.digit(block.charAt(1), 10);
    int ones= Character.digit(block.charAt(2), 10);
    int twoDigit = tens*10+ones;
    if (hundreds > 0) {
      formatter.add(base[hundreds]).add("hundred");
    }
    if ((hundreds > 0 || nextLevelEnd > 0) && twoDigit < 10 && twoDigit > 0) {
      formatter.add("and");
    }
    String twoDigitString = formatTo99(twoDigit, ordinal && thousandsLevel == 0);
    if (twoDigit > 0 || hundreds == 0) {
      formatter.add(twoDigitString);
    }
    if (thousandsLevel > 0) {
      formatter.add(thousands[thousandsLevel]);
    } else if (ordinal && twoDigit == 0 && hundreds > 0) {
      formatter.suffix("th");
    }
    return true;
  }

  private static String formatTo99(int n, boolean ordinal) {
    if (n < base.length) {
      return small(n, ordinal);
    }
    int tensDigit= n/10;
    int unitsDigit = n%10;
    if (unitsDigit == 0) {
      if (ordinal) {
        return Strings.chopFromEnd(1, tens[tensDigit])+"ieth";
      }
      return tens[tensDigit];
    } 
    return tens[tensDigit]+"-"+small(unitsDigit, ordinal);
  }

  public static String small(int n, boolean ordinal) {
    if (ordinal) {
      return n < ordinals.length ? ordinals[n] : base[n]+"th";
    }
    return base[n];
  }


}
