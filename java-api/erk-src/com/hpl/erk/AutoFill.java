/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.hpl.erk.func.NullaryFunc;
import com.hpl.erk.func.Functions;
import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.util.CollUtils;

/**
 * {@code AutoFill<K,V>} provides an implementation of {@code Map<K,V>} that guarantees
 * that calls to {@code get()} will return non-null, generating new value objects as needed.
 * The class wraps a {@code Map<K,V>}, delegating all method calls except {@code get()} to
 * it.  Note that this includes calls to {@code containsKey()}, so {@code get()} will 
 * return non-null, even if {@code containsKey()} returns {@code false}.
 * 
 * <p> {@code AutoFill} objects must implement a {@code generate()} method to create the value,
 * as in
 * 
 * <pre>
 *   {@code Map<String,Record>} map = new AutoFill<String,Record>(new{@code HashMap<String,Record>}(100)) {
 *     Record generate() {
 *       return new MyRecord();
 *     }
 *   } 
 * </pre>
 * A static function encapsulates this common case of using a null constructor to do the
 * generation:
 * <pre>
 * {@code Map<String,Record>} map = AutoFill.wrap(MyRecord.class, new{@code HashMap<String,Record>}(100));
 * </pre>
 * 
 * A more general wrapper takes a {@code Generator<V>} argument, as in
 * 
 * <pre>
 * {@code Generator<MyRecord>} gen = new{@code Generator<MyRecord>}() {
 *   MyRecord generate() {
 *     MyRecord rec = findUnusedRecord();
 *     if (rec == null) {
 *       rec = new MyRecord();
 *     }
 *     return rec;
 *   }
 * }
 * 
 * {@code Map<String,Record>} map = AutoFill.wrap(gen, new{@code HashMap<String,Record>}(100));
 * </pre>
 * 
 * @author Evan Kirshenbaum
 *
 * @param <K> The map key type
 * @param <V> The map value type
 */

public abstract class AutoFill {
  private AutoFill() {}
  
  
  public static <K,V> Map<K,V> wrap(Map<K,V> map, final UnaryFunc<? super K, ? extends V> valCreator) {
    return new Wrapped<K,V>(map, valCreator);
  }
  public static <K,V> Map<K,V> wrap(Map<K,V> map, final NullaryFunc<? extends V> valCreator) {
    return new Wrapped<K,V>(map, valCreator);
  }
  public static <K,V> Map<K, V> wrap(Map<K,V> map, Class<? extends V> valClass) {
    return wrap(map, Functions.makeNew(valClass));
  }
  
  public static <K,V> Map<K, V> newMap(NullaryFunc<? extends Map<K, V>> mapCreator,  UnaryFunc<? super K, ? extends V> valCreator) {
    return wrap(mapCreator.call(), valCreator);
  }
  public static <K,V> Map<K, V> newMap(NullaryFunc<? extends Map<K, V>> mapCreator,  NullaryFunc<? extends V> valCreator) {
    return wrap(mapCreator.call(), valCreator);
  }
  public static <K,V> Map<K, V> newMap(NullaryFunc<? extends Map<K, V>> mapCreator,  Class<? extends V> valClass) {
    return wrap(mapCreator.call(), valClass);
  }
  
  
  
  public static <K,V> Map<K,Set<V>> hashMapToHashSet() {
    return new HashMap<K,Set<V>>(CollUtils.<V>hashSetCreator());
  }
  public static <K,V> Map<K,Set<V>> hashMapToHashSet(Marker<K> key, Marker<V> val) {
    return AutoFill.<K,V>hashMapToHashSet();
  }
  public static <K,V> Map<K,Set<V>> hashMapToHashSet(Marker<K> key, Class<V> val) {
    return AutoFill.<K,V>hashMapToHashSet();
  }
  public static <K,V> Map<K,Set<V>> hashMapToHashSet(Class<K> key, Marker<V> val) {
    return AutoFill.<K,V>hashMapToHashSet();
  }
  public static <K,V> Map<K,Set<V>> hashMapToHashSet(Class<K> key, Class<V> val) {
    return AutoFill.<K,V>hashMapToHashSet();
  }
  
  public static <K,V> Map<K,List<V>> hashMapToArrayList() {
    return new HashMap<K,List<V>>(CollUtils.<V>arrayListCreator());
  }
  public static <K,V> Map<K,List<V>> hashMapToArrayList(Marker<K> key, Marker<V> val) {
    return AutoFill.<K,V>hashMapToArrayList();
  }
  public static <K,V> Map<K, List<V>> hashMapToArrayList(Marker<K> key, Class<V> val) {
    return AutoFill.<K,V>hashMapToArrayList();
  }
  public static <K,V> Map<K, List<V>> hashMapToArrayList(Class<K> key, Marker<V> val) {
    return AutoFill.<K,V>hashMapToArrayList();
  }
  public static <K,V> Map<K, List<V>> hashMapToArrayList(Class<K> key, Class<V> val) {
    return AutoFill.<K,V>hashMapToArrayList();
  }
  
  
  
  private static <K, V> V createIfNecessary(Object key, V val, UnaryFunc<? super K, ? extends V> creator, Map<K, V> map) {
    if (val == null) {
      @SuppressWarnings("unchecked")
      K realKey = (K)key;
      val = creator.call(realKey);
      map.put(realKey, val);
    }
    return val;
  }
  
  private static <K, V> UnaryFunc<K, V> valCreator(final NullaryFunc<? extends V> valCreator) {
    return new UnaryFunc<K, V>() {
      @Override
      public V call(K val) {
        return valCreator.call();
      }
    };
  }
  
  private static <K, V> UnaryFunc<K, V> valCreator(final Class<? extends V> valClass) {
    return new UnaryFunc<K, V>() {
      @Override
      public V call(K val) {
        try {
          return valClass.newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
          throw new RuntimeException("Error creating value", e);
        }
      }
    };
  }
  
  public static class HashMap<K,V> extends java.util.HashMap<K, V> {
    private static final long serialVersionUID = 2878549073668469508L;
    protected final UnaryFunc<? super K, ? extends V> valCreator;

    public HashMap(UnaryFunc<? super K, ? extends V> valCreator) {
    	super();
      this.valCreator = valCreator;
    }
    public HashMap(NullaryFunc<? extends V> valCreator) {
      this(valCreator(valCreator));
    }
    public HashMap(Class<? extends V> valClass) {
      this(valCreator(valClass));
    }
    
    public HashMap(int initialCapacity, UnaryFunc<? super K, ? extends V> valCreator) {
      super(initialCapacity);
      this.valCreator = valCreator;
    }
    public HashMap(int initialCapacity, NullaryFunc<? extends V> valCreator) {
      this(initialCapacity, valCreator(valCreator));
    }
    public HashMap(int initialCapacity, Class<? extends V> valClass) {
      this(initialCapacity, valCreator(valClass));
    }
    
    public HashMap(int initialCapacity, float loadFactor, UnaryFunc<? super K, ? extends V> valCreator) {
      super(initialCapacity, loadFactor);
      this.valCreator = valCreator;
    }
    public HashMap(int initialCapacity, float loadFactor, NullaryFunc<? extends V> valCreator) {
      this(initialCapacity, loadFactor, valCreator(valCreator));
    }
    public HashMap(int initialCapacity, float loadFactor, Class<? extends V> valClass) {
      this(initialCapacity, loadFactor, valCreator(valClass));
    }
    
    public HashMap(Map<? extends K, ? extends V> m, UnaryFunc<? super K, ? extends V> valCreator) {
      super(m);
      this.valCreator = valCreator;
    }
    public HashMap(Map<? extends K, ? extends V> m, NullaryFunc<? extends V> valCreator) {
      this(m, valCreator(valCreator));
    }
    public HashMap(Map<? extends K, ? extends V> m, Class<? extends V> valClass) {
      this(m, valCreator(valClass));
    }
    

    @Override
    public V get(Object key) {
      return createIfNecessary(key, super.get(key), valCreator, this);
    }
  }

  /** A HashMap<K,Integer> that auto-generates dense serial numbers for new objects 0,1,2,...   
   * NB: clear() does not reset the numbering.  Not threadsafe.
   */
  public static class HashMap2SerialNumber<K> extends com.hpl.erk.AutoFill.HashMap<K, Integer> {
	  
	private static final long	serialVersionUID	= 766444091908050267L;
	
	public HashMap2SerialNumber() {
		this(16, 0.75f, 0);
	}
	public HashMap2SerialNumber(int initialCapacity, float loadFactor, final int initialSerialNumber) {
		super(initialCapacity, loadFactor, new NullaryFunc<Integer>() {
			int next = initialSerialNumber;
			@Override
			public Integer call() {
				return next++;
			}
		});
	}
  }

  
  public static class IdentityHashMap<K,V> extends java.util.IdentityHashMap<K, V> {
    private static final long serialVersionUID = -2449775181145230485L;
    protected final UnaryFunc<? super K, ? extends V> valCreator;

    public IdentityHashMap(UnaryFunc<? super K, ? extends V> valCreator) {
      this.valCreator = valCreator;
    }
    public IdentityHashMap(NullaryFunc<? extends V> valCreator) {
      this(valCreator(valCreator));
    }
    public IdentityHashMap(Class<? extends V> valClass) {
      this(valCreator(valClass));
    }
    
    public IdentityHashMap(int initialCapacity, UnaryFunc<? super K, ? extends V> valCreator) {
      super(initialCapacity);
      this.valCreator = valCreator;
    }
    public IdentityHashMap(int initialCapacity, NullaryFunc<? extends V> valCreator) {
      this(initialCapacity, valCreator(valCreator));
    }
    public IdentityHashMap(int initialCapacity, Class<? extends V> valClass) {
      this(initialCapacity, valCreator(valClass));
    }
    
    public IdentityHashMap(Map<? extends K, ? extends V> m, UnaryFunc<? super K, ? extends V> valCreator) {
      super(m);
      this.valCreator = valCreator;
    }
    public IdentityHashMap(Map<? extends K, ? extends V> m, NullaryFunc<? extends V> valCreator) {
      this(m, valCreator(valCreator));
    }
    public IdentityHashMap(Map<? extends K, ? extends V> m, Class<? extends V> valClass) {
      this(m, valCreator(valClass));
    }
    

    @Override
    public V get(Object key) {
      return createIfNecessary(key, super.get(key), valCreator, this);
    }
  }
  
  public static class EnumMap<K extends Enum<K>,V> extends java.util.EnumMap<K, V> {
    private static final long serialVersionUID = -86799555505851494L;
    protected final UnaryFunc<? super K, ? extends V> valCreator;

    public EnumMap(Class<K> keyClass, UnaryFunc<? super K, ? extends V> valCreator) {
      super(keyClass);
      this.valCreator = valCreator;
    }
    public EnumMap(Class<K> keyClass, NullaryFunc<? extends V> valCreator) {
      this(keyClass, valCreator(valCreator));
    }
    public EnumMap(Class<K> keyClass, Class<? extends V> valClass) {
      this(keyClass, valCreator(valClass));
    }
    
    public EnumMap(Map<K, ? extends V> m, UnaryFunc<? super K, ? extends V> valCreator) {
      super(m);
      this.valCreator = valCreator;
    }
    public EnumMap(Map<K, ? extends V> m, NullaryFunc<? extends V> valCreator) {
      this(m, valCreator(valCreator));
    }
    public EnumMap(Map<K, ? extends V> m, Class<? extends V> valClass) {
      this(m, valCreator(valClass));
    }
    

    @Override
    public V get(Object key) {
      return createIfNecessary(key, super.get(key), valCreator, this);
    }
  }
  
  public static class Wrapped<K,V> implements Map<K, V> {
    protected final Map<K,V> map;
    protected final UnaryFunc<? super K, ? extends V> valCreator;

    public Wrapped(Map<K, V> m, UnaryFunc<? super K, ? extends V> valCreator) {
      map = m;
      this.valCreator = valCreator;
    }
    public Wrapped(Map<K, V> m, NullaryFunc<? extends V> valCreator) {
      this(m, valCreator(valCreator));
    }
    public Wrapped(Map<K, V> m, Class<? extends V> valClass) {
      this(m, valCreator(valClass));
    }
    

    @Override
    public V get(Object key) {
      return createIfNecessary(key, map.get(key), valCreator, this);
    }
    
    public int size() {
      return map.size();
    }
    public boolean isEmpty() {
      return map.isEmpty();
    }
    public boolean containsKey(Object key) {
      return map.containsKey(key);
    }
    public boolean containsValue(Object value) {
      return map.containsValue(value);
    }
    public V put(K key, V value) {
      return map.put(key, value);
    }
    public V remove(Object key) {
      return map.remove(key);
    }
    public void putAll(Map<? extends K, ? extends V> m) {
      map.putAll(m);
    }
    public void clear() {
      map.clear();
    }
    public Set<K> keySet() {
      return map.keySet();
    }
    public Collection<V> values() {
      return map.values();
    }
    public Set<java.util.Map.Entry<K, V>> entrySet() {
      return map.entrySet();
    }
    public boolean equals(Object o) {
      return map.equals(o);
    }
    public int hashCode() {
      return map.hashCode();
    }
    @Override
    public String toString() {
      return map.toString();
    }
  }
  
  
  

}
