/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import com.hpl.erk.func.Functions;
import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.impl_helper.CompareToImpl;
import com.hpl.erk.util.Strings;

/**
 * Provides a nicely formatted two-column list.  Rows in the list are added by calling {@link #add(K, Collection)}.  
 * Terms on the left-hand side are formatted by the {@link UnaryFunc} registered
 * by calling {@link #fmtKey(UnaryFunc)} (or {@link #toString()}).  The width of the right-hand column is determined by subtracting
 * the widest term and the separator (as specified with {@link #sep(String)}, defaulting to " : ") from the overall width, specified by {@link #width(int)}
 * (default = 80).  The items in the right-hand side are wrapped in the space by calling {@link Strings#wrap(Object, int)}.  {@link SelfWrapping} 
 * objects that draw lines across the space are aquired by calling {@link #bar(String)}.  Bars between items are specified with {@link #itemSep(String)},
 * while bars above and below the glossary are specified with {@link #topLine(String)} and {@link #bottomLine(String)}.  {@link #borders(String)}
 * sets both top and bottom lines.
 * <p/>
 * Once all rows have been added, call {@link #format()} to obtain the formatted list as a {@link String}.
 * <p/>
 * The {@link #Glossary()} is configured by calling functions which return the glossary, so they can be chained.  In addition to the ones specified
 * above, {@link #sortKeys(Comparator)} is used to specify a comparator to use to sort the keys and {@link #sortTerms(Comparator)} is used to
 * specify a comparator to sort the terms extracted from the keys.  The sort order is: by keys (if key comparator specified), then by terms 
 * (if term comparator specified), then by order added.  Functions {@link #sortTermsCI()} and {@link #sortTermsCS()} can be used to request
 * (respectively) case-insensitive and case-sensitive term sorting.
 * <p/>
 * Static functions can be used to create the {@link Glossary}.  {@link #withKey(Class)} creates a Glossary with a given key class.  {@link #withSortedKey()} 
 * and {@link #withSortedKey(Class)} create a Glossary sorted by the keys' natural order. {@link #withStringKey()} creates a Glossary with string
 * keys, and {@link #withCiSortedStringKey()} and {@link #withCsSortedStringKey()} create String-key glossaries sorted case-insensitively and
 * case-sensitively, respectively.
 * @param <K> the type of the key.
 */
public class Glossary<K> {
  private List<Row> rows = new ArrayList<>();
  private String sep = " : ";
  private int width = 80;
  private boolean sorted = true;
  private SelfWrapping itemSep = null;
  private SelfWrapping topLine = null;
  private SelfWrapping bottomLine = null;
  private Comparator<? super String> termCptr = null;
  private Comparator<? super K> keyCptr = null;
  private UnaryFunc<K, String> keyFormatter = null;
  
  private class Row implements Comparable<Row> {
    private final int order = rows.size();
    private final String term;
    private final K key;
    private final Collection<?> defLines;
    protected Row(K key, Collection<?> defLines) {
      this.key = key;
      this.term = keyFormatter == null ? key.toString() : keyFormatter.call(key);
      this.defLines = defLines;
    }
    @Override
    public int compareTo(Row o) {
      return CompareToImpl.notNull(this, o)
          .compareIf(keyCptr != null, key, o.key, keyCptr)
          .compareIf(termCptr != null, term, o.term, termCptr)
          .compare(order, o.order)
          .value();
    }
    @Override
    public String toString() {
      return String.format("%s -> %s", term, defLines);
    }
  }
  
  /**
   * Add a row to the {@link Glossary}.
   * @param key row key
   * @param defLines row definition
   */
  public void add(K key, Collection<?> defLines) {
    rows.add(new Row(key, defLines));
  }
  
  /**
   * @param sep the separator to use between columns.
   * @return this {@link Glossary}
   */
  public Glossary<K> sep(String sep) {
    this.sep = sep;
    return this;
  }

  /**
   * 
   * @param width the overall line width
   * @return this {@link Glossary}
   */
  public Glossary<K> width(int width) {
    this.width = width;
    return this;
  }
  
  /**
   * 
   * @param formatter a {@link UnaryFunc} to use to convert the key into a LHS term
   * @return this {@link Glossary}
   */
  public Glossary<K> fmtKey(UnaryFunc<K, String> formatter) {
    this.keyFormatter = formatter;
    return this;
  }
  
  /**
   * 
   * @param cptr a {@link Comparator} to use to sort keys
   * @return this {@link Glossary}
   */
  public Glossary<K> sortKeys(Comparator<? super K> cptr) {
    this.keyCptr = cptr;
    return this;
  }
  /**
   * 
   * @param cptr a {@link Comparator} to use to sort LHS terms
   * @return this {@link Glossary}
   */
  public Glossary<K> sortTerms(Comparator<? super String> cptr) {
    this.termCptr = cptr;
    return this;
  }
  
  /**
   * Sort terms as case-sensitive strings
   * @return this {@link Glossary}
   */
  public Glossary<K> sortTermsCS() {
    sortTerms(Strings.caseSensitive());
    return this;
  }
  /**
   * Sort terms as case-insensitive strings
   * @return this {@link Glossary}
   */
  public Glossary<K> sortTermsCI() {
    sortTerms(Strings.caseInsensitive());
    return this;
  }
  
  /**
   * Specify a bar to use between rows
   * @param s a string to repeat to form the bar
   * @return this {@link Glossary}
   */
  public Glossary<K> itemSep(String s) {
    this.itemSep = bar(s);
    return this;
  }
  /**
   * Specify a bar to use at the top
   * @param s a string to repeat to form the bar
   * @return this {@link Glossary}
   */
  public Glossary<K> topLine(String s) {
    this.topLine = bar(s);
    return this;
  }
  /**
   * Specify a bar to use at the bottom
   * @param s a string to repeat to form the bar
   * @return this {@link Glossary}
   */
  public Glossary<K> bottomLine(String s) {
    this.bottomLine = bar(s);
    return this;
  }
  /**
   * Specify a bar to use at the top and bottom
   * @param s a string to repeat to form the bar
   * @return this {@link Glossary}
   */
  public Glossary<K> borders(String s) {
    topLine(s);
    bottomLine = topLine;
    return this;
  }
  
  /**
   * Format the contents of the added rows
   * @return a formatted string
   */
  public String format() {
    StringBuilder bldr = new StringBuilder();
    if (sorted) {
      Collections.sort(rows);
    }
    int leftWidth = 0;
    for (Row row : rows) {
      int w = row.term.length();
      if (w > leftWidth) {
        leftWidth = w;
      }
    }
    int rightWidth = width-leftWidth-sep.length();
    String leftFmt = String.format("%%%ds", leftWidth);
    if (topLine != null) {
      bldr.append(topLine.toWrappedString(width));
    }
    boolean firstItem = true;
    for (Row row : rows) {
      if (bldr.length() > 0) {
        bldr.append("\n");
      }
      if (itemSep != null) {
        if (!firstItem) {
          bldr.append(itemSep.toWrappedString(width));
          bldr.append("\n");
        }
      }
      bldr.append(String.format(leftFmt, row.term));
      bldr.append(sep);
      boolean firstLine = true;
      for (Object line : row.defLines) {
        if (line == null) {
          continue;
        }
        if (!firstLine) {
          bldr.append("\n");
        }
        String right = Strings.wrap(line, rightWidth);
        right = Strings.indentLines(right, width-rightWidth, !firstLine);
        firstLine = false;
        bldr.append(right);
      }
      firstItem = false;
    }
    if (bottomLine != null) {
      if (bldr.length() > 0) {
        bldr.append("\n");
      }
      bldr.append(bottomLine.toWrappedString(width));
    }
    return bldr.toString();
  }
  
  /**
   * 
   * @param s a string to repeat
   * @return a {@link SelfWrapping} object that repeats the string as necessary.
   */
  public static SelfWrapping bar(final String s) {
    return new SelfWrapping() {
      @Override
      public String toWrappedString(int width) {
        int n = width/s.length();
        final String val = Strings.rep(s, n);
        final int len = val.length();
        if (len == width) {
          return val;
        }
        return val+s.substring(width-len);
      }
      @Override
      public String toString() {
        return s+"...";
      }
    };
  }
  
  /**
   * 
   * @return a {@link Glossary} with {@link String} keys
   */
  public static Glossary<String> withStringKey() {
    return new Glossary<>();
  }
  /**
   * 
   * @return a {@link Glossary} with {@link String} keys, sorted case-insensitive
   */
  public static Glossary<String> withCiSortedStringKey() {
    return withStringKey().sortKeys(Strings.caseInsensitive());
  }
  /**
   * 
   * @return a {@link Glossary} with {@link String} keys, sorted case-sensitive
   */
  public static Glossary<String> withCsSortedStringKey() {
    return withStringKey().sortKeys(Strings.caseSensitive());
  }
  
  /**
   * 
   * @param clss the key class
   * @return a {@link Glossary} with the given key class.
   */
  public static <K> Glossary<K> withKey(Class<K> clss) {
    return new Glossary<>();
  }
  
  /**
   * 
   * @param clss the key class
   * @return a {@link Glossary} with the given key class, sorted by the keys' natural order.
   */
  public static <K extends Comparable<? super K>> Glossary<K> withSortedKey(Class<K> clss) {
    return withSortedKey(clss);
  }


  /**
   * 
   * @param clss the key class
   * @return a {@link Glossary} with the given key class, sorted by the keys' natural order.
   */
  public static <K> Glossary<K> withSortedKey() {
    return new Glossary<K>().sortKeys(Functions.<K>naturalOrder());
  }
  
}
