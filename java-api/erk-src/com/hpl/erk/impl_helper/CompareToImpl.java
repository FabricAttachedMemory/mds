/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.impl_helper;

import java.util.Comparator;

import com.hpl.erk.func.NullaryFunc;
import com.hpl.erk.func.UnaryFuncToDouble;
import com.hpl.erk.func.UnaryFuncToInt;
import com.hpl.erk.func.UnaryFuncToLong;
import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.lazy.LazyDouble;
import com.hpl.erk.lazy.LazyInt;
import com.hpl.erk.lazy.LazyLong;
import com.hpl.erk.util.Strings;

public class CompareToImpl<T> {
  private boolean done;
  private int val = 0;
  private final T self;
  private final T other;
  
  private CompareToImpl(T self, T other, boolean nullsFirst) {
    this(self, other);
    if (!done) {
      if (self == null) {
        setVal(nullsFirst ? -1 : 1);
      } else if (other == null) {
        setVal(nullsFirst ? 1 : -1);
      }
    }
  }
  
  
  private CompareToImpl(T self, T other) {
    this.self = self;
    this.other = other;
    done = self == other;
  }


  public static <T> CompareToImpl<T> start(T self, T other, boolean nullsFirst) {
    return new CompareToImpl<T>(self, other, nullsFirst);
  }
  public static <T> CompareToImpl<T> nullsFirst(T self, T other) {
    return start(self, other, true);
  }
  public static <T> CompareToImpl<T> nullsLast(T self, T other) {
    return start(self, other, false);
  }
  public static <T> CompareToImpl<T> notNull(T self, T other) {
    return new CompareToImpl<T>(self, other);
  }
  public static <T> T forEquals(Object obj, Class<T> clss) {
    if (obj == null || !clss.isInstance(obj)) {
      return null;
    }
    @SuppressWarnings("unchecked")
    final T other = (T)obj;
    return other;
  }
  
  private void setVal(int v) {
    val = v;
    done = v != 0;
  }
  
  private boolean checkGuard(boolean guard) {
    return guard && !done;
  }
  
  public int value() {
    return val;
  }
  public int uniqueValue() {
    if (done) {
      return val;
    }
    return Integer.compare(System.identityHashCode(self), System.identityHashCode(other));
  }
  public boolean isEqual() {
    return val == 0;
  }
  
  public boolean isDone() {
    return done;
  }
  
  public CompareToImpl<T> reverse() {
    val = -val;
    return this;
  }
  
  public <X> CompareToImpl<T> compare(X a, X b, Comparator<? super X> cptr) {
    return compareIf(true, a, b, cptr);
  }
  public <X> CompareToImpl<T> compareIf(boolean guard, X a, X b, Comparator<? super X> cptr) {
    if (!checkGuard(guard)) { return this; }
    setVal(cptr.compare(a, b));
    return this;
  }
  
  public <X extends Comparable<? super X>> CompareToImpl<T> compare(X a, X b) {
    return compareIf(true, a, b);
  }
  public <X extends Comparable<? super X>> CompareToImpl<T> compareIf(boolean guard, X a, X b) {
    if (!checkGuard(guard)) { return this; }
    if (a != b) {
      if (a == null) {
        setVal(-b.compareTo(a));
      } else {
        setVal(a.compareTo(b));
      }
    }
    return this;
  }
  
  public <X> CompareToImpl<T> compare(NullaryFunc<? extends X> aCtr, NullaryFunc<? extends X> bCtr, Comparator<? super X> cptr) {
    return compareIf(true, aCtr, bCtr, cptr);
  }
  public <X> CompareToImpl<T> compareIf(boolean guard, NullaryFunc<? extends X> aCtr, NullaryFunc<? extends X> bCtr, Comparator<? super X> cptr) {
    if (!checkGuard(guard)) { return this; }
    return compare(aCtr.call(), bCtr.call(), cptr);
  }
  
  public <X extends Comparable<? super X>> CompareToImpl<T> compare(NullaryFunc<? extends X> aCtr, NullaryFunc<? extends X> bCtr) {
    return compareIf(true, aCtr, bCtr);
  }
  public <X extends Comparable<? super X>> CompareToImpl<T> compareIf(boolean guard, NullaryFunc<? extends X> aCtr, NullaryFunc<? extends X> bCtr) {
    if (!checkGuard(guard)) { return this; }
    return compare(aCtr.call(), bCtr.call());
  }

  public <Y, X> CompareToImpl<T> compare(Y a, Y b, UnaryFunc<Y,X> xformer, Comparator<? super X> cptr) {
    return compareIf(true, a, b, xformer, cptr);
  }
  public <Y,X> CompareToImpl<T> compareIf(boolean guard, Y a, Y b, UnaryFunc<Y,X> xformer, Comparator<? super X> cptr) {
    if (!checkGuard(guard)) { return this; }
    setVal(cptr.compare(xformer.call(a), xformer.call(b)));
    return this;
  }
  
  public <Y, X extends Comparable<? super X>> CompareToImpl<T> compare(Y a, Y b, UnaryFunc<Y,X> xformer) {
    return compareIf(true, a, b, xformer);
  }
  public <Y, X extends Comparable<? super X>> CompareToImpl<T> compareIf(boolean guard, Y aOrig, Y bOrig, UnaryFunc<Y,X> xformer) {
    if (!checkGuard(guard)) { return this; }
    X a = xformer.call(aOrig);
    X b = xformer.call(bOrig);
    if (a != b) {
      if (a == null) {
        setVal(-b.compareTo(a));
      } else {
        setVal(a.compareTo(b));
      }
    }
    return this;
  }
  
  public <Y> CompareToImpl<T> compare(Y a, Y b, UnaryFuncToInt<Y> xformer) {
    return compareIf(true, a, b, xformer);
  }
  public <Y> CompareToImpl<T> compareIf(boolean guard, Y a, Y b, UnaryFuncToInt<Y> xformer) {
    if (!checkGuard(guard)) { return this; }
    setVal(Integer.compare(xformer.primCall(a), xformer.primCall(b)));
    return this;
  }
  public <Y> CompareToImpl<T> compare(Y a, Y b, UnaryFuncToLong<Y> xformer) {
    return compareIf(true, a, b, xformer);
  }
  public <Y> CompareToImpl<T> compareIf(boolean guard, Y a, Y b, UnaryFuncToLong<Y> xformer) {
    if (!checkGuard(guard)) { return this; }
    setVal(Long.compare(xformer.primCall(a), xformer.primCall(b)));
    return this;
  }
  public <Y> CompareToImpl<T> compare(Y a, Y b, UnaryFuncToDouble<Y> xformer) {
    return compareIf(true, a, b, xformer);
  }
  public <Y> CompareToImpl<T> compareIf(boolean guard, Y a, Y b, UnaryFuncToDouble<Y> xformer) {
    if (!checkGuard(guard)) { return this; }
    setVal(Double.compare(xformer.primCall(a), xformer.primCall(b)));
    return this;
  }
  
  
  public <X> CompareToImpl<T> compareUsing(UnaryFunc<? super T, ? extends X> xform, Comparator<? super X> cptr) {
    return compareUsingIf(true, xform, cptr);
  }
  public <X> CompareToImpl<T> compareUsingIf(boolean guard, UnaryFunc<? super T, ? extends X> xform, Comparator<? super X> cptr) {
    if (!checkGuard(guard)) { return this; }
    return compare(xform.call(self), xform.call(other), cptr);
  }

  public <X extends Comparable<? super X>> CompareToImpl<T> compareUsing(UnaryFunc<? super T, ? extends X> xform) {
    return compareUsingIf(true, xform);
  }
  public <X extends Comparable<? super X>> CompareToImpl<T> compareUsingIf(boolean guard, UnaryFunc<? super T, ? extends X> xform) {
    if (!checkGuard(guard)) { return this; }
    return compare(xform.call(self), xform.call(other));
  }
  
  public CompareToImpl<T> compare(int a, int b) {
    return compareIf(true, a, b);
  }
  public CompareToImpl<T> compareIf(boolean guard, int a, int b) {
    if (!checkGuard(guard)) { return this; }
    setVal(Integer.compare(a, b));
    return this;
  }
  
  public CompareToImpl<T> compare(LazyInt a, LazyInt b) {
    return compareIf(true, a, b);
  }
  public CompareToImpl<T> compareIf(boolean guard, LazyInt a, LazyInt b) {
    if (!checkGuard(guard)) { return this; }
    setVal(Integer.compare(a.value(), b.value()));
    return this;
  }
  
  public CompareToImpl<T> compare(long a, long b) {
    return compareIf(true, a, b);
  }
  public CompareToImpl<T> compareIf(boolean guard, long a, long b) {
    if (!checkGuard(guard)) { return this; }
    setVal(Long.compare(a, b));
    return this;
  }

  public CompareToImpl<T> compare(LazyLong a, LazyLong b) {
    return compareIf(true, a, b);
  }
  public CompareToImpl<T> compareIf(boolean guard, LazyLong a, LazyLong b) {
    if (!checkGuard(guard)) { return this; }
    setVal(Long.compare(a.value(), b.value()));
    return this;
  }
  
  public CompareToImpl<T> compare(double a, double b) {
    return compareIf(true, a, b);
  }
  public CompareToImpl<T> compareIf(boolean guard, double a, double b) {
    if (!checkGuard(guard)) { return this; }
    setVal(Double.compare(a, b));
    return this;
  }
  
  public CompareToImpl<T> compare(LazyDouble a, LazyDouble b) {
    return compareIf(true, a, b);
  }
  public CompareToImpl<T> compareIf(boolean guard, LazyDouble a, LazyDouble b) {
    if (!checkGuard(guard)) { return this; }
    setVal(Double.compare(a.value(), b.value()));
    return this;
  }

  public CompareToImpl<T> compare(boolean a, boolean b, boolean trueFirst) {
    return compareIf(true, a, b, trueFirst);
  }
  public CompareToImpl<T> compareIf(boolean guard, boolean a, boolean b, boolean trueFirst) {
    if (!checkGuard(guard)) { return this; }
    if (a != b) {
      setVal((a == trueFirst) ? -1 : 1); 
    }
    return this;
  }
  
  public CompareToImpl<T> trueFirst(boolean a, boolean b) {
    return trueFirstIf(true, a, b);
  }
  public CompareToImpl<T> trueFirstIf(boolean guard, boolean a, boolean b) {
    return compareIf(guard, a, b, true);
  }
  
  public CompareToImpl<T> falseFirst(boolean a, boolean b) {
    return falseFirstIf(true, a, b);
  }
  public CompareToImpl<T> falseFirstIf(boolean guard, boolean a, boolean b) {
    return compareIf(guard, a, b, false);
  }
  
  public CompareToImpl<T> compare(NullaryFunc<Boolean> aCtr, NullaryFunc<Boolean> bCtr, boolean trueFirst) {
    return compareIf(true, aCtr, bCtr, trueFirst);
  }
  public CompareToImpl<T> compareIf(boolean guard, NullaryFunc<Boolean> aCtr, NullaryFunc<Boolean> bCtr, boolean trueFirst) {
    if (!checkGuard(guard)) { return this; }
    return compare(aCtr.call(), bCtr.call(), trueFirst);
  }
  
  public CompareToImpl<T> trueFirst(NullaryFunc<Boolean> aCtr, NullaryFunc<Boolean> bCtr) {
    return trueFirstIf(true, aCtr, bCtr);
  }
  public CompareToImpl<T> trueFirstIf(boolean guard, NullaryFunc<Boolean> aCtr, NullaryFunc<Boolean> bCtr) {
    return compareIf(true, aCtr, bCtr, true);
  }
  
  public CompareToImpl<T> falseFirst(NullaryFunc<Boolean> aCtr, NullaryFunc<Boolean> bCtr) {
    return falseFirstIf(true, aCtr, bCtr);
  }
  public CompareToImpl<T> falseFirstIf(boolean guard, NullaryFunc<Boolean> aCtr, NullaryFunc<Boolean> bCtr) {
    return compareIf(guard, aCtr, bCtr, false);
  }
  
  public CompareToImpl<T> caseSensitive(String a, String b) {
    return caseSensitiveIf(true, a, b);
  }
  public CompareToImpl<T> caseSensitiveIf(boolean guard, String a, String b) {
    return compareIf(guard, a, b, Strings.caseSensitive());
  }
  
  public CompareToImpl<T> caseInsensitive(String a, String b) {
    return caseInsensitiveIf(true, a, b);
  }
  public CompareToImpl<T> caseInsensitiveIf(boolean guard, String a, String b) {
    return compareIf(guard, a, b, Strings.caseInsensitive());
  }
  
  public CompareToImpl<T> caseSensitive(NullaryFunc<? extends String> aCtr, NullaryFunc<? extends String> bCtr) {
    return caseSensitiveIf(true, aCtr, bCtr);
  }
  public CompareToImpl<T> caseSensitiveIf(boolean guard, NullaryFunc<? extends String> aCtr, NullaryFunc<? extends String> bCtr) {
    if (!checkGuard(guard)) { return this; }
    return caseSensitive(aCtr.call(), bCtr.call());
  }

  public CompareToImpl<T> caseInsensitive(NullaryFunc<? extends String> aCtr, NullaryFunc<? extends String> bCtr) {
    return caseInsensitiveIf(true, aCtr, bCtr);
  }
  public CompareToImpl<T> caseInsensitiveIf(boolean guard, NullaryFunc<? extends String> aCtr, NullaryFunc<? extends String> bCtr) {
    if (!checkGuard(guard)) { return this; }
    return caseInsensitive(aCtr.call(), bCtr.call());
  }
  
  public CompareToImpl<T> compareUsing(Comparator<? super T> cptr) {
    return compareUsingIf(true, cptr);
  }
  public CompareToImpl<T> compareUsingIf(boolean guard, Comparator<? super T> cptr) {
    if (!checkGuard(guard)) { return this; }
    setVal(cptr.compare(self, other));
    return this;
  }
  
  
  public CompareToImpl<T> compareHashCodes() {
    return compare(self.hashCode(), other.hashCode());
  }
}
