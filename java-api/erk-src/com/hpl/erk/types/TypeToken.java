/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.types;

import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.WildcardType;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import com.hpl.erk.types.templates.PTypeTempl;

public abstract class TypeToken implements TypeDeclToken, TypeBound {
  private static final Map<TypeToken, TypeToken> known = new HashMap<>();
  static final TypeToken OBJECT = find(Object.class);
  
  protected TypeToken[] parents = null;
  protected TypeToken[] ancestors = null;
  
  public abstract boolean isAssignableFrom(TypeToken other);
  public abstract String getName(boolean fullp);
  public abstract Class<?> rawClass();
  public abstract TypeToken elementType();
  public abstract boolean isArray();
  public abstract boolean isParameterized();
  public abstract boolean equalSatisfyingParams(TypeToken token);
  public abstract TypeToken[] computeParents();
  public abstract TypeToken[] computeAncestors();

  @Override
  public boolean satisfiedBy(TypeBound bound) {
    if (bound == this) {
      return true;
    }
    if (!(bound instanceof TypeToken)) {
      return false;
    }
    TypeToken other = (TypeToken)bound;
    return equalSatisfyingParams(other);
  }
  
  @Override
  public Collection<TypeToken> uppers() {
    return Collections.singleton(this);
  }

  @Override
  public Collection<TypeToken> lowers() {
    return Collections.singleton(this);
  }

  public static GenericTypeToken generic(Class<?> raw) {
    return GenericTypeToken.find(raw);
  }
  
  public static TypeToken find(Class<?> base) {
    if (base.isArray() ) {
      return findArray(base.getComponentType());
    }
    if (base.getTypeParameters().length > 0) {
      return generic(base).raw();
    }
    TypeToken token = new SimpleTypeToken(base);
    return checkCache(token);
  }
  
  public static TypeToken find(GenericTypeToken generic, TypeBound...args) {
    return generic.bind(args);
  }
  
  public static TypeToken find(Class<?> base, TypeBound...args) {
    if (base.isArray()) {
      return findArray(base.getComponentType(), args);
    }
    return GenericTypeToken.find(base).bind(args);
  }
  static TypeToken findUnchecked(Class<?> base, TypeBound...args) {
    if (base.isArray()) {
      return findArray(base.getComponentType(), args);
    }
    return GenericTypeToken.find(base).bindUnchecked(args);
  }
  private static TypeToken checkCache(TypeToken token) {
    TypeToken old = known.get(token);
    if (old != null) {
      return old;
    }
    known.put(token, token);
    return token;
  }
  
  public static TypeToken findArray(Class<?> cptBase) {
    return findArray(find(cptBase));
  }
  
  public static TypeToken findArray(Class<?> cptBase, TypeBound...args) {
    return findArray(find(cptBase, args));
  }
  public static TypeToken findArray(TypeToken cptToken) {
    TypeToken token = new ArrayTypeToken(cptToken);
    return checkCache(token);
  }
  
  public static TypeBound below(TypeToken... uppers) {
    return TypeRange.between(TypeRange.NO_BOUND, uppers);
  }
  
  public static TypeBound above(TypeToken... lowers) {
    return TypeRange.between(lowers, TypeRange.NO_BOUND);
  }
  
  public static TypeBound between(TypeToken lower, TypeToken...uppers) {
    return TypeRange.between(new TypeBound[] {lower}, uppers);
  }
  
  public static TypeBound between(TypeToken[] lowers, TypeToken...uppers) {
    return TypeRange.between(lowers, uppers);
  }
  
  public static TypeBound any() {
    return TypeRange.WILDCARD;
  }
  
  public TypeBound asBound(Type type) {
    if (type instanceof WildcardType) {
      WildcardType wct = (WildcardType)type;
      TypeBound[] uppers = toBounds(wct.getUpperBounds());
      TypeBound[] lowers = toBounds(wct.getLowerBounds());
      return TypeRange.between(lowers, uppers);
    }
    return asToken(type);
  }
  
  public TypeToken asToken(Type type) {
    if (type instanceof Class) {
      return find((Class<?>)type);
    }
    if (type instanceof ParameterizedType) {
      ParameterizedType ptype = (ParameterizedType)type;
      Class<?> tRaw = (Class<?>)ptype.getRawType();
      Type[] params = ptype.getActualTypeArguments();
      final int n = params.length;
      TypeBound[] array = new TypeBound[n];
      for (int i=0; i<n; i++) {
        array[i] = asBound(params[i]);
      }
      return findUnchecked(tRaw, array);
    }
    if (type instanceof GenericArrayType) {
      GenericArrayType gat = (GenericArrayType)type;
      return findArray(asToken(gat.getGenericComponentType()));
    }
    throw new IllegalArgumentException(String.format("%s can't interpret %s", this, type));
  }
  
  TypeBound[] toBounds(Type[] types) {
    final int n = types.length;
    TypeBound[] array = new TypeBound[n];
    for (int i=0; i<n; i++) {
      final TypeBound bound = asBound(types[i]);
      array[i] = bound;
    }
    return array;
  }
  @Override
  public String toString() {
    return getName(false);
  }
  
  public TypeToken[] parents() {
    if (parents == null) {
      parents = computeParents();
    }
    return parents;
  }
  
  public TypeToken[] ancestors() {
    if (ancestors == null) {
      ancestors = computeAncestors();
    }
    return ancestors;
  }

  @Override
  public void inferBounds(TypeBound token, TypeBound[] bounds) {
    // no vars, so nothing to do
  }
  
  public void inferBoundsWhenMatching(PTypeTempl ptt, TypeBound[] bounds) {
    throw new IllegalArgumentException(String.format("Can't match %s with %s", ptt, this));
  }
  
}
