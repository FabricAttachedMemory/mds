/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.types.templates;

import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Arrays;

import com.hpl.erk.types.GenericTypeToken;
import com.hpl.erk.types.TypeBound;
import com.hpl.erk.types.TypeRange;
import com.hpl.erk.types.TypeToken;

public class Templates {
  public static TypeTemplate from(Type type, TypeVariable<?>[] vars, TypeTemplate[] vals) {
    if (type instanceof Class) {
      return from((Class<?>)type);
    }
    if (type instanceof GenericArrayType) {
      return from((GenericArrayType)type, vars, vals);
    }
    if (type instanceof TypeVariable<?>) {
      return from((TypeVariable<?>)type, vars, vals);
    }
    if (type instanceof ParameterizedType) {
      return from((ParameterizedType)type, vars, vals);
    }
    if (type instanceof WildcardType) {
      return from((WildcardType)type, vars, vals);
    }
    throw new IllegalStateException();
  }

  public static TypeTemplate from(Class<?> c) {
    return TypeToken.find(c);
  }
  
  public static TypeTemplate from(Class<?> c, TypeVariable<?>[] vars, TypeTemplate[] vals) {
    return from(c);
    
  }
  public static TypeTemplate from(WildcardType t, TypeVariable<?>[] vars, TypeTemplate[] vals) {
    TypeTemplate[] upperBounds = fromArray(t.getUpperBounds(), vars, vals);
    TypeTemplate[] lowerBounds = fromArray(t.getLowerBounds(), vars, vals);
    TypeBound[] ub = asBoundsArray(upperBounds);
    if (ub != null) {
      TypeBound[] lb = asBoundsArray(lowerBounds);
      if (lb != null) {
        return TypeRange.between(lb, ub);
      }
    }
    return new TemplateRange(lowerBounds, upperBounds);
  }
  public static TypeTemplate from(TypeVariable<?> v, TypeVariable<?>[] vars, TypeTemplate[] vals) {
    final int n = vars.length;
    for (int i=0; i<n; i++) {
      if (v == vars[i]) {
        return vals[i];
      }
    }
    throw new IllegalArgumentException(String.format("%s not in %s", v, Arrays.asList(vars)));
    
  }
  public static TypeTemplate from(ParameterizedType t, TypeVariable<?>[] vars, TypeTemplate[] vals) {
    GenericTypeToken generic = TypeToken.generic((Class<?>)t.getRawType());
    TypeTemplate[] params = fromArray(t.getActualTypeArguments(), vars, vals);
    TypeBound[] bounds = asBoundsArray(params);
    if (bounds != null) {
      return generic.bind(bounds);
    }
    return new PTypeTempl(generic, params);
  }

  private static TypeTemplate[] fromArray(final Type[] array,  TypeVariable<?>[] vars, TypeTemplate[] vals) {
    final int n = array.length;
    TypeTemplate[] params = new TypeTemplate[n];
    for (int i=0; i<n; i++) {
      params[i] = from(array[i], vars, vals);
    }
    return params;
  }
  
  private static TypeBound[] asBoundsArray(TypeTemplate[] array) {
    for (TypeTemplate t : array) {
      if (!(t instanceof TypeBound)) {
        return null;
      }
    }
    return Arrays.copyOf(array, array.length, TypeBound[].class);
  }

  public static TypeTemplate from(GenericArrayType t, TypeVariable<?>[] vars, TypeTemplate[] vals) {
    Type ct = t.getGenericComponentType();
    return new ArrayTypeTemplate(from(ct, vars, vals));
  }


}
