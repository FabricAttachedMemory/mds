/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.types;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import com.hpl.erk.formatters.SeqFormatter;
import com.hpl.erk.func.Predicate;
import com.hpl.erk.impl_helper.EqualsImpl;
import com.hpl.erk.impl_helper.HashCode;
import com.hpl.erk.types.templates.PTypeTempl;
import com.hpl.erk.types.templates.TypeTemplate;

public class TypeRange implements TypeBound {
  static final TypeBound[] NO_BOUND = new TypeBound[0];
  static final TypeRange WILDCARD = new TypeRange(Collections.<TypeToken>emptySet(), Collections.<TypeToken>emptySet());
  final Set<TypeToken> lowers;
  final Set<TypeToken> uppers;
  
  private TypeRange(Set<TypeToken> lowers, Set<TypeToken> uppers) {
    this.uppers = uppers;
    this.lowers = lowers;
  }
  
  @Override
  public Collection<TypeToken> uppers() {
    return uppers;
  }
  
  @Override
  public Collection<TypeToken> lowers() {
    return lowers;
  }

  public boolean satisfiedBy(TypeBound bound) {
    return checkUppers(bound.uppers()) && checkLowers(bound.lowers());
  }
  
  private boolean checkUppers(Collection<TypeToken> tighterUppers) {
    OUTER:
      for (TypeToken upper : uppers) {
        for (TypeToken token : tighterUppers) {
          if (upper.isAssignableFrom(token)) {
            continue OUTER;
          }
        }
        return false;
      }
  return true;
  }
  
  private boolean checkLowers(Collection<TypeToken> tighterLowers) {
    OUTER:
      for (TypeToken lower : lowers) {
        for (TypeToken token : tighterLowers) {
          if (token.isAssignableFrom(lower)) {
            continue OUTER;
          }
        }
        return false;
      }
  return true;
  }

  
  public static TypeBound between(TypeBound[] lowers, TypeBound... uppers) {
    Set<TypeToken> uset = new HashSet<>(uppers.length);
    Set<TypeToken> lset = new HashSet<>(lowers.length);
    for (TypeBound l : lowers) {
      for (TypeToken token : l.lowers()) {
        if (token == TypeToken.OBJECT) {
          return token;
        }
        lset.add(token);
      }
    }
    for (TypeBound u : uppers) {
      for (TypeToken token : u.uppers()) {
        if (token != TypeToken.OBJECT) {
          uset.add(token);
        }
      }
    }
    if (lset.equals(uset)) {
      if (lset.isEmpty()) {
        return WILDCARD;
      }
      assert lset.size() == 1;
      return lset.iterator().next();
    }
    return new TypeRange(lset, uset);
  }
  
  @Override
  public boolean equals(Object obj) {
    return EqualsImpl.check(this, obj, TypeRange.class, new Predicate<TypeRange>() {
      @Override
      public boolean test(TypeRange other) {
        return uppers.equals(other.uppers) && lowers.equals(other.lowers);
      }
    });
  }
  
  @Override
  public int hashCode() {
    return HashCode.simple()
        .include(uppers)
        .include(lowers)
        .value();
  }
  
  @Override
  public String toString() {
    String ldesc = lowers.isEmpty() ? "" : " super "+SeqFormatter.withSep(" & ").format(lowers);
    String udesc = uppers.isEmpty() ? "" : " extends "+SeqFormatter.withSep(" & ").format(uppers);
    return "?"+ldesc+udesc;
  }
  
  @Override
  public void fillAncestors(Map<Class<?>, TypeTemplate> map) {
    throw new UnsupportedOperationException(String.format("Type range %s cannot be ancestor", this));
  }
  
  @Override
  public void inferBounds(TypeBound token, TypeBound[] bounds) {
    // no vars, so nothing to do
    
  }

  @Override
  public void inferBoundsWhenMatching(PTypeTempl ptt, TypeBound[] bounds) {
    // TODO Auto-generated method stub
    
  }
  

}
