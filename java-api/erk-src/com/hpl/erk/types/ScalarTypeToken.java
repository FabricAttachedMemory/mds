/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.types;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.TreeSet;

import com.hpl.erk.types.templates.TypeTemplate;

public abstract class ScalarTypeToken extends TypeToken {

  protected List<TypeToken> parents = null;

  public ScalarTypeToken() {
    super();
  }

  @Override
  final public boolean isArray() {
    return false;
  }
  
  @Override
  final public TypeToken elementType() {
    return null;
  }

  protected void addParent(Type parentType, List<TypeToken> list) {
    if (parentType == null) {
      if (this != OBJECT) {
        list.add(OBJECT);
      }
      return;
    }
    TypeToken token = asToken(parentType);
    list.add(token);
  }
  
  @Override
  public TypeToken[] computeParents() {
    List<TypeToken> list = new ArrayList<>();
    Class<?> raw = rawClass();
    addParent(raw.getGenericSuperclass(), list);
    for (Type iface : raw.getGenericInterfaces()) {
      addParent(iface, list);
    }
    return list.toArray(new TypeToken[list.size()]);
  }
  
  @Override
  public void fillAncestors(Map<Class<?>, TypeTemplate> map) {
    final Class<?> r = rawClass();
    if (!map.containsKey(r)) {
      map.put(r, this);
      for (TypeToken a : ancestors()) {
        Class<?> c = a.rawClass();
        map.put(c, a);
      }
    }
    
  }


  public TypeToken[] computeAncestors() {
    TreeSet<TypeToken> tree = new TreeSet<> (new Comparator<TypeToken>(){
        public int compare(TypeToken c1, TypeToken c2) {
          if (c1 == c2) {
            return 0;
          }
          if (c2.isAssignableFrom(c1)) {
            return -1;
          }
          /*
           * we assume that classes are added in order, so they can move to the end
           * unless they have to come sooner.
           */
          return 1;
        }});
    tree.add(this);
    for (TypeToken parent : parents()) {
      tree.addAll(Arrays.asList(parent.ancestors()));
    }
    return tree.toArray(new TypeToken[tree.size()]);
  }

}