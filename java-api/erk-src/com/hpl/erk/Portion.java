/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;

import com.hpl.erk.formatters.SeqFormatter;

/**
 * Represents the size of a sample to be extracted from a larger collection.  The 
 * portion may be specified as either an explicit number of elements or as a fraction
 * of the overall size.  
 */
public abstract class Portion {
  /**
   * Take all of the elements.
   */
  public static final Portion ALL = new FullPortion();
  /**
   * Take none of the elements.
   */
  public static final Portion NONE = new EmptyPortion();
  /**
   * Take a majority of the elements.
   */
  public static final Portion MAJORITY = new MajorityPortion();
  public int n;
  
  /**
   * @param whole the size of the whole
   * @return the number of elements in the portion
   */
  public abstract int of(int whole);
  
  protected double remainderWeight() {
    return 0;
  }
  
  public abstract boolean equals(Object obj);
  public abstract int hashCode();
  
  /**
   * Draw a sample of this size.
   * @param source the collection to draw from
   * @param sample the collection to add the sample to
   */
  public <U, T extends U, Source extends Collection<T>, Sink extends Collection<U>> 
  void extractSample(Source source, Sink sample) {
    int n = of(source.size());
    RandomSample.pick(n, source, sample);
  }
  
  /**
   * Draw a sample of this size.
   * @param source the collection to draw from
   * @return the drawn sample 
   */
  public <T, Source extends Collection<T>> ArrayList<T> of(Source source) {
    int n = of(source.size());
    ArrayList<T> list = new ArrayList<T>(n);
    RandomSample.pick(n, source, list);
    return list;
  }

  /**
   * @param n the number of elements
   * @return a {@link Portion} representing that many elements
   */
  public static ExactNumberPortion exactly(int n) {
    return new ExactNumberPortion(n);
  }
  
  /**
   * @param q a rational number
   * @return a {@link Portion} representing that fraction.
   */
  public static RationalPortion as(Rational q) {
    return new RationalPortion(q);
  }
  /**
   * @param d a real number
   * @return a {@link Portion} representing that fraction.
   */
  public static RealPortion as(double d) {
    return new RealPortion(d);
  }
  /**
   * 
   * @param pct a percentage.
   * @return a {@link Portion} representing that percentage
   */
  public static PercentPortion asPercent(double pct) {
    return new PercentPortion(pct);
  }
  /**
   * @return a portion representing an empty sample.
   */
  public static Portion none() {
    return NONE;
  }
  /**
   * @return a portion representing a complete sample.
   */
  public static Portion all() {
    return ALL;
  }
  /**
   * @return a portion representing a majority.
   */
  public static Portion majority() {
    return MAJORITY;
  }
  
  public static Portion rest(double weight) {
    return remainder(weight);
  }
  
  public static Portion rest() {
    return remainder(1);
  }
  
  public static Portion remainder(double weight) {
    return new RemainderPortion(weight);
  }
  public static Portion remainder() {
    return remainder(1);
  }
  
  
  private static class ExactNumberPortion extends Portion {
    private final int n;
    
    public ExactNumberPortion(int n) {
      this.n = n;
    }

    @Override
    public int of(int whole) {
      return n;
    }
    
    @Override
    public String toString() {
      return String.format("%,d", n);
    }

    @Override
    public boolean equals(Object obj) {
      if (obj == this) {
        return true;
      }
      if (obj == null) {
        return false;
      }
      if (obj instanceof EmptyPortion) {
        return n == 0;
      }
      if (obj instanceof ExactNumberPortion) {
        ExactNumberPortion other = (ExactNumberPortion)obj;
        return n == other.n;
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (n == 0) {
        return NONE.hashCode();
      }
      return ExactNumberPortion.class.hashCode() ^ n;
    }
  }
  
  protected static abstract class ProportionalPortion extends Portion {
    abstract double fraction();
    @Override
    public boolean equals(Object obj) {
      if (obj == this) {
        return true;
      }
      if (obj == null) {
        return false;
      }
      if (obj instanceof EmptyPortion) {
        return fraction() == 0;
      }
      if (obj instanceof ProportionalPortion) {
        ProportionalPortion other = (ProportionalPortion)obj;
        return fraction() == other.fraction();
      }
      return false;
    }
    
    @Override
    public int of(int whole) {
      return (int)(fraction()*whole);
    }

    @Override
    public int hashCode() {
      if (fraction() == 0) {
        return NONE.hashCode();
      }
      return ProportionalPortion.class.hashCode() ^ Double.valueOf(fraction()).hashCode();
    }
  }
  
  private static class RationalPortion extends ProportionalPortion {
    private final Rational q;

    public RationalPortion(Rational q) {
      this.q = q;
    }

    @Override
    public String toString() {
      return q.toString();
    }

    @Override
    double fraction() {
      return q.doubleValue();
    }
  }
  
  private static class RealPortion extends ProportionalPortion {
    private final double d;

    public RealPortion(double d) {
      this.d = d;
    }


    @Override
    public String toString() {
      return String.format("%f", d);
    }

    @Override
    double fraction() {
      return d;
    }
  }

  private static class PercentPortion extends ProportionalPortion {
    private final double pct;

    public PercentPortion(double pct) {
      this.pct = pct;
    }

    @Override
    public String toString() {
      return String.format("%f%%", pct);
    }

    @Override
    double fraction() {
      return pct/100.0;
    }
  }
  
  private static class EmptyPortion extends Portion {
    @Override
    public int of(int whole) {
      return 0;
    }
    
    @Override
    public String toString() {
      return "none";
    }

    @Override
    public boolean equals(Object obj) {
      if (obj == this) {
        return true;
      }
      if (obj == null) {
        return false;
      }
      if (obj instanceof EmptyPortion) {
        return true;
      }
      if (obj instanceof Portion) {
        Portion other = (Portion)obj;
        return other.equals(this);
      }
      return false;
    }

    @Override
    public int hashCode() {
      return EmptyPortion.class.hashCode();
    }
  }
  
  private static class FullPortion extends ProportionalPortion {
    @Override
    public int of(int whole) {
      return whole;
    }
    
    @Override
    public String toString() {
      return "all";
    }

    @Override
    double fraction() {
      return 1;
    }
  }

  private static class MajorityPortion extends Portion {
    @Override
    public int of(int whole) {
      return (whole/2)+1;
    }
    
    @Override
    public String toString() {
      return "majority";
    }

    @Override
    public boolean equals(Object obj) {
      if (obj == this) {
        return true;
      }
      if (obj == null) {
        return false;
      }
      if (obj instanceof MajorityPortion) {
        return true;
      }
      return false;
    }

    @Override
    public int hashCode() {
      return MajorityPortion.class.hashCode();
    }
  }
  
  private static class RemainderPortion extends Portion {
    private final double weight;
    
    public RemainderPortion(double weight) {
      this.weight = weight;
    }
    
    @Override
    public int of(int whole) {
      return whole;
    }
    
    @Override
    public String toString() {
      return "remainder";
    }
    
    @Override
    protected double remainderWeight() {
      return weight;
    }

    @Override
    public boolean equals(Object obj) {
      if (obj == this) {
        return true;
      }
      if (obj == null) {
        return false;
      }
      if (obj instanceof RemainderPortion) {
        RemainderPortion other = (RemainderPortion)obj;
        return weight == other.weight;
      }
      return false;
    }

    @Override
    public int hashCode() {
      return RemainderPortion.class.hashCode() ^ Double.valueOf(weight).hashCode();
    }
    
  }
  
  public static int[] split(int whole, Portion ...portions) {
    final int nPartitions = portions.length;
    final int[] sizes = new int[nPartitions];
    int nClaimed = 0;
    double restWeight = 0;
    for (int i=0; i<nPartitions; i++) {
      Portion p = portions[i];
      double w = p.remainderWeight();
      if (w > 0) {
        restWeight += w;
      } else {
        sizes[i] = p.of(whole);
        nClaimed += sizes[i];
      }
    }
    if (nClaimed > whole) {
      throw new IllegalArgumentException(String.format("Trying to draw %d of %d values", nClaimed, whole));
    }
    if (restWeight > 0 && nClaimed < whole) {
      for (int i=0; i<nPartitions; i++) {
        Portion p = portions[i];
        double w = p.remainderWeight();
        if (w > 0) {
          int n = (int)((w*(whole-nClaimed))/restWeight);
          nClaimed += n;
          sizes[i] = n;
          restWeight -= w;
        }
      }
    }
    return sizes;
  }
  
  public static int[][] partitionIndices(int whole, Portion ...portions) {
    final int nPartitions = portions.length;
    final int[][] samples = new int[nPartitions][];
    final int[] nDrawn = new int[nPartitions];
    final int[] nRemaining = split(whole, portions);
    for (int i=0; i<nPartitions; i++) {
      samples[i] = new int[nRemaining[i]];
    }
    final Random rnd = new Random();
    for (int i=0; i<whole; i++) {
      int k = rnd.nextInt(whole-i);
      for (int j=0; j<nPartitions; j++) {
        final int remaining = nRemaining[j];
        if (k < remaining) {
          samples[j][nDrawn[j]++] = i;
          nRemaining[j]--;
          break;
        } else {
          k -= remaining;
        }
      }
    }
    return samples;
  }
  
  public static <T> List<T>[] partition(Collection<T> coll, Portion ...portions) {
    final int whole = coll.size();
    final int nPartitions = portions.length;
    final List<T>[] samples = (List<T>[])Array.newInstance(List.class, nPartitions);
    final int[] nRemaining = split(whole, portions);
    for (int i=0; i<nPartitions; i++) {
      samples[i] = new ArrayList<>(nRemaining[i]);
    }
    final Random rnd = new Random();
    int eltsLeft = whole;
    for (T elt : coll) {
      int k = rnd.nextInt(eltsLeft--);
      for (int j=0; j<nPartitions; j++) {
        final int remaining = nRemaining[j];
        if (k < remaining) {
          samples[j].add(elt);
          nRemaining[j]--;
          break;
        } else {
          k -= remaining;
        }
      }
    }
    return samples;
  }
  
  public static <T,K> Map<K,List<T>> partition(Collection<T> coll, Map<K, ? extends Portion> map) {
    int n = map.size();
    Portion[] portions = new Portion[n];
    @SuppressWarnings("unchecked")
    K[] keys = (K[])new Object[n];
    {
      int i=0;
      for (Entry<K, ? extends Portion> entry : map.entrySet()) {
        portions[i] = entry.getValue();
        keys[i] = entry.getKey();
        i++;
      }
    }
    List<T>[] partitions = partition(coll, portions);
    Map<K, List<T>> resultMap = new HashMap<K, List<T>>(n);
    for (int i=0; i<n; i++) {
      resultMap.put(keys[i], partitions[i]);
    }
    return resultMap;
  }
  
  public static void main(String[] args) {
    {
      int[][] partition = partitionIndices(200, Portion.exactly(5), Portion.asPercent(25), Portion.as(0.4), Portion.remainder(2), Portion.remainder());
      Glossary<String> g = new Glossary<String>().itemSep("-").bottomLine("=");
      for (int[] sample : partition) {
        SeqFormatter<Integer> fmt = SeqFormatter.commaSpaceSep();
        for (int i : sample) {
          fmt.add(i);
        }
        g.add(String.format("%,d elements", sample.length), Collections.singleton(fmt));
      }
      System.out.format("%s%n", g.format());
    }
    System.out.format("%n");
    {
      String[] strings = { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o" };
      Map<String, Portion> pMap = new HashMap<>();
      pMap.put("Third", Portion.as(new Rational(1, 3)));
      pMap.put("Half", Portion.asPercent(50));
      Map<String, List<String>> rMap = partition(Arrays.asList(strings), pMap);
      Glossary<String> g = Glossary.withCiSortedStringKey().itemSep("-").bottomLine("=");
      for (Entry<String, List<String>> entry : rMap.entrySet()) {
        SeqFormatter<Object> fmt = SeqFormatter.commaSpaceSep().addAll(entry.getValue());
        g.add(entry.getKey(), Collections.singleton(fmt));
      }
      System.out.format("%s%n", g.format());
    }
  }
  
}
