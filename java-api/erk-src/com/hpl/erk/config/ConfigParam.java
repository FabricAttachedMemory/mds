/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.config;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;

import com.hpl.erk.ReadableString;
import com.hpl.erk.config.ex.ErrorDuringForce;
import com.hpl.erk.config.ex.IgnoreableIllegalValueException;
import com.hpl.erk.config.ex.IllegalValueException;
import com.hpl.erk.config.ex.ReadError;
import com.hpl.erk.iter.Iteration;
import com.hpl.erk.util.CollUtils;



public class ConfigParam<T>  {
  private static final Logger logger = Logger.getLogger(ConfigParam.class);
  public static final List<ConfigParam<?>> paramsBySerialNumber = new LinkedList<>();

  public final int serialNumber;
  public final String name;
  public final RunContext context;
  protected T val;
  protected T defaultVal;
  protected String delayedDefault;
  protected Source source = Source.UNSET;
  protected final PType<T> type;
  protected String helpString = null;
  protected Storage<? super T> storage = null;
  protected List<Restriction<? super T>> restrictions = null;
  protected List<Interpreter<T>> interpreters = null;
  protected DelayedVal<? extends T> delayedVal = null;
  
  public static final Map<String, Map<RunContext, ConfigParam<?>>> active = new HashMap<>();
  private static final List<ConfigParam<?>> withDelayedVal = new ArrayList<>();
  

  public static interface Storage<T> {
    public void store(T val);
  }
  
  public ConfigParam(RunContext context, String name, PType<T> type) {
    this.context = context;
    this.name = name;
    this.type = type;
    synchronized (paramsBySerialNumber) {
      serialNumber = paramsBySerialNumber.size();
      paramsBySerialNumber.add(this);
    }
    context.register(this);
  }
  
  public ConfigParam(String name, PType<T> type) {
    this(RunContext.GLOBAL, name, type);
  }
  
  public ConfigParam(RunContext context, String name, Class<T> c) {
    this(context, name, PType.of(c));
  }
  
  public ConfigParam(String name, Class<T> c) {
    this(RunContext.GLOBAL, name, c);
  }
  
  public ConfigParam<T> defaultVal(T defaultVal) {
    try {
      setVal(defaultVal, Source.DEFAULT);
    } catch (IllegalValueException e) {
      logger.warn(String.format("Error setting default val for %s", fullName()), e);
    }
    return this;
  }
  
  public PType<T> type() {
    return type;
  }
  
  public ConfigParam<T> delayedDefault(DelayedVal<T> dv) {
    setDelayed(dv, Source.DEFAULT);
    delayedDefault = dv.desc;
    return this;
  }
  
  public ConfigParam<T> delayedDefault(final ConfigParam<? extends T> cp) {
    return delayedDefault(DelayedVal.referencing(cp));
  }
  
  public ConfigParam<T> help(String helpString, Object...fmtArgs) {
    this.helpString = fmtArgs.length == 0 ? helpString : String.format(helpString, fmtArgs);
    return this;
  }
  
  public ConfigParam<T> storage(Storage<? super T> storage) {
    this.storage = storage;
    return this;
  }
  
  public ConfigParam<T> restrict(final Restriction<? super T> restriction) {
    if (restriction != null) {
      restrictions = CollUtils.addTo(restrictions, restriction, CollUtils.<Restriction<? super T>>arrayListCreator(1));
    }
    return this;
  }
  
  public ConfigParam<T> interpret(final Interpreter<T> interpreter) {
    if (interpreter != null) {
      interpreters = CollUtils.addTo(interpreters, interpreter, CollUtils.<Interpreter<T>>arrayListCreator(1));
    }
    return this;
  }
  
  private class DelayedCycle extends DelayedVal<T> {

    protected DelayedCycle() {
      super("Cycle in delayed val evaluation");
    }

    @Override
    public T force() {
      throw new IllegalStateException(String.format("Cycle in delayed val evaluation of %s", fullName()));
    }
  }
  
  public String fullName() {
    return String.format("%s.%s", context.name, name);
  }
  
  public T getVal() {
    if (delayedVal != null) {
      final DelayedVal<? extends T> dv = delayedVal;
      delayedVal = new DelayedCycle();
      try {
        internalSetVal(dv.force());
      } catch (IllegalValueException e) {
        throw new ErrorDuringForce(this, dv, e);
      }
      delayedVal = null;
    }
    return val;
  }
  
  public Source getSource() {
    return source;
  }
  
  public void setVal(T val) throws IllegalValueException {
    setVal(val, Source.EXPLICIT);
  }
  
  public void setVal(T newVal, Source newSource) throws IllegalValueException {
    if (newSource == Source.DEFAULT) {
      defaultVal = newVal;
    }
    if ((source == newSource && source.allowEquivalent()) || source.compareTo(newSource) < 0) {
      if (internalSetVal(newVal)) {
        source = newSource;
      }
    }
  }
  
  private boolean internalSetVal(T newVal) throws IllegalValueException {
    if (interpreters != null) {
      for (Interpreter<T> i : CollUtils.maybeNullCollection(interpreters)) {
        try {
          newVal = i.interpret(newVal);
        } catch (IgnoreableIllegalValueException e) {
          return false;
        }
      }
    }
    if (restrictions != null) {
      for (Restriction<? super T> r : CollUtils.maybeNullList(restrictions)) {
        if (newVal != null || !r.alwaysAllowsNull()) {
          r.check(newVal, this);
        }
      }
    }
    val = newVal;
    if (storage != null) {
      storage.store(val);
    }
    return true;
  }
  
  public void setDelayed(DelayedVal<? extends T> dv) {
    setDelayed(dv, Source.EXPLICIT);
  }
  
  public void setDelayed(DelayedVal<? extends T> dv, Source newSource) {
    if ((source == newSource && source.allowEquivalent()) || source.compareTo(newSource) < 0) { 
      source = newSource;
      delayedVal = dv;
      withDelayedVal.add(this);
    }
  }
  
  public static void forceDelayed() {
    for (ConfigParam<?> cp : withDelayedVal) {
      cp.getVal();
    }
    withDelayedVal.clear();
  }

  public boolean activate(boolean warnOnReplacement) {
    Map<RunContext, ConfigParam<?>> map = active.get(name);
    if (map == null) {
      map = new IdentityHashMap<>();
      active.put(name, map);
    }
    ConfigParam<?> old = map.put(context, this);
    if (old != null && old != this && warnOnReplacement) {
      logger.warn(String.format("Warning: RunContext %s replaced param %s%n", context, name));
    }
    return old != null;
  }
  
  public void readAndSet(String s, Source newSource) throws ReadError, IllegalValueException {
    if (!newSource.overrides(source)) {
      return;
    }
    try {
      setVal(type.read(s), newSource);
    } catch (ReadDelayedVal e) {
      setDelayed(e.<T>delayedVal(), newSource);
    }
  }
  
  @Override
  public String toString() {
    String vString = val==null ? "null" : type.format(val);
    return String.format("%s.%s(%s = %s, %s)", context, name, type, vString, source);
  }
  
  public String asSwitch(boolean includeContext) {
    return includeContext ? String.format("-%s.%s", context.name, name) : String.format("-%s", name);
  }
  
  public String asSwitch() {
    return asSwitch(false);
  }
  
  public String formatDefault() {
    return type.format(defaultVal);
  }
  
  public String formatVal() {
    return type.format(val);
  }

  public static ConfigParam<?> find(String kwd, String context) {
    RunContext requiredContext = null;
    if (context != null && !context.isEmpty()) {
      requiredContext = RunContext.find(context, false);
      if (requiredContext == null) {
        throw new IllegalArgumentException(String.format("Unknown context '%s'", context));
      }
    }
    Map<RunContext, ConfigParam<?>> matching = active.get(kwd);
    if (matching == null || matching.isEmpty()) {
      return null;
    }
    Map<RunContext, ConfigParam<?>> pruned = new IdentityHashMap<>(matching);
    for (Iteration<ConfigParam<?>> iteration : Iteration.over(pruned.values())) {
      ConfigParam<?> cp = iteration.current();
      if (!cp.context.isActive()) {
        iteration.removeCurrent();
      }
      if (requiredContext != null) {
        if (!requiredContext.dominatedBy(cp.context)) {
          iteration.removeCurrent();
        }
      }
    }
    if (pruned.isEmpty()) {
      return null;
    }
    if (pruned.size() == 1) {
      return pruned.values().iterator().next();
    }
    String cdesc = requiredContext == null ? "" : context+".";
    throw new IllegalArgumentException(String.format("param '%s%s' could be any of %s",
                                                     cdesc, kwd, pruned));
  }
  
  private static final Pattern paramRefPat = Pattern.compile("\\s*@(?:([a-z_][a-z0-9_-]*(?<!-))\\.)?([a-z_][a-z0-9_-]*(?<!-))", Pattern.CASE_INSENSITIVE);
  public static ConfigParam<?> readRef(ReadableString s, int resetTo, PType<?> type) throws ReadError {
    Matcher m = s.consume(paramRefPat);
    if (m == null) {
      return null;
    }
    String context = m.group(1);
    String param = m.group(2);
    ConfigParam<?> cp = ConfigParam.find(param, context);
    if (cp == null) {
      throw new ReadError(s, resetTo, type, "Unknown parameter reference '%s'", m.group());
    }
    return cp;
  }

  public <C> DelayedVal<C> delayedValTo(PType<C> otherType) {
    return otherType.delayedValFrom(this);
  }


  /** @return getVal().equals(cmp); true if both are null.  
   * Readable convenience method for testing values, e.g. 
   * <pre>
   * if (param.is("solid")) {... 
   * if (param.is("blue")) {...
   */
  public boolean is(T cmp) {
	  T v = getVal();
	  if (v == null) {
	    return cmp == null;
	  }
	  return v.equals(cmp);
  }

  /** @return getVal().  Common-case shorthand to make client code less bulky.
   * Using this, we can use lots of config parameters conveniently and readably, e.g.
   * <pre>
   * double factor = known.v() * train.v() / sz.v() + classes.v();
   * System.err.printf("Generating %.2f cases in each of %,d largest classes (%.1f) into %s.csv%n",
   * 	train.v(), known.v(), train.v() * known.v(), fname.v());
   * </pre>
   * instead of
   * <pre>
   * double factor = known.getVal() * train.getVal() / sz.getVal() + classes.getVal();
   * System.err.printf("Generating %.2f cases in each of %,d largest classes (%.1f) into %s.c.getVal%n",
   * 	train.getVal(), known.getVal(), train.getVal() * known.getVal(), fname.getVal());
   */
  public T v() { return getVal(); }
  
  public List<Restriction<? super T>> restrictions() {
    return CollUtils.maybeNullList(restrictions);
  }
  public List<Interpreter<T>> interpreters() {
    return CollUtils.maybeNullList(interpreters);
  }
  
  
  public static Comparator<ConfigParam<?>> bySerialNumber() {
    return new Comparator<ConfigParam<?>>() {
      @Override
      public int compare(ConfigParam<?> o1, ConfigParam<?> o2) {
        return o1.serialNumber - o2.serialNumber;
      }
    };
  }
}
