/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.config;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.hpl.erk.adt.IdentityHashSet;
import com.hpl.erk.config.type.MappishType;
import com.hpl.erk.config.type.SeqType;
import com.hpl.erk.func.Functions;
import com.hpl.erk.func.Pair;

public abstract class ValueConverter<From, To> {
  public final PType<? super From> from;
  public final PType<? extends To> to;
  
  private static final Map<Pair<PType<?>, PType<?>>, ValueConverter<?,?>> registered = new HashMap<>();

  public abstract To convert(From val);
  
  public ValueConverter(PType<? super From> from, PType<? extends To> to) {
    this.from = from;
    this.to = to;
  }
  
  public ValueConverter<From, To> register() {
    Pair<PType<?>, PType<?>> key = Functions.<PType<?>, PType<?>>pair(from, to);
    registered.put(key, this);
    return this;
  }
  
  public static <From, To> ValueConverter<? super From, ? extends To> lookup(PType<From> from, PType<To> to) {
    if (from instanceof SeqType && to instanceof SeqType) {
      @SuppressWarnings("unchecked")
      final SeqType<From, ?> fromCT = (SeqType<From,?>)from;
      @SuppressWarnings("unchecked")
      final SeqType<To, ?> toCT = (SeqType<To,?>)to;
      ValueConverter<From,To> vc = lookupComposite(fromCT, toCT);
      if (vc != null) {
        return vc;
      }
    }
    if (from instanceof MappishType && to instanceof MappishType) {
      @SuppressWarnings("unchecked")
      final MappishType<From, ?, ?> fromMT = (MappishType<From,?,?>)from;
      @SuppressWarnings("unchecked")
      final MappishType<To, ?, ?> toMT = (MappishType<To,?,?>)to;
      ValueConverter<From,To> vc = lookupMapping(fromMT, toMT);
      if (vc != null) {
        return vc;
      }
    }
    ValueConverter<? super From, ? extends To> best = null;
    for (ValueConverter<?, ?> vc : registered.values()) {
      if (to.assignableFrom(vc.to) && vc.from.assignableFrom(from)) {
        @SuppressWarnings("unchecked")
        ValueConverter<? super From, ? extends To> c = (ValueConverter<? super From, ? extends To>)vc;
        if (best == null) {
          best = c;
        } else if (best.from.assignableFrom(c.from)) {
          best = c;
        } else if (best.from == c.from && c.to.assignableFrom(best.to)) {
          best = c;
        }
      }
    }
    return best;
  }

  private static <FK, FV, From, TK, TV, To>
  ValueConverter<From, To> 
  lookupMapping(final MappishType<From, FK, FV> fromMTS,  final MappishType<To, TK, TV> toMTS) 
  {
    PType<FK> fromKey = fromMTS.keyType();
    PType<FV> fromVal = fromMTS.valType();
    PType<From> fromMT = fromMTS.asType();
    PType<TK> toKey = toMTS.keyType();
    PType<TV> toVal = toMTS.valType();
    PType<To> toMT = toMTS.asType();
    if (toKey.assignableFrom(fromKey) && toVal.assignableFrom(fromVal)) {
      return new ValueConverter<From, To>(fromMT, toMT) {
        @Override
        public To convert(From val) {
          Map<FK,FV> map = fromMTS.asMap(val);
          @SuppressWarnings("unchecked")
          final Map<? extends TK, ? extends TV> downcast = (Map<? extends TK, ? extends TV>)map;
          return toMTS.copyFrom(downcast);
        }
      };
    }
    // TODO handle convertable keys and vals
    return null;
  }
  private static <F, From, T, To>
  ValueConverter<From, To> 
  lookupComposite(final SeqType<From, F> fromCTS,  final SeqType<To,T> toCTS) 
  {
    PType<F> fromElt = fromCTS.elementType();
    PType<From> fromCT = fromCTS.asType();
    PType<T> toElt = toCTS.elementType();
    PType<To> toCT = toCTS.asType();
    if (toElt.assignableFrom(fromElt)) {
      return new ValueConverter<From, To>(fromCT, toCT) {
        @Override
        public To convert(From val) {
          Collection<F> coll = fromCTS.asCollection(val);
          @SuppressWarnings("unchecked")
          final Collection<? extends T> downcast = (Collection<? extends T>)coll;
          return toCTS.copyFrom(downcast);
        }
      };
    }
    final ValueConverter<? super F, ? extends T> vc = lookup(fromElt, toElt);
    if (vc == null) {
      return null;
    }
    return new ValueConverter<From, To>(fromCT, toCT) {
      @Override
      public To convert(From val) {
        Collection<F> coll = fromCTS.asCollection(val);
        List<T> list = new ArrayList<>(coll.size());
        for (F elt : coll) {
          list.add(vc.convert(elt));
        }
        return toCTS.copyFrom(list);
      }
    };
  }
  
  public static Set<PType<?>> convertableTo(PType<?> to) {
    Set<PType<?>> set = null;
    for (Pair<PType<?>, PType<?>> key : registered.keySet()) {
      if (to.assignableFrom(key.value)) {
        if (set == null) {
          set = new IdentityHashSet<>();
        }
        set.add(key.key);
      }
    }
    return set;
  }
}
