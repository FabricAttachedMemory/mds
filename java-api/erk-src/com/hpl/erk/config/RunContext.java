/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.config;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.hpl.erk.AutoFill;
import com.hpl.erk.Types;
import com.hpl.erk.adt.IdentityHashSet;
import com.hpl.erk.config.type.EnumType;

public class RunContext implements Comparable<RunContext> {
  private static final Map<String, RunContext> known = Collections.synchronizedMap(new HashMap<String, RunContext>());
  private static final Set<RunContext> activeContexts = Collections.synchronizedSet(new IdentityHashSet<RunContext>());
  public static RunContext GLOBAL = new RunContext("global", true) {
    public boolean isGlobal() {
      return true;
    };
  };
  
      
  public final String name;
  private final List<RunContext> parents;
  private final Set<RunContext> dominatedBy;
  protected boolean active = false;
  
  public RunContext(String name, boolean active, RunContext...parents) {
    this.name = name;
    this.parents = (parents.length == 0 
        ? (GLOBAL == null ? Collections.<RunContext>emptyList() : Collections.singletonList(GLOBAL))
        : new ArrayList<>(Arrays.asList(parents)));
    known.put(name.toLowerCase(), this);
    dominatedBy = new IdentityHashSet<>(this.parents);
    for (RunContext parent : parents) {
      dominatedBy.addAll(parent.dominatedBy);
    }

    if (active) {
      activate();
    }
  }
  
  public RunContext(String name, RunContext...parents) {
    this(name, false, parents);
  }
  public boolean isActive() {
    return active;
  }
  
  public boolean isGlobal() {
    return false;
  }
  
  public RunContext activate() {
    if (!active) {
      active = true;
      activeContexts.add(this);
      for (RunContext c : parents) {
        c.activate();
      }
    }
    return this;
  }
  
  
  public boolean register(ConfigParam<?> param) {
    return param.activate(true);
  }

  @Override
  public String toString() {
    return name;
  }

  public static RunContext find(String contextName, boolean createIfMissing) {
    RunContext rc = known.get(contextName.toLowerCase());
    if (rc == null && createIfMissing) {
      rc = new RunContext(contextName);
    }
    return rc;
  }
  
  public static Map<RunContext, List<ConfigParam<?>>> paramMap(boolean includeInactive) {
    Map<RunContext, List<ConfigParam<?>>> map = AutoFill.hashMapToArrayList(RunContext.class, Types.<ConfigParam<?>>marker());
    for (Map<RunContext, ConfigParam<?>> m : ConfigParam.active.values()) {
      for (ConfigParam<?> cp : m.values()) {
        if (includeInactive || cp.context.isActive()) {
          map.get(cp.context).add(cp);
        }
      }
    }
    return map;
  }
  
  public List<ConfigParam<?>> params(boolean includeNested) {
    List<ConfigParam<?>> list = new ArrayList<>();
    for (Map<RunContext, ConfigParam<?>> m : ConfigParam.active.values()) {
      for (Entry<RunContext, ConfigParam<?>> entry : m.entrySet()) {
        RunContext ctxt = entry.getKey();
        if (ctxt == this || (includeNested && ctxt.dominatedBy(this))) {
          list.add(entry.getValue());
        }
      }
    }
    return list;
  }
  
  /** @return params(boolean) sorted by serial number */
  public List<ConfigParam<?>> paramsBySerialNumber(boolean includeNested) {
		ArrayList<ConfigParam<?>> params = new ArrayList<ConfigParam<?>>(params(includeNested));
		Collections.sort(params, ConfigParam.bySerialNumber());
		return params;
  }

  public boolean dominatedBy(RunContext context) {
    if (this == context) {
      return true;
    }
    for (RunContext parent : parents) {
      if (parent.dominatedBy(context)) {
        return true;
      }
    }
    return false;
  }

  @Override
  public int compareTo(RunContext o) {
    if (this == o) {
      return 0;
    }
    if (dominatedBy(o)) {
      return -1;
    }
    if (o.dominatedBy(this)) {
      return 1;
    }
    return name.compareTo(o.name);
  }
  
  public static Set<RunContext> activeContexts() {
    return activeContexts;
  }

  public <T> ConfigParam<T> param(PType<T> type, String name) {
    return type.configParam(this, name);
  }
  
  public <T> ConfigParam<T> param(Class<T> clss, String name) {
    return param(PType.of(clss), name);
  }
  
  public <T> ConfigParam<List<T>> listParam(PType<T> type, String name) {
    return param(PType.listOf(type), name);
  }
  public <T> ConfigParam<List<T>> listParam(Class<T> clss, String name) {
    return listParam(PType.of(clss), name);
  }
  
  public <T> ConfigParam<Set<T>> setParam(PType<T> type, String name) {
    return param(PType.setOf(type), name);
  }
  public <T> ConfigParam<Set<T>> setParam(Class<T> clss, String name) {
    return setParam(PType.of(clss), name);
  }
  
  public <T> ConfigParam<T[]> arrayParam(PType<T> type, String name) {
    return param(PType.arrayOf(type), name);
  }
  public <T> ConfigParam<T[]> arrayParam(Class<T> clss, String name) {
    return arrayParam(PType.of(clss), name);
  }
  
  public <E extends Enum<E>> ConfigParam<EnumSet<E>> enumSetParam(PType<E> type, String name) {
    return param(PType.enumSetOf(type), name);
  }
  public <E extends Enum<E>> ConfigParam<EnumSet<E>> enumSetParam(Class<E> clss, String name) {
    return enumSetParam(EnumType.ofEnum(clss), name);
  }

  public <K,V> ConfigParam<Map<K,V>> mapParam(Class<K> key, Class<V> val, String name) {
    return mapParam(PType.of(key), PType.of(val), name);
  }
  public <K,V> ConfigParam<Map<K,V>> mapParam(Class<K> key, PType<V> val, String name) {
    return mapParam(PType.of(key), val, name);
  }
  public <K,V> ConfigParam<Map<K,V>> mapParam(PType<K> key, Class<V> val, String name) {
    return mapParam(key, PType.of(val), name);
  }
  public <K,V> ConfigParam<Map<K,V>> mapParam(PType<K> key, PType<V> val, String name) {
    return param(PType.mapOf(key, val), name);
  }
  
  public RunContext subContext(String processName) {
    return new RunContext(processName, this);
  }
  public RunContext subContext(String processName, boolean activate) {
    return new RunContext(processName, activate, this);
  }
  
}
