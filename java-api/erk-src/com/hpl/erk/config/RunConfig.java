/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.config;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;

import com.hpl.erk.AutoFill;
import com.hpl.erk.Generics;
import com.hpl.erk.Glossary;
import com.hpl.erk.LineWrapper;
import com.hpl.erk.PropAndEnvHandler;
import com.hpl.erk.SelfWrapping;
import com.hpl.erk.Types;
import com.hpl.erk.adt.IdentityHashSet;
import com.hpl.erk.chain.Chain;
import com.hpl.erk.chain.Chain.Receiver;
import com.hpl.erk.config.Source.Loc;
import com.hpl.erk.config.ex.ConfigErrorsSeen;
import com.hpl.erk.config.ex.ErrorDuringForce;
import com.hpl.erk.config.ex.IllegalValueException;
import com.hpl.erk.config.ex.ReadError;
import com.hpl.erk.config.func.ConfigFunc;
import com.hpl.erk.config.type.BuiltInTypes;
import com.hpl.erk.config.type.SimpleType;
import com.hpl.erk.func.NullaryFunc;
import com.hpl.erk.func.Functions;
import com.hpl.erk.func.Predicate;
import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.util.CollUtils;
import com.hpl.erk.util.Strings;

public class RunConfig {
  private static final Logger logger = Logger.getLogger(RunConfig.class);
  private static final PType<Boolean> BOOLEAN_TYPE = PType.of(Boolean.class);
  private static final ErrorLog errorLog = new ErrorLog();
  
  private static final Map<String, String> falsePrefixes = new HashMap<String, String>();

  static void falsePrefix(String ...strings) {
    falsePrefixKeeping("", strings);
  }
  
  static void falsePrefixKeeping(String keep, String ...strings) {
    for (String s : strings) {
      falsePrefixes.put(s.toLowerCase(), keep.toLowerCase());
    }
  }
  
  static {
    falsePrefix("doNot", "dont", "do_not");
    falsePrefix("no", "not");
    falsePrefixKeeping("is", "isNot", "isnt", "is_not");
  }
  
  private static class NotCollectionError extends Exception {

    private static final long serialVersionUID = 5976070293719231952L;
    @SuppressWarnings("unused")
    public final ConfigParam<?> param;
    private NotCollectionError(ConfigParam<?> param) {
      super(String.format("%s: Not a collection parameter", param.asSwitch()));
      this.param = param;
    }
  }
  
  private static class ParamWithoutValError extends Exception {

    private static final long serialVersionUID = -7544239315171812235L;
    @SuppressWarnings("unused")
    public final ConfigParam<?> param;
    private ParamWithoutValError(ConfigParam<?> param) {
      super(String.format("%s: parameter without value", param.asSwitch()));
      this.param = param;
    }
  }
  

  
  @SuppressWarnings("unused")
  private static Class<?>[] RUN_CONFIG_DEPENDENCIES = { BuiltInTypes.class };
  
  static final RunContext ctxt = RunContext.find("cmd_line", true).activate();
  
  private static NullaryFunc<?> usageCreator;
  
  private static final List<Path> defaultSearchPath = new ArrayList<>(2);
  static {
    defaultSearchPath.add(Paths.get("."));
    String homeDir = System.getenv("HOME");
    if (homeDir != null && !homeDir.isEmpty()) {
      defaultSearchPath.add(Paths.get(homeDir));
    }
  }
  
  private static ConfigParam<List<Path>> searchPathParam = ctxt.listParam(Path.class, "config_file_path")
      .defaultVal(defaultSearchPath)
      .help("Directories to search for config files");
                  
  
//  private static ConfigParam<File> configDirParam = ctxt.param(File.class, "config_file_dir")
//      .validator(FileRestriction.isDir)
//      .defaultVal(new File("."))
//      .help("Directory containing config files");
 
  private static ConfigParam<String> configFileSuffixParam = ctxt.param(String.class, "config_file_suffix")
      .defaultVal(".config")
      .help("Suffix for configuration files");
  
  static ConfigParam<Boolean> dumpParamsParam = ctxt.param(Boolean.class, "dump_params")
      .defaultVal(false)
      .help("Dump param values");
  
  private static ConfigParam<EnumSet<DumpOption>> dumpOptsParam = ctxt.enumSetParam(DumpOption.class, "dump")
      .defaultVal(EnumSet.allOf(DumpOption.class))
      .help("What to dump with -%s", dumpParamsParam.name);
  
  private static ConfigParam<Integer> dumpLineWidth = ctxt.param(Integer.class, "dump_line_width")
      .defaultVal(80)
      .help("Default width for lines with -%s", dumpParamsParam.name);
  
  private static ConfigParam<File> dumpToParam = ctxt.param(File.class, "dump_params_to")
      .defaultVal(null)
      .help("File to dump params to with -%s or null to dump to terminal", dumpParamsParam.name);
  
//  private static ConfigParam<Boolean> singleLineParamDescsParam = ctxt.param(Boolean.class, "single_line_param_descs")
//      .defaultVal(true)
//      .help(String.format("Show sources on the same line as values with -%s", dumpParamsParam.name));
  
  private static ConfigParam<Boolean> helpParam = ctxt.param(Boolean.class, "help") 
      .defaultVal(false)
      .help("Show usage help and help on available params");
  
  private static ConfigParam<EnumSet<HelpOption>> helpOptsParam = ctxt.enumSetParam(HelpOption.class, "help_on")
      .defaultVal(EnumSet.complementOf(EnumSet.of(HelpOption.INACTIVE)))
      .help("What to give help on with -%s", helpParam.name);

  private static ConfigParam<Integer> helpLineWidth = ctxt.param(Integer.class, "help_line_width")
      .defaultVal(100)
      .help("Default width for lines with -%s", helpParam.name);
  
  static ConfigParam<Boolean> stopAfterParserParam = ctxt.param(Boolean.class, "stop_after_parser")
      .defaultVal(false)
      .help("Exit after processing params");
  
//  private static ConfigParam<Boolean> stopOnParseErrorsParam = ctxt.param(Boolean.class, "stop_on_parse_errors")
//      .defaultVal(true)
//      .help("Stop if errors parsing params");
//  
//  private static ConfigParam<Boolean> warnOnUnresolvedParam = ctxt.param(Boolean.class, "warn_on_unresolved")
//      .defaultVal(true)
//      .help("Warn if unknown param seen");
  
  
  
  
  

  public static String[] process(String processName, String[] args, Class<?>...classes) throws ConfigErrorsSeen {
    return process(processName, args, Arrays.asList(classes));
  }
  public static String[] process(Class<?> mainClass, String[] args, Class<?>...classes) throws ConfigErrorsSeen {
    return process(mainClass, args, Arrays.asList(classes));
  }
  
  public static String[] process(String[] args, Class<?>...classes) throws ConfigErrorsSeen {
    return process((String)null, args, classes);
  }
  public static String[] process(String[] args, Collection<Class<?>> classes) throws ConfigErrorsSeen {
    return process((String)null, args, classes);
  }
  public static String[] process(Class<?> mainClass, String[] args, Collection<Class<?>> classes) throws ConfigErrorsSeen {
    String processName = mainClass == null ? "" : mainClass.getSimpleName();
    Collection<Class<?>> toCheck = classes;
    if (mainClass != null) {
      toCheck = new ArrayList<>(classes.size()+1);
      toCheck.add(mainClass);
      toCheck.addAll(classes);
    }
    String[] val = process(processName, args, toCheck);
    return val;
    
  }
  public static String[] process(String processName, String[] args, Collection<Class<?>> classes) throws ConfigErrorsSeen {
    RunContext processContext = processName != null && !processName.isEmpty() ? RunContext.find(processName, true) : null;
    if (processContext != null) {
      processContext.activate();
    }
    Collection<Class<?>> list = augmentClassList(classes, "RUN_CONFIG_DEPENDENCIES");
    ensureSetUp(list);
    ensureActivated("PARAM_CONTEXTS");
    
    
    args = processCommandLineArgs(args);
    
    processVariables(System.getProperties(), Source.Loc.PROPERTY);
    processVariables(System.getenv(), Source.Loc.ENVIRONMENT_VARIABLE);
//    processProperties();
    processConfigFiles();
    ConfigParam.forceDelayed();

    if (helpParam.getVal()) {
      displayHelp();
    }
    if (dumpParamsParam.getVal()) {
      dumpParams();
    }
    errorLog.dumpErrors();
    if (stopAfterParserParam.getVal()) {
      System.exit(0);
    }
    return args;
  }
  

  static final Pattern var = Pattern.compile("^(?:([a-z_][a-z0-9_-]*(?<!-))\\.)?([a-z_][a-z0-9_-]*(?<!-))_param");

  private static <K,V> void processVariables(Map<K, V> map, Loc loc) {
    for (Entry<K, V> entry : map.entrySet()) {
      K key = entry.getKey();
      if (!(key instanceof String)) {
        continue;
      }
      String k = ((String)key).toLowerCase();
      Matcher m = var.matcher(k);
      if (!m.matches()) {
        continue;
      }
      String context = m.group(1);
      String param = m.group(2);
      V val = entry.getValue();
      if (!(val instanceof String)) {
        continue;
      }
      String v = (String)val;
      Source source = new Source.FromVar(k, loc);
      ConfigParam<?> cp = ConfigParam.find(param, context);
      if (cp == null) {
        logger.warn(String.format("%s looks like a parameter, but isn't, ignoring", source));
        continue;
      }
      try {
        cp.readAndSet(v, source);
      } catch (ReadError | IllegalValueException | ErrorDuringForce e) {
        errorLog.noteError(cp, source, e);
//        String cdesc = context == null ? "" : context+".";
//        logger.error(String.format("%s (line %,d): Error processing: '%s%s: %s': (%s) %s, ignoring%n",
//                          source, cdesc, param, val, e.getClass().getSimpleName(), e.getMessage()));
      }
    }
  }

  private static final class AugmentClassHandler    extends PropAndEnvHandler {
    private final Collection<Class<?>> orig;
    @SuppressWarnings("unchecked")
    final PType<List<Class<?>>> classListType = PType.listOf((Class<Class<?>>)(Class<?>)Class.class);
    Collection<Class<?>> classes;

    private AugmentClassHandler(String propName, Collection<Class<?>> orig) {
      super(propName);
      this.orig = orig;
      classes = orig;
    }

    @Override
    protected void process(String fromProp, Source source) throws ReadError, ReadDelayedVal {
      if (fromProp == null) {
        return;
      }
      if (classes == orig) {
        classes = new ArrayList<>(orig);
      }
      List<Class<?>> toProcess = classListType.read(fromProp); 
      classes.addAll(toProcess);
    }
    
    @Override
    public void process() {
      try {
        super.process();
      } catch (Exception e) {
        // This shouldn't be possible.
        throw new IllegalStateException(String.format("AugmentClassHandler.process() threw an exception: %s: %s", e.getClass(), e.getMessage()), e);
      }
    }
  }


  private static Collection<Class<?>> augmentClassList(final Collection<Class<?>> orig, final String propName) {
    AugmentClassHandler handler = new AugmentClassHandler(propName, orig);
    handler.process();
    return handler.classes;
  }
  private static void ensureActivated(final String propName) {
    PropAndEnvHandler handler = new PropAndEnvHandler(propName) {
      PType<List<String>> stringListType = PType.listOf(String.class);

      @Override
      protected void process(String fromProp, Source source) throws ReadError, ReadDelayedVal {
        if (fromProp == null) {
          return;
        }
        List<String> toProcess = stringListType.read(fromProp); 
        for (String name : toProcess) {
          RunContext ctxt = RunContext.find(name, false);
          if (ctxt == null) {
            logger.warn(String.format("Unknown run context '%s' in %s, ignoring", name, source));
          } else {
            ctxt.activate();
          }
        }
      }
    };
    handler.process();
  }

  private static void processConfigFiles() {
    PriorityQueue<RunContext> queue = new PriorityQueue<>(RunContext.activeContexts());
    Set<RunContext> processed = new IdentityHashSet<>();
    while (!queue.isEmpty()) {
      RunContext context = queue.poll();
      processConfigFile(context, queue, processed);
    }
  }

  private static void processConfigFile(RunContext context,
                                        PriorityQueue<RunContext> queue,
                                        Set<RunContext> processed) 
  {
    if (!processed.add(context)) {
      return;
    }

    final File cfile = findConfigFile(context.name);
    if (cfile == null) {
      return;
    }
    ConfigReader rdr = new ConfigReader(cfile, queue);
    Chain.from(cfile).fill(rdr);
  }
  
  private static File findConfigFile(String contextName) {
    String suffix = configFileSuffixParam.getVal();
    if (suffix == null) { 
      suffix = "";
    }
    final List<Path> dirs = searchPathParam.getVal();
    final String fileName = contextName+suffix;
    for (Path dir : dirs) {
      if (dir != null) {
        Path p = dir.resolve(fileName);
        File f = p.toFile();
        if (f.exists()) {
          return f;
        }
      }
    }
    return null;
  }

  static class ConfigReader implements Receiver<String> {
    static final Pattern blank = Pattern.compile("^\\s*(?:(?://|#).*)?$");
    static final Pattern continuation = Pattern.compile("^\\s+(\\S.*)$");
    static final Pattern arg = Pattern.compile("^(?:([a-z_][a-z0-9_-]*(?<!-))\\.)?([a-z_][a-z0-9_-]*(?<!-))(\\+\\+?\\-\\-?)?:(?:\\s+(\\S.*))?", Pattern.CASE_INSENSITIVE);
    static final Pattern contextPat = Pattern.compile("^\\+([a-z_][a-z0-9_-]*(?<!-))\\s*$", Pattern.CASE_INSENSITIVE);
    final File f;
    int lineNum = 0;
    int lineStarts = 0;
    String context = null;
    String kwd = null;
    String val = null;
    private final PriorityQueue<RunContext> queue;
    private String mods;

    
    protected ConfigReader(File f, PriorityQueue<RunContext> queue) {
      this.f = f;
      this.queue = queue;
    }
    
    @Override
    public boolean receive(String line) {
      lineNum++;
      Matcher m = blank.matcher(line);
      if (m.matches()) {
        return true;
      }
      m = continuation.matcher(line);
      if (m.matches()) {
        String s = m.group(1);
        if (val != null) {
          val += " ";
        }
        val += s;
        return true;
      }
      m = arg.matcher(line);
      if (m.matches()) {
        process();
        context = m.group(1);
        kwd = m.group(2);
        mods = m.group(3);
        val = m.group(4);
        lineStarts = lineNum;
        return true;
      }
      m = contextPat.matcher(line);
      if (m.matches()) {
        RunContext rc = RunContext.find(line, true);
        queue.add(rc);
      }
      logger.warn(String.format("%s (line %,d): Weird line: '%s', ignoring%n", f, lineNum, line));
      return true;
    }

    private void process() {
      if (kwd == null) {
        return;
      }
      ConfigParam<?> cp = ConfigParam.find(kwd, context);
      Source source = Source.fromFile(f, lineStarts);
      if (cp == null) {
        errorLog.unknownParam(kwd, source);
        return;
      }
      try {
        if (mods == null) {
          cp.readAndSet(val, source);
        } else if (!(cp instanceof CollectionCP)) {
          throw new NotCollectionError(cp);
        } else {
          CollectionCP<?,?> ccp = (CollectionCP<?,?>)cp;
          switch (mods) {
          case "+":
            ccp.readAndAdd(val, source);
            break;
          case "++":
            ccp.readAndAddAll(val, source);
            break;
          case "-":
            ccp.readAndRemove(val, source);
            break;
          case "--":
            ccp.readAndRemoveAll(val, source);
            break;
          default:
            throw new IllegalStateException();  
          }
        }
      } catch (ReadError | IllegalValueException | NotCollectionError | ErrorDuringForce e) {
        errorLog.noteError(cp, source, e);
//        String cdesc = context == null ? "" : context+".";
//        logger.error(String.format("%s (line %,d): Error processing: '%s%s: %s': (%s) %s, ignoring%n",
//                          f, lineStarts, cdesc, kwd, val, e.getClass().getSimpleName(), e.getMessage()));
      }
    }
    
    @Override
    public void close() {
      process();
    }
    
  }

  static final Pattern argPat = Pattern.compile("^-(?:([a-z_][a-z0-9_-]*(?<!-))\\.)?([a-z_][a-z0-9_-]*(?<!-))(\\+\\+?|--?)?(?:=(.*))?$", Pattern.CASE_INSENSITIVE);
  static final Pattern contextPat = Pattern.compile("^\\+([a-z_][a-z0-9_-]*(?<!-))$", Pattern.CASE_INSENSITIVE);

  public static String[] processCommandLineArgs(String[] args) {
    final int length = args.length;
    if (length == 0) {
      return args;
    }
    for (int i=0; i<length; i++) {
      String arg = args[i];
      if (arg.equals("--")) {
        return Arrays.copyOfRange(args, i+1, length);
      }
      Matcher m;
      if ((m = argPat.matcher(arg)).matches()) {
        String context = m.group(1);
        String kwd = m.group(2);
        String mod = m.group(3);
        String val = m.group(4);
        ConfigParam<?> cp = ConfigParam.find(kwd, context);
        if (cp == null) {
          final String lcKwd = kwd.toLowerCase();
          for (Entry<String, String> entry : falsePrefixes.entrySet()) {
            String prefix = entry.getKey();
            String keep = entry.getValue(); 
            final int len = prefix.length();
            if (lcKwd.startsWith(prefix)) {
              String k = keep+kwd.substring(len);
              cp = ConfigParam.find(k, context);
              if (cp != null && cp.type == BOOLEAN_TYPE) {
                val = "false";
                break;
              }
              k = keep+kwd.substring(len, len+1).toLowerCase()+kwd.substring(len+1);
              cp = ConfigParam.find(k, context);
              if (cp != null && cp.type == BOOLEAN_TYPE) {
                val = "false";
                break;
              }
            }
            prefix += "_";
            if (lcKwd.startsWith(prefix)) {
              String k = keep+kwd.substring(len);
              cp = ConfigParam.find(k, context);
              if (cp != null && cp.type == BOOLEAN_TYPE) {
                val = "false";
                break;
              }
            }
          }
//          if (lcKwd.startsWith("no")) {
//            int index = 2;
//            if (lcKwd.startsWith("not_")) {
//              index = 4;
//            } else if (lcKwd.startsWith("no_") || lcKwd.startsWith("not")) {
//              index = 3;
//            } else if (lcKwd.startsWith("dont_")) {
//              index = 5;
//            } else if (lcKwd.startsWith("do_not_")) {
//              index = 7;
//            }
//            kwd = kwd.substring(index);
//            cp = ConfigParam.find(kwd, context);
//            if (cp != null && cp.type == BOOLEAN_TYPE) {
//              val = "false";
//            }
//          }
        }
        if (cp == null) {
          errorLog.unknownParam(kwd, Source.COMMAND_LINE);
          continue;
        }
//        if (val == null && cp.type == BOOLEAN_TYPE) {
//          val = "true";
//        }

        try {
          if (val == null) {
            i++;
            if (i >= length) {
              if (cp.type == BOOLEAN_TYPE) {
                val = "true";
              } else {
                throw new ParamWithoutValError(cp);
              }
            } else {
              val = args[i];
            }
          }
          if (mod == null) {
            cp.readAndSet(val, Source.COMMAND_LINE);
          } else if (cp instanceof CollectionCP) {
            CollectionCP<?,?> ccp = (CollectionCP<?,?>)cp;
            switch (mod) {
            case "+":
              ccp.readAndAdd(val, Source.COMMAND_LINE);
              break;
            case "++":
              ccp.readAndAddAll(val, Source.COMMAND_LINE);
              break;
            case "-":
              ccp.readAndRemove(val, Source.COMMAND_LINE);
              break;
            case "--":
              ccp.readAndRemoveAll(val, Source.COMMAND_LINE);
              break;
            default:
              throw new IllegalStateException();
            }
//          } else if (cp.type() instanceof SeqType) {
          } else {
            throw new NotCollectionError(cp);
          }
        } catch (ReadError e) {
          if (cp.type == BOOLEAN_TYPE) {
            // We thought there might be a boolean param, but there wasn't
            i--;
            @SuppressWarnings("unchecked")
            ConfigParam<Boolean> bcp = (ConfigParam<Boolean>)cp;
            try {
              bcp.setVal(true, Source.COMMAND_LINE);
            } catch (IllegalValueException e1) {
              errorLog.noteError(cp, Source.COMMAND_LINE, e);
            }
          } else {
            errorLog.noteError(cp, Source.COMMAND_LINE, e);
          }
        } catch (IllegalValueException | NotCollectionError | ParamWithoutValError | ErrorDuringForce e) {
          errorLog.noteError(cp, Source.COMMAND_LINE, e);
        }
      } else if ((m = contextPat.matcher(arg)).matches()) {
        String contextName = m.group(1);
        RunContext rc = RunContext.find(contextName, true);
        if (rc == null) {
          errorLog.unknownContext(contextName, Source.COMMAND_LINE);
          continue;
        }
        rc.activate();
      } else {
        return i == 0 ? args : Arrays.copyOfRange(args, i, length);
      }
    }
    
    return new String[0];
  }

  public static void ensureSetUp(Collection<Class<?>> classes) {
    Set<Class<?>> seen = new IdentityHashSet<>();
    Queue<Class<?>> toDo = new LinkedList<>(classes);
    toDo.add(RunConfig.class);
    ensureSetUp(seen, toDo);
  }

  private static void ensureSetUp(Set<Class<?>> seen, Queue<Class<?>> toDo) {
    while (!toDo.isEmpty()) {
      Class<?> c = toDo.poll();
      if (seen.add(c)) {
        ensureSetUp(c, toDo);
      }
    }
  }

  private static void ensureSetUp(Class<?> c, Queue<Class<?>> toDo) {
    try {
      final Method method = c.getDeclaredMethod("ensureConfigParams");
      if (Modifier.isStatic(method.getModifiers())) {
        method.setAccessible(true);
        method.invoke(null);
      }
    } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
      // ignore
    }
    try {
      final Method method = c.getDeclaredMethod("runConfigDependencies");
      if (Modifier.isStatic(method.getModifiers())) {
        method.setAccessible(true);
        addDependencies(String.format("%s.runConfigDependencies()", c),
                        method.getReturnType(), method.getGenericReturnType(), new Accessor() {
          @Override
          public Object create() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
            return method.invoke(null);
          }
        }, toDo);
      }
    } catch (NoSuchMethodException | SecurityException e) {
      // ignore
    }
    try {
      final Field field = c.getDeclaredField("RUN_CONFIG_DEPENDENCIES");
      if (Modifier.isStatic(field.getModifiers())) {
        addDependencies(String.format("%s.RUN_CONFIG_DEPENDENCIES", c),
                        field.getType(), field.getGenericType(), new Accessor() {
          @Override
          public Object create() throws IllegalAccessException {
            field.setAccessible(true);
            return field.get(null);
          }
        }, toDo);
      }
    } catch (NoSuchFieldException | SecurityException e1) {
      // ignore
    }
    List<Field> paramFields = null;
    List<Field> runContextFields = null;
    final NullaryFunc<ArrayList<Field>> arrayListCreator = CollUtils.<Field>arrayListCreator();
    for (final Field field : c.getDeclaredFields()) {
      if (Modifier.isStatic(field.getModifiers())) {
        if (ConfigParam.class.isAssignableFrom(field.getType())) {
          paramFields = CollUtils.addTo(paramFields, field, arrayListCreator);
        }
        if (RunContext.class.isAssignableFrom(field.getType())) {
          runContextFields = CollUtils.addTo(runContextFields, field, arrayListCreator);
        }
      }
    }
    for (Field field : CollUtils.maybeNullList(runContextFields)) {
      forceInit(field);
    }
    for (Field field : CollUtils.maybeNullList(paramFields)) {
      forceInit(field);
    }
  }
  private static void forceInit(Field field) {
    field.setAccessible(true);
    try {
      @SuppressWarnings("unused")
      Object force = field.get(null);
    } catch (IllegalArgumentException | IllegalAccessException e) {
      // nothing we can do here.
    }
  }
  
  static interface Accessor {
    Object create() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException;
  }

  private static void addDependencies(String desc, Class<?> c, java.lang.reflect.Type gt, Accessor accessor, Queue<Class<?>> toDo) {
    if (c.isArray()) {
      Class<?> ec = c.getComponentType();
      if (!Class.class.isAssignableFrom(ec)) {
        logger.warn(String.format("WARNING: %s is of type %s[], ignoring%n", desc, ec));
      } else {
        try {
          Class<?>[] dependencies = (Class<?>[])accessor.create();
          toDo.addAll(Arrays.asList(dependencies));
        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
          logger.warn(String.format("WARNING: Couldn't access %s: %s, ignoring%n", desc, e.getMessage()));
        }
      }
    } else if (Collection.class.isAssignableFrom(c)) {
      Class<?> ec = Generics.collectionParam(gt, Collection.class);
      if (ec == null || !Class.class.isAssignableFrom(ec)) {
        logger.warn(String.format("WARNING: %s is of type %s, ignoring%n", desc, c));
      }
      try {
        @SuppressWarnings("unchecked")
        Collection<? extends Class<?>> dependencies = (Collection<? extends Class<?>>)accessor.create();
        toDo.addAll(dependencies);
      } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
        logger.warn(String.format("WARNING: Couldn't access %s: %s, ignoring%n", desc, e.getMessage()));
      }
    } else {
      logger.warn(String.format("WARNING: %s is of type %s, ignoring%n", desc, c));
    }
    
  }

  @SuppressWarnings("unused")
  private static void addDependencies(Field field, Class<?> c,
                                     Queue<Class<?>> toDo) 
  {
    field.setAccessible(true);
    Class<?> fc = field.getType();
    if (fc.isArray()) {
      Class<?> ec = fc.getComponentType();
      if (!Class.class.isAssignableFrom(ec)) {
        logger.warn(String.format("WARNING: %s.RUN_CONFIG_DEPENDENCIES is of type %s[], ignoring%n", c, ec));
      } else {
        try {
          Class<?>[] dependencies = (Class<?>[])field.get(null);
          toDo.addAll(Arrays.asList(dependencies));
        } catch (IllegalArgumentException | IllegalAccessException e) {
          logger.warn(String.format("WARNING: Couldn't access %s.RUN_CONFIG_DEPENDENCIES: %s, ignoring%n", c, e.getMessage()));
        }
      }
    } else if (Collection.class.isAssignableFrom(fc)) {
      Class<?> ec = Generics.collectionParam(field.getGenericType(), Collection.class);
      if (ec == null || !Class.class.isAssignableFrom(ec)) {
        logger.warn(String.format("WARNING: %s.RUN_CONFIG_DEPENDENCIES is of type %s, ignoring%n", c, fc));
      }
      try {
        Collection<? extends Class<?>> dependencies = (Collection<? extends Class<?>>)field.get(null);
        toDo.addAll(dependencies);
      } catch (IllegalArgumentException | IllegalAccessException e) {
        logger.warn(String.format("WARNING: Couldn't access %s.RUN_CONFIG_DEPENDENCIES: %s, ignoring%n", c, e.getMessage()));
      }
    } else {
      logger.warn(String.format("WARNING: %s.RUN_CONFIG_DEPENDENCIES is of type %s, ignoring%n", c, fc));
    }
  }

  public static <T> ConfigParam<T> param(RunContext context, PType<T> type, String name) {
    return context.param(type, name);
  }
  public static <T> ConfigParam<T> param(RunContext context, Class<T> type, String name) {
    return context.param(type, name);
  }
  public static <T> ConfigParam<List<T>> listParam(RunContext context, PType<T> type, String name) {
    return context.listParam(type, name);
  }
  public static <T> ConfigParam<List<T>> listParam(RunContext context, Class<T> type, String name) {
    return context.listParam(type, name);
  }
  public static <T> ConfigParam<Set<T>> setParam(RunContext context, PType<T> type, String name) {
    return context.setParam(type, name);
  }
  public static <T> ConfigParam<Set<T>> setParam(RunContext context, Class<T> type, String name) {
    return context.setParam(type, name);
  }
  public static <T> ConfigParam<T[]> arrayParam(RunContext context, PType<T> type, String name) {
    return context.arrayParam(type, name);
  }
  public static <T> ConfigParam<T[]> arrayParam(RunContext context, Class<T> type, String name) {
    return context.arrayParam(type, name);
  }
  public static <T extends Enum<T>> ConfigParam<EnumSet<T>> enumSetParam(RunContext context, PType<T> type, String name) {
    return context.enumSetParam(type, name);
  }
  public static <T extends Enum<T>> ConfigParam<EnumSet<T>> enumSetParam(RunContext context, Class<T> type, String name) {
    return context.enumSetParam(type, name);
  }
  public static <K,V> ConfigParam<Map<K,V>> mapParam(RunContext context, Class<K> keyType, Class<V> valType, String name) {
    return context.mapParam(keyType, valType, name);
  }
  public static <K,V> ConfigParam<Map<K,V>> mapParam(RunContext context, Class<K> keyType, PType<V> valType, String name) {
    return context.mapParam(keyType, valType, name);
  }
  public static <K,V> ConfigParam<Map<K,V>> mapParam(RunContext context, PType<K> keyType, Class<V> valType, String name) {
    return context.mapParam(keyType, valType, name);
  }
  public static <K,V> ConfigParam<Map<K,V>> mapParam(RunContext context, PType<K> keyType, PType<V> valType, String name) {
    return context.mapParam(keyType, valType, name);
  }

  public static <T> ConfigParam<T> param(PType<T> type, String name) {
    return param(RunContext.GLOBAL, type, name);
  }
  public static <T> ConfigParam<T> param(Class<T> type, String name) {
    return param(RunContext.GLOBAL, type, name);
  }
  public static <T> ConfigParam<List<T>> listParam(PType<T> type, String name) {
    return listParam(RunContext.GLOBAL, type, name);
  }
  public static <T> ConfigParam<List<T>> listParam(Class<T> type, String name) {
    return listParam(RunContext.GLOBAL, type, name);
  }
  public static <T> ConfigParam<Set<T>> setParam(PType<T> type, String name) {
    return setParam(RunContext.GLOBAL, type, name);
  }
  public static <T> ConfigParam<Set<T>> setParam(Class<T> type, String name) {
    return setParam(RunContext.GLOBAL, type, name);
  }
  public static <T> ConfigParam<T[]> arrayParam(PType<T> type, String name) {
    return arrayParam(RunContext.GLOBAL, type, name);
  }
  public static <T> ConfigParam<T[]> arrayParam(Class<T> type, String name) {
    return arrayParam(RunContext.GLOBAL, type, name);
  }
  public static <T extends Enum<T>> ConfigParam<EnumSet<T>> enumSetParam(PType<T> type, String name) {
    return enumSetParam(RunContext.GLOBAL, type, name);
  }
  public static <T extends Enum<T>> ConfigParam<EnumSet<T>> enumSetParam(Class<T> type, String name) {
    return enumSetParam(RunContext.GLOBAL, type, name);
  }
  public static <K,V> ConfigParam<Map<K,V>> mapParam(Class<K> keyType, Class<V> valType, String name) {
    return mapParam(RunContext.GLOBAL, keyType, valType, name);
  }
  public static <K,V> ConfigParam<Map<K,V>> mapParam(Class<K> keyType, PType<V> valType, String name) {
    return mapParam(RunContext.GLOBAL, keyType, valType, name);
  }
  public static <K,V> ConfigParam<Map<K,V>> mapParam(PType<K> keyType, Class<V> valType, String name) {
    return mapParam(RunContext.GLOBAL, keyType, valType, name);
  }
  public static <K,V> ConfigParam<Map<K,V>> mapParam(PType<K> keyType, PType<V> valType, String name) {
    return mapParam(RunContext.GLOBAL, keyType, valType, name);
  }


  public static void usage(NullaryFunc<?> creator) {
    usageCreator = creator;
  }
  
  public static void usage(String fmt, Object...args) {
    usage(Functions.always(String.format(fmt, args)));
  }
  
  public static void usage(SelfWrapping sw) {
    usage(Functions.always(sw));
  }
  
  private static void displayHelp() {
    int width = helpLineWidth.getVal();
    if (usageCreator != null) {
      Object usage = usageCreator.call();
      System.out.format("%s%n", Strings.wrap(usage, width));
    }
    EnumSet<HelpOption> opts = helpOptsParam.getVal();
    
    
    Set<FunctionReturnType> types = null;
    if (opts.contains(HelpOption.TYPES)) {
      types = new IdentityHashSet<>();
    }
    if (opts.contains(HelpOption.ONLY)) {
      dumpParamsParam.defaultVal(false);
      stopAfterParserParam.defaultVal(true);
    }
    displayParamHelp(width, opts, types);
//    displayTypeHelp(width, opts, types);
  }
  /*
  private static void displayTypeHelp(int width, EnumSet<HelpOption> opts, Set<FunctionReturnType> types) {
    if (types != null) {
      System.out.format("%nTypes:%n%n");
      boolean displayFuncs = opts.contains(HelpOption.FUNCTIONS);
      boolean displayEmpty = opts.contains(HelpOption.EMPTY);
      boolean displaySyntax = opts.contains(HelpOption.SYNTAX);
      boolean displaySubs = opts.contains(HelpOption.SUBTYPES);
      boolean displayConversions = opts.contains(HelpOption.CONVERSIONS);
      if (displaySyntax) {
        String overall = "All values (except for primitives inside primitive arrays) can be " +
        		"specified as \"null\" (without the quotes).  " +
        		"\n\n" +
        		"Sequences (arrays, lists, sets, etc.) " +
        		"are specified as comma-separated lists.  Sequences must be delimited by square brackets " +
        		"when not at top-level.  (Brackets are optional at top-level.)  " +
        		"EnumSets may be specified as \"all\", \"none\" or \"all but\", \"all except\" or \"not\" " +
        		"another set." +
        		"\n\n" +
        		"Values of parameters, including " +
        		"parameters whose values are not yet defined, are specified by preceding the name of the parameter " +
        		"(without the leading dash) by \"@\".";
        System.out.format("%s%n", Strings.wrap(overall, width));
      }
      Map<FunctionReturnType, Set<CFuncBase>> typeFuncs = collectFunctions(types);
      Map<FunctionReturnType, Set<FunctionReturnType>> subtypes = simplify(types, typeFuncs);
      SelfWrapping separator = Glossary.bar("-");
      Glossary g = new Glossary().sep(" : ").width(width).sorted(true).itemSep("=").borders("=");
      for (FunctionReturnType type : types) {
        List<Object> lines = new ArrayList<>();
        String name = type.toString();
        addLine(type.describe(), null, lines, separator);
        if (displaySyntax) {
          addLine(type.syntax(), "SYNTAX:", lines, separator);
        }
        if (displaySubs) {
          Set<FunctionReturnType> subs = subtypes.get(type);
          if (subs != null) {
            List<FunctionReturnType> list = new ArrayList<>(subs);
            Collections.sort(list, new Comparator<FunctionReturnType>() {
              @Override
              public int compare(FunctionReturnType o1, FunctionReturnType o2) {
                return o1.toString().compareToIgnoreCase(o2.toString());
              }
            });
            addLine(SeqFormatter.commaSpaceSep().format(list), "SUBTYPES:", lines, separator);
          }
        }
        if (displayConversions) {
          Set<FunctionReturnType> convertableFrom = ValueConverter.convertableTo(type);
          if (convertableFrom != null) {
            List<FunctionReturnType> list = new ArrayList<>();
            OUTER:
            for (FunctionReturnType t1 : types) {
              if (t1 == type || type.assignableFrom(t1)) {
                continue;
              }
              for (Type<?> t2 : convertableFrom) {
                if (t2.assignableFrom(t1)) {
                  list.add(t1);
                  continue OUTER;
                }
              }
            }
            if (!list.isEmpty()) {
              Collections.sort(list, new Comparator<FunctionReturnType>() {
                @Override
                public int compare(FunctionReturnType o1, FunctionReturnType o2) {
                  return o1.toString().compareToIgnoreCase(o2.toString());
                }});
              addLine(SeqFormatter.commaSpaceSep().format(list), "CONVERTABLE FROM:", lines, separator);
            }
          }
        }
        if (displayFuncs) {
          Collection<CFuncBase> funcs = typeFuncs.get(type);
          if (funcs != null) {
            final List<CFuncBase> list = new ArrayList<>(funcs);
            int nConstants = 0;
            for (CFuncBase f : list) {
              if (f.isConstant()) {
                nConstants++;
              }
            }
            Collections.sort(list, new Comparator<CFuncBase>() {
              @Override
              public int compare(CFuncBase o1, CFuncBase o2) {
                return o1.name.compareToIgnoreCase(o2.name);
              }});
            if (nConstants > 0) {
              addLine(funcListDesc(list, true), "CONSTANTS:", lines, separator);
            }
            if (nConstants < list.size()) {
              addLine(funcListDesc(list, false), "FUNCTIONS:", lines, separator);
            }
          }
        }
        if (displayEmpty || !lines.isEmpty()) {
          g.add(name, lines);
        }
      }
      System.out.println(g.format());
    }
    
  }
  */
  @SuppressWarnings("unused")
  private static Map<FunctionReturnType, Set<FunctionReturnType>> simplify(
      Set<FunctionReturnType> types, 
      Map<FunctionReturnType, Set<ConfigFunc>> typeFuncs) {
    Map<FunctionReturnType, List<FunctionReturnType>> allSubs = new IdentityHashMap<>();
    Map<FunctionReturnType, Set<FunctionReturnType>> map = new IdentityHashMap<>();
    final int n = types.size();
    SimpleType<?>[] array = types.toArray(new SimpleType[n]);
    for (int i=0; i<n; i++) {
      SimpleType<?> t1 = array[i];
      for (int j=i+1; j<n; j++) {
        SimpleType<?> t2 = array[j];
        if (t1.assignableFrom(t2)) {
          noteSubtype(t1, t2, allSubs);
        } else if (t2.assignableFrom(t1)) {
          noteSubtype(t2, t1, allSubs);
        }
      }
    }
    for (Entry<FunctionReturnType, List<FunctionReturnType>> entry : allSubs.entrySet()) {
      FunctionReturnType type = entry.getKey();
      Set<FunctionReturnType> subtypes = new IdentityHashSet<>(entry.getValue());
      map.put(type, subtypes);
      Set<ConfigFunc> funcs = typeFuncs.get(type);
      for (FunctionReturnType sub : entry.getValue()) {
        List<FunctionReturnType> further = allSubs.get(sub);
        if (further != null) {
          subtypes.removeAll(further);
        }
        Set<ConfigFunc> stFuncs = typeFuncs.get(sub);
        if (stFuncs != null) {
          funcs.removeAll(stFuncs);
        }
      }
    }
    return map;
  }
  private static void noteSubtype(
      SimpleType<?> superType,
      SimpleType<?> subType, Map<FunctionReturnType, List<FunctionReturnType>> allSubs) {
    List<FunctionReturnType> subs = allSubs.get(superType);
    if (subs == null) {
      subs = new ArrayList<>();
      allSubs.put(superType, subs);
    }
    subs.add(subType);
  }
  /*
  private static SelfWrapping funcListDesc(final List<CFuncBase> list,
      final boolean chooseConstants) {
    return new SelfWrapping() {
      @Override
      public String toWrappedString(int width) {
        int indent = 2;
        SeqFormatter<Object> sf = SeqFormatter.lines();
        for (CFuncBase f : list) {
          if (chooseConstants == f.isConstant()) {
            sf.add(Strings.wrap(f, width));
            String help = f.help(width-indent);
            if (help != null) {
              sf.add(Strings.indentLines(help, indent));
            }
          }
        }
        return sf.toString();
      }
    };
  }
  */
  @SuppressWarnings("unused")
  private static void addLine(final Object line, final String title, List<Object> lines,  SelfWrapping separator) {
    if (line != null) {
      if (separator != null && !lines.isEmpty()) {
        lines.add(separator);
      }
      if (title == null) {
        lines.add(line);
      } else {
        lines.add(new SelfWrapping() {
          @Override
          public String toWrappedString(int width) {
            int indent = 2;
            return Strings.wrap(title, width)+"\n"+Strings.indentLines(Strings.wrap(line, width-indent), indent);
          }});
      }
    }
  }
  
  /*
  private static Map<FunctionReturnType, Set<CFuncBase>> collectFunctions(Set<FunctionReturnType> types) {
    Map<FunctionReturnType, Set<CFuncBase>> typeFuncs = new HashMap<>();
    Queue<FunctionReturnType> toDo = new LinkedList<>(types);
    Set<FunctionReturnType> seen = new IdentityHashSet<>();
    while (!toDo.isEmpty()) {
      FunctionReturnType t = toDo.poll();
      if (seen.add(t)) {
        final Class<?> underlyingClass = t.underlyingClass();
        @SuppressWarnings("unchecked")
        Collection<CFuncBase> funcs = (Collection<CFuncBase>)(Collection<?>)ConfigFunc.listFuncs(underlyingClass);
        if (funcs != null) {
          typeFuncs.put(t, new IdentityHashSet<>(funcs));
          for (CFuncBase f : funcs) {
            for (Param<?> param : f.positional()) {
              param.type.addFunctionTypesTo(toDo);
            }
            for (Param<?> param : f.byKwd().values()) {
              param.type.addFunctionTypesTo(toDo);
            }
          }
        }
      }
    }
    return typeFuncs;
  }
  */
  private static void displayParamHelp(int width, EnumSet<HelpOption> opts,
                                       Set<FunctionReturnType> types) {
    boolean includeInactive = opts.contains(HelpOption.INACTIVE);
    boolean includeDefaults = opts.contains(HelpOption.DEFAULTS);
    boolean includeRestrictions = opts.contains(HelpOption.RESTRICTIONS);
    System.out.format("%nParams:%n");
    Map<RunContext, List<ConfigParam<?>>> map = AutoFill.hashMapToArrayList(RunContext.class, Types.<ConfigParam<?>>marker());
    for (Map<RunContext, ConfigParam<?>> m : ConfigParam.active.values()) {
      for (ConfigParam<?> cp : m.values()) {
        if (includeInactive || cp.context.isActive()) {
          map.get(cp.context).add(cp);
          if (types != null) {
            cp.type.addFunctionTypesTo(types);
          }
        }
      }
    }
    
    List<RunContext> ctxts = new ArrayList<>(map.keySet());
    Collections.sort(ctxts, new Comparator<RunContext>() {
      @Override
      public int compare(RunContext o1, RunContext o2) {
        if (o1.isGlobal()) {
          return o2.isGlobal() ? 0 : -1;
        }
        if (o2.isGlobal()) {
          return 1;
        }
        return o1.name.compareToIgnoreCase(o2.name);
      }});
    
    for (RunContext ctxt : ctxts) {
      System.out.format("[%s].%n", ctxt.name);
      Glossary<ConfigParam<?>> g = new Glossary<ConfigParam<?>>()
          .width(width)
          .fmtKey(new UnaryFunc<ConfigParam<?>, String>() {
            @Override
            public String call(ConfigParam<?> val) {
              return val.asSwitch();
            }
          })
          .itemSep("=").borders("=");
      List<ConfigParam<?>> list = map.get(ctxt);
      for (ConfigParam<?> cp : list) {
        List<Object> lines = new ArrayList<>();
        String t = cp.type.toString();
        if (includeDefaults) {
          t += String.format(" (Default = %s)", cp.formatDefault());
        }
        lines.add(t);
        if (cp.helpString != null) {
          if (!lines.isEmpty()) {
            lines.add(Glossary.bar("-"));
          }
          lines.add(cp.helpString);
        }
        if (includeRestrictions) {
          for (Interpreter<?> i : cp.interpreters()) {
            if (!lines.isEmpty()) {
              lines.add(Glossary.bar("-"));
            }
            lines.add(i.describe());
          }
          for (Restriction<?> r : cp.restrictions()) {
            if (!lines.isEmpty()) {
              lines.add(Glossary.bar("-"));
            }
            lines.add(r.describe());
          }
        }
        g.add(cp, lines);
      }
      System.out.format("%s%n", g.format());
    }
  }
  
  private static void dumpParams() {
    File f = dumpToParam.getVal();
    if (f != null) {
      try (PrintStream out = new PrintStream(f)) {
        dumpTo(out);
        return;
      } catch (FileNotFoundException e) {
        logger.warn(String.format("Couldn't dump params to %s, using terminal", f.getAbsoluteFile()), e);
      }
    }
    dumpTo(System.out);
  }
  
  private static void dumpTo(PrintStream out) {
    final int width = dumpLineWidth.getVal();
    final EnumSet<DumpOption> opts = dumpOptsParam.getVal();
    final boolean includeHelp = opts.contains(DumpOption.HELP);
    final boolean includeDefaults = opts.contains(DumpOption.DEFAULTS);
    final boolean includeSources = opts.contains(DumpOption.SOURCES);
    List<ConfigParam<?>> params = new ArrayList<>();
    Predicate<ConfigParam<?>> use = new Predicate<ConfigParam<?>>() {
      @Override
      public boolean test(ConfigParam<?> cp) {
        return cp.context.isActive() && (includeDefaults || cp.getSource().compareTo(Source.DEFAULT) > 0);
      }
    };
    for (Map<RunContext, ConfigParam<?>> m : ConfigParam.active.values()) {
      Chain.from(m).values().keep(use).into(params);
    }
    Comparator<ConfigParam<?>> cptr = new Comparator<ConfigParam<?>>() {
      
      @Override
      public int compare(ConfigParam<?> o1, ConfigParam<?> o2) {
        int val = o1.context==o2.context ? 0 : 
          o1.context==RunContext.GLOBAL ? -1 : 
            o2.context==RunContext.GLOBAL ? 1 : 
              o1.context.name.compareToIgnoreCase(o2.context.name);
        if (val == 0) {
          val = o1.name.compareToIgnoreCase(o2.name);
        }
        return val;
      }
    };
    boolean firstLineInFile = true;
    LineWrapper helpWrapper = new LineWrapper(width).prefix("# ");
    Collections.sort(params, cptr);
    for (ConfigParam<?> cp : params) {
      boolean firstLineInParam = true;
      if (cp.helpString != null && includeHelp) {
        if (!firstLineInFile) {
          out.println();
        }
        out.format("%s%n", helpWrapper.wrap(cp.helpString));
        firstLineInFile = false;
        firstLineInParam = false;
      }
      if (includeSources) {
        if (!firstLineInFile && firstLineInParam) {
          out.println();
        }
        out.format("%s%n", helpWrapper.wrap("Source: "+cp.getSource()));
        firstLineInFile = false;
        firstLineInParam = false;
      }
      firstLineInFile = false;
      String left = String.format("%s.%s: ", cp.context.name, cp.name);
      out.format("%s%n", LineWrapper.wrapLines(cp.formatVal(), width, left));
    }
  }

}
