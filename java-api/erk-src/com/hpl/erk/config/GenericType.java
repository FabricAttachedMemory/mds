/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.config;


import java.util.Collection;

import com.hpl.erk.config.GenericCache.Factory;
import com.hpl.erk.config.PType.Sig;
import com.hpl.erk.config.func.Param;
import com.hpl.erk.config.type.CollType;
import com.hpl.erk.config.type.EnumSetType;
import com.hpl.erk.config.type.ListType;
import com.hpl.erk.config.type.OneArgCompositeType;
import com.hpl.erk.config.type.SetType;
import com.hpl.erk.config.type.TwoArgCompositeType;
import com.hpl.erk.types.GenericTypeToken;
import com.hpl.erk.types.TypeToken;

public abstract class GenericType<GT> implements FunctionReturnType {
  protected final GenericTypeToken generic;
  public static final GenericCache cache = new GenericCache();
  
  static {
    ListType.generic().register();
    SetType.generic().register();
    EnumSetType.generic().register();
  }
  
  protected GenericType(GenericTypeToken generic) {
    this.generic = generic;
  }

  public abstract <T extends GT> PType<T> concreteType(Sig<T> sig, PType<?>...bounds);
  public abstract <T extends GT> PType<T> makeNew(Sig<T> sig, TypeToken token, PType<?>...bounds);

//  public static class Template extends TypeBase {
//    private final GenericType<?> generic;
//    private final List<TypeBase> parameters;
//    
//    protected Template(GenericType<?> generic, List<TypeBase> parameters) {
//      this.generic = generic;
//      this.parameters = parameters;
//    }
//
//    @Override
//    public Type<? extends Object> reify(List<Type<?>> bindings) {
//      List<Type<?>> args = new ArrayList<>(bindings.size());
//      for (TypeBase p : parameters) {
//        args.add(p.reify(bindings));
//      }
//      return generic.concreteType(args);
//    }
//  }
  
  
  
//  public Template template(List<TypeBase> parameters) {
//    return new Template(this, parameters);
//  }
  
  public class CFunc extends GenericFunc<GT> {
    public CFunc(String name, Registration reg, Param... params) {
      super(name, GenericType.this, params);
    }
    
    public CFunc(String name, Param...params) {
      this(name, Registration.REGISTERED, params);
    }
  }
  
    
  
  @Override
  public String toString() {
    return generic.toString();
  }
  
  
  @Override
  public String syntax() {
    return null;
  }
  
  @Override
  public String describe() {
    return null;
  }
  
  public void register() {
    cache.cache(generic, this);
  }
  
  public TypeToken token(PType<?> ...types) {
    final int n = types.length;
    TypeToken[] tokens = new TypeToken[n];
    for (int i=0; i<n; i++) {
      tokens[i] = types[i].typeToken;
    }
    return token(tokens);
  }

  
  public TypeToken token(TypeToken[] tokens) {
    return TypeToken.find(generic, tokens);
  }

  public static <T> GenericType<T> of(final Class<T> clss) {
    final GenericTypeToken token = TypeToken.generic(clss);
    return of(token);
  }
  


  public static <T> GenericType<T> of(final GenericTypeToken token) {
    final Factory<T> factory = new Factory<T>() {
      @Override
      public GenericType<T> create() {
        switch (token.arity()) {
        case 1:
          if (Collection.class.isAssignableFrom(token.rawClass())) {
            Class<? extends Collection<?>> cClass = (Class<? extends Collection<?>>)token.rawClass();
            return newCollectionGeneric(cClass, token);
          }
          return new OneArgCompositeType.Generic<T,Object>(token);
        case 2:
          return new TwoArgCompositeType.Generic<T,Object,Object>(token);
        }
        throw new IllegalArgumentException(String.format("Don't (yet) know how to make %,d-argument generic %s", token.arity(), token));
      }

      private <U extends Collection<?>> GenericType<T> newCollectionGeneric(Class<U> cClass, GenericTypeToken token) {
        @SuppressWarnings("unchecked")
        final GenericType<T> type = (GenericType<T>)new CollType.Generic<U, Object>(token);
        return type;
      }
    };
    return of(token, factory);
  }
  
  public static <T> GenericType<T> of(GenericTypeToken token, final Factory<T> factory) {
    return cache.lookup(token, factory);
  }


}
