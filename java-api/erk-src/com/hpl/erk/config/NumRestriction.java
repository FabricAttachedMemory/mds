/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.config;

import com.hpl.erk.config.ex.RestrictionFailed;


public class NumRestriction {
  
  
  public static Restriction<Number> gt(final Number min) {
    return new Restriction<Number>() {
      @Override
      public boolean checkVal(Number val) {
        return val.doubleValue() > min.doubleValue();
      }

      @Override
      public String describe() {
        return String.format("Must be > %s", min);
      }
    };
  }
  public static Restriction<Number> ge(final Number min) {
    return new Restriction<Number>() {
      @Override
      public boolean checkVal(Number val) {
        return val.doubleValue() >= min.doubleValue();
      }

      @Override
      public String describe() {
        return String.format("Must be >= %s", min);
      }
    };
  }
  public static Restriction<Number> lt(final Number max) {
    return new Restriction<Number>() {
      @Override
      public boolean checkVal(Number val) {
        return val.doubleValue() < max.doubleValue();
      }

      @Override
      public String describe() {
        return String.format("Must be < %s", max);
      }
    };
  }
  public static Restriction<Number> le(final Number max) {
    return new Restriction<Number>() {
      @Override
      public boolean checkVal(Number val) {
        return val.doubleValue() <= max.doubleValue();
      }

      @Override
      public String describe() {
        return String.format("Must be <= %s", max);
      }
    };
  }
  public static Restriction<Number> ne(final Number n) {
    return new Restriction<Number>() {
      @Override
      public boolean checkVal(Number val) {
        return val.doubleValue() != n.doubleValue();
      }

      @Override
      public String describe() {
        return String.format("Must be != %s", n);
      }
    };
  }
  public static Restriction<Number> non_zero() {
    return ne(0.0);
  }
  public static Restriction<Number> positive() {
    return gt(0.0);
  }
  public static Restriction<Number> non_negative() {
    return ge(0.0);
  }
  public static Restriction<Number> negative() {
    return lt(0.0);
  }
  public static Restriction<Number> non_positive() {
    return le(0.0);
  }
  public static Restriction<Number> in_range(final Number min, final boolean includeMin, final Number max, final boolean includeMax) {
    return new Restriction<Number>() {
      @Override
      public String describe() {
        return String.format("Must be in %s%s,%s%s",
                             (includeMin ? "[" : "("),
                             (min == null ? "" : min),
                             (max == null ? "" : max),
                             (includeMax ? "]" : ")"));
      }
      
      @Override
      public boolean checkVal(Number val) throws RestrictionFailed {
        if (min != null) {
          if (includeMin) {
            if (val.doubleValue() < min.doubleValue()) {
              return false;
            }
          } else {
            if (val.doubleValue() <= min.doubleValue()) {
              return false;
            }
          }
        }
        if (max != null) {
          if (includeMax) {
            if (val.doubleValue() > max.doubleValue()) {
              return false;
            }
          } else {
            if (val.doubleValue() >= max.doubleValue()) {
              return false;
            }
          }
        }
        return true;
      }
    };
  }
  
  /**
   * in (inclusive, inclusive) range [min,max] 
   */
  public static Restriction<Number> in_range_ii(final Number min, final Number max) {
    return in_range(min, true, max, true);
  }
  /**
   * in (inclusive, exclusive) range [min,max) 
   */
  public static Restriction<Number> in_range_ie(final Number min, final Number max) {
    return in_range(min, true, max, false);
  }
  /**
   * in (exclusive, inclusive) range (min,max] 
   */
  public static Restriction<Number> in_range_ei(final Number min, final Number max) {
    return in_range(min, false, max, true);
  }
  /**
   * in (exclusive, exclusive) range (min,max) 
   */
  public static Restriction<Number> in_range_ee(final Number min, final Number max) {
    return in_range(min, false, max, false);
  }
  
  public static Restriction<Number> integer() {
    return new Restriction<Number>() {
      
      @Override
      public String describe() {
        return "Must be an integer";
      }
      
      @Override
      public boolean checkVal(Number val) throws RestrictionFailed {
        return val.doubleValue() == val.longValue();
      }
    };
  }
  
  public static Restriction<Number> finite() {
    return new Restriction<Number>() {
      @Override
      public String describe() {
        return "Must be finite";
      }
      
      @Override
      public boolean checkVal(Number val) throws RestrictionFailed {
        return Double.isInfinite(val.doubleValue());
      }
    };
  }
  public static Restriction<Number> infinite() {
    return new Restriction<Number>() {
      @Override
      public String describe() {
        return "Must be finite";
      }
      
      @Override
      public boolean checkVal(Number val) throws RestrictionFailed {
        return Double.isInfinite(val.doubleValue());
      }
    };
  }
  
  public static Restriction<Number> not_NaN() {
    return new Restriction<Number>() {
      @Override
      public String describe() {
        return "Must not be NaN";
      }
      
      @Override
      public boolean checkVal(Number val) throws RestrictionFailed {
        return !Double.isNaN(val.doubleValue());
      }
    };
  }
  
  public static Restriction<Number> even() {
    return new Restriction<Number>() {
      
      @Override
      public String describe() {
        return "Must be an even integer";
      }
      
      @Override
      public boolean checkVal(Number val) throws RestrictionFailed {
        long n = val.longValue();
        return n%2 == 0 && n == val.doubleValue();
      }
    };
  }
  public static Restriction<Number> odd() {
    return new Restriction<Number>() {
      
      @Override
      public String describe() {
        return "Must be an odd integer";
      }
      
      @Override
      public boolean checkVal(Number val) throws RestrictionFailed {
        long n = val.longValue();
        return n%2 == 1 && n == val.doubleValue();
      }
    };
  }
  public static Restriction<Number> prime() {
    return new Restriction<Number>() {
      
      @Override
      public String describe() {
        return "Must be a prime integer (>=2)";
      }
      
      @Override
      public boolean checkVal(Number val) throws RestrictionFailed {
        long v = val.longValue();
        if (v<2 || v != val.doubleValue()) return false;
        for (long i = 2, end = (long) Math.floor(Math.sqrt(v)); i <= end; i++) {
            if (v%i == 0) return false;
        }
        return true;
      }
    };
  }
  public static Restriction<Number> power_of_2() {
    return new Restriction<Number>() {
      
      @Override
      public String describe() {
        return "Must be a positive integral power of 2 or zero";
      }
      
      @Override
      public boolean checkVal(Number val) throws RestrictionFailed {
        long v = val.longValue();
        return v == val.doubleValue() && (v == 0 || (v & (v-1))==0);
      }
    };
  }
  
  public static Restriction<Number> power_of(final Number base) {
    if (base.doubleValue() <= 1) {
      throw new IllegalArgumentException(String.format("Base was %s, must be > 1", base));
    }
    if (base.doubleValue() == 2) {
      return power_of_2();
    }
    return new Restriction<Number>() {
      
      @Override
      public String describe() {
        return String.format("Must be a positive integral power of %s or zero", base);
      }
      
      @Override
      public boolean checkVal(Number val) throws RestrictionFailed {
        double n = val.doubleValue();
        if (n == 0 ) {
          return true;
        }
        final double b = base.doubleValue();
        for (double d = 1.0; d <= n; d *= b) {
          if (d == n) {
            return true;
          }
        }
        return false;
      }
    };
  }
  
  public static Restriction<Number> multiple_of(final Number n) {
    return new Restriction<Number>() {
      
      @Override
      public String describe() {
        return String.format("Must be an integral multiple of %s", n);
      }
      
      @Override
      public boolean checkVal(Number val) throws RestrictionFailed {
        double v = val.doubleValue();
        double m = v/n.doubleValue();
        return m == (int)m;
      }
    };
  }
  public static Restriction<Number> power_of_10() {
    return power_of(10);
  }
  
  public static Restriction<Number> percentage_100() {
    return in_range(0.0, true, 100.0, true);
  }
  public static Restriction<Number> percentage_01() {
    return in_range(0.0, true, 1.0, true);
  }
  
}
