/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.config.type;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import com.hpl.erk.ReadableString;
import com.hpl.erk.config.DelayedVal;
import com.hpl.erk.config.FunctionReturnType;
import com.hpl.erk.config.PType;
import com.hpl.erk.config.ReadDelayedVal;
import com.hpl.erk.config.TypeCache.Factory;
import com.hpl.erk.config.ex.IllegalValueException;
import com.hpl.erk.config.ex.ReadError;
import com.hpl.erk.formatters.SeqFormatter;
import com.hpl.erk.types.TypeToken;

public class ArrayType<T> extends PType<T[]> implements SeqType<T[], T> {
  private final PType<T> eltType;

  static interface TerminationCriteria {
    boolean done(ReadableString input);
  }

  protected ArrayType(PType<T> eltType) {
    super(TypeToken.findArray(eltType.typeToken));
    this.eltType = eltType;
  }
  
  public static <T> PType<T[]> of(final PType<T> eltType) {
    TypeToken token = TypeToken.findArray(eltType.typeToken);
    return PType.of(token, new Factory<T[]>() {
      @Override
      public PType<T[]> create() {
        return new ArrayType<>(eltType);
      }});
  }

  @Override
  public void addFunctionTypesTo(Collection<FunctionReturnType> types) {
    super.addFunctionTypesTo(types);
    eltType.addFunctionTypesTo(types);
  }

  @Override
  public List<PType<?>> bindings() {
    return eltType.bindings();
  }

  @Override
  public Collection<T> asCollection(T[] composite) {
    return Arrays.asList(composite);
  }

  @Override
  public T[] copyFrom(Collection<? extends T> val) {
    ArrayList<T> list = new ArrayList<>(val);
    T[] array = list.toArray(makeArray(list.size()));
    return array;
  }
  
  private T[] makeArray(final int size) {
    T[] array = (T[])Array.newInstance(eltType.typeToken.rawClass(), size);
    return array;
  }


  @Override
  public PType<T> elementType() {
    return eltType;
  }

  @Override
  public TypeToken typeToken() {
    return typeToken;
  }

  @Override
  public PType<T[]> asType() {
    return this;
  }
  
  @Override
  public T[] readVal(ReadableString input, final String valTerminators) throws ReadError, ReadDelayedVal {
    int resetTo = input.getCursor();
    input.skipWS();
    if (input.consume("[")) {
      return readSequence(input, resetTo, new TerminationCriteria() {
        @Override
        public boolean done(ReadableString input) {
          return input.consume("]");
        }});
    }
    if (!valTerminators.contains(",")) {
      return readSequence(input, resetTo, new TerminationCriteria() {
        @Override
        public boolean done(ReadableString input) {
          return input.atEnd() || input.atAny(valTerminators);
        }
      });
    }
    throw new ReadError(input, resetTo, this, "Not a sequence");
  }
  


  protected T[] readSequence(ReadableString input, int resetTo, TerminationCriteria term) throws ReadError, ReadDelayedVal {
    input.skipWS();
    ArrayList<T> list = new ArrayList<>();
    if (input.consume("]")) {
      return makeArray(0);
    }
    boolean first = true;
    Map<Integer, DelayedVal<? extends T>> delayedVals = null;
    while (!term.done(input)) {
      if (!first) {
        if (!input.consume(",")) {
          throw new ReadError(input, resetTo, this, "Expected a comma after element %,d", list.size());
        }
      }
      input.skipWS();
      T elt;
      try {
        elt = eltType.read(input, ",]");
      } catch (ReadDelayedVal e) {
        if (delayedVals == null) {
          delayedVals = new HashMap<>();
        }
        delayedVals.put(list.size(), e.<T>delayedVal());
        elt = null;
      }
      list.add(elt);
      input.skipWS();
      first = false;
    }
    final T[] array = makeArray(list.size());
    final T[] val = list.toArray(array);
    if (delayedVals == null) {
      return val;
    }
    final Map<Integer, DelayedVal<? extends T>> map = delayedVals;
    List<String> desc = new ArrayList<>(val.length);
    for (T elt : val) {
      desc.add(eltType.format(elt));
    }
    for (Entry<Integer, DelayedVal<? extends T>> entry : map.entrySet()) {
      desc.set(entry.getKey(), entry.getValue().desc);
    }
    throw new ReadDelayedVal(new DelayedVal<T[]>(String.format("%s", desc)) {
      @Override
      public T[] force() throws IllegalValueException {
        for (Entry<Integer, DelayedVal<? extends T>> entry : map.entrySet()) {
          final int i = entry.getKey();
          final DelayedVal<? extends T> dv = entry.getValue();
          val[i] = dv.force();
        }
        return val;
      }});
  }
  
  @Override
  public String toString() {
    return String.format("%s[]", eltType);
  }

  public String format(T[] val) {
    if (val == null) {
      return "null";
    }
    SeqFormatter<String> sf = SeqFormatter.bracketList();
    for (T elt : val) {
      sf.add(eltType.format(elt));
    }
    return sf.toString();
  };

}
