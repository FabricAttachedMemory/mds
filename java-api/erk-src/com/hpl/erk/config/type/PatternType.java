/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.config.type;

import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import com.hpl.erk.ReadableString;
import com.hpl.erk.TrueOnce;
import com.hpl.erk.config.DelayedVal;
import com.hpl.erk.config.PType;
import com.hpl.erk.config.ReadDelayedVal;
import com.hpl.erk.config.ex.IllegalValueException;
import com.hpl.erk.config.ex.ReadError;
import com.hpl.erk.config.func.ArgSet;
import com.hpl.erk.config.func.Param;

public class PatternType extends SimpleType<Pattern> {
  PatternType() {
    super(Pattern.class);
  }

  @Override
  public Pattern read(ReadableString input, String valTerminators) throws ReadDelayedVal, ReadError {
    int resetTo = input.getCursor();
    PType<String> stringType = PType.of(String.class);
    try {
      String s = stringType.read(input, valTerminators);
      return Pattern.compile(s);
    } catch (ReadDelayedVal e) {
      final DelayedVal<? extends String> stringDV = e.delayedVal();
      DelayedVal<Pattern> dv = new DelayedVal<Pattern>(stringDV.desc) {
        @Override
        public Pattern force() throws IllegalValueException {
          String s = stringDV.force();
          try {
            return Pattern.compile(s);
          } catch (PatternSyntaxException e) {
            throw new IllegalValueException("Error compiling pattern", e);
          }
        }
      }; 
      throw new ReadDelayedVal(dv);
    } catch (PatternSyntaxException e) {
      throw new ReadError(input, resetTo, this, "Pattern syntax error: %s", e.getMessage());
    }
  }


  private static final TrueOnce needInit = new TrueOnce();
  public static void ensureConfigParams() {
    if (!needInit.check()) {
      return;
    }
    
    final PType<Pattern> type = PType.of(Pattern.class);
    
    type.new ConversionFrom<String>(PType.of(String.class)) {
      @Override
      public Pattern convert(String regexp) {
        return regexp==null ? null : Pattern.compile(regexp);
      }
    }.register();
    
    type.new CFunc("ci",
        Param.req("re", PType.of(String.class))) {
          @Override
          public Pattern make(ArgSet args) throws MFailed {
            String s = args.<String>get("re");
            try {
              return Pattern.compile(s, Pattern.CASE_INSENSITIVE);
            } catch (PatternSyntaxException e) {
              throw new MFailed(this, args, e.getMessage());
            }
          }
    };
    
    type.new CFunc("re",
        Param.req("re", String.class),
        Param.kwd("unix_lines", boolean.class, false),
        Param.kwd("case_insensitive", boolean.class, false),
        Param.kwd("multiline", boolean.class, false),
        Param.kwd("literal", boolean.class, false),
        Param.kwd("dotall", boolean.class, false),
        Param.kwd("unicode_case", boolean.class, false),
        Param.kwd("canon_eq", boolean.class, false),
        Param.kwd("unicode_char_class", boolean.class, false)) {
          @Override
          public Pattern make(ArgSet args) throws MFailed {
            String s = args.<String>get("re");
            int flags = 0;
            flags = addFlag(args, flags, "unix_lines", Pattern.UNIX_LINES);
            flags = addFlag(args, flags, "case_insensitive", Pattern.CASE_INSENSITIVE);
            flags = addFlag(args, flags, "multiline", Pattern.MULTILINE);
            flags = addFlag(args, flags, "literal", Pattern.LITERAL);
            flags = addFlag(args, flags, "dotall", Pattern.DOTALL);
            flags = addFlag(args, flags, "unicode_case", Pattern.UNICODE_CASE);
            flags = addFlag(args, flags, "canon_eq", Pattern.CANON_EQ);
            flags = addFlag(args, flags, "unicode_char_class", Pattern.UNICODE_CHARACTER_CLASS);
            try {
              return Pattern.compile(s, flags);
            } catch (PatternSyntaxException e) {
              throw new MFailed(this, args, e.getMessage());
            }
          }

          private int addFlag(ArgSet args, int flags, final String argName,
                              final int flag) 
          {
            return args.<Boolean>get(argName) ? flags | flag : flags;
          }
    };
  }
  
  

}
