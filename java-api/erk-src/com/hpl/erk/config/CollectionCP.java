/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.config;

import java.util.Collection;

import com.hpl.erk.config.ex.IgnoreableIllegalValueException;
import com.hpl.erk.config.ex.IllegalValueException;
import com.hpl.erk.config.ex.ReadError;
import com.hpl.erk.config.type.CollType;


public class CollectionCP<ET, T extends Collection<ET>> extends ConfigParam<T> {
  protected final PType<? extends ET> eltType;
  protected final CollType<ET, T> collType;
//  protected final CollectionType<ET, ? extends T> collType;

  public CollectionCP(RunContext context, String name, PType<T> type, PType<? extends ET> eltType) {
    super(context, name, type);
    this.eltType = eltType;
    @SuppressWarnings("unchecked")
    final CollType<ET, T> downcast = (CollType<ET,T>)type;
    this.collType = downcast;
  }


  private abstract class Modifier {
    abstract boolean modify(T collection, ET elt);
  }
  
  private void modify(ET elt, final Source newSource, Modifier modifier) throws IllegalValueException {
    if (source.compareTo(newSource) > 0) {
      return;
    }
    if (val == null) {
      val = collType.createEmpty();
    }
    try {
      elt = modifyElement(elt);
      if (delayedVal != null) {
        final ET adding = elt;
        delayedVal = modify(new DelayedVal<ET>(String.format("%s", elt)) {
          @Override
          public ET force() {
            return adding;
          }
        }, delayedVal, newSource, modifier);
        return;
      }
      if (modifier.modify(val,elt)) {
        if (storage != null) {
          storage.store(val);
        }
      }
      source = newSource;
    } catch (IgnoreableIllegalValueException e) {
      return;
    }
  }

  private void modify(final DelayedVal<? extends ET> delayedElt, final Source newSource, Modifier modifier) {
    if (source.compareTo(newSource) > 0) {
      return;
    }
    if (val == null) {
      val = collType.createEmpty();
    }
    delayedVal = modify(delayedElt, delayedVal != null ? delayedVal : new DelayedVal<T>(String.format("%s+%s",val,delayedElt.desc)){
      @Override
      public T force() {
        return val == null ? collType.createEmpty() : val;
      }
    }, newSource, modifier);
  }
  private DelayedVal<? extends T> modify(final DelayedVal<? extends ET> delayedElt,
                                         final DelayedVal<? extends T> delayedVal,
                                         final Source source, 
                                         final Modifier modifier) {
    return new DelayedVal<T>(String.format("%s+%s", delayedVal.desc, delayedElt.desc)) {
      @Override
      public T force() throws IllegalValueException {
        T val = delayedVal.force();
        try {
          ET elt = delayedElt.force();
          elt = modifyElement(elt);
          if (modifier.modify(val, elt)) {
            setVal(val, source);
          }
        } catch (IgnoreableIllegalValueException e) {
          // ignore
        }
        return val;
      }};
  }

  private void modifyMultiple(final Collection<? extends ET> elts, final Source newSource, Modifier modifier) throws IllegalValueException {
    if (source.compareTo(newSource) > 0) {
      return;
    }
    if (val == null) {
      val = collType.createEmpty();
    }
    try {
      if (delayedVal != null) {
        delayedVal = modifyMultiple(new DelayedVal<Collection<? extends ET>>(String.format("%s", elts)) {
          @Override
          public Collection<? extends ET> force() {
            return elts;
          }
        }, delayedVal, newSource, modifier);
        return;
      }
      boolean changed = false;
      for (ET elt : elts) {
        try {
          elt = modifyElement(elt);
        } catch (IgnoreableIllegalValueException e) {
          // ignore
        }
        if (modifier.modify(val, elt)) {
          changed = true;
        }
      }
      if (changed) {
        if (storage != null) {
          storage.store(val);
        }
      }
      source = newSource;
    } catch (IgnoreableIllegalValueException e) {
      return;
    }
  }

  private void modifyMultiple(final DelayedVal<? extends Collection<? extends ET>> delayedElt, final Source newSource, Modifier modifier) {
    if (source.compareTo(newSource) > 0) {
      return;
    }
    if (val == null) {
      val = collType.createEmpty();
    }
    delayedVal = modifyMultiple(delayedElt, delayedVal != null ? delayedVal : new DelayedVal<T>(String.format("%s+%s",val,delayedElt.desc)){
      @Override
      public T force() {
        return val == null ? collType.createEmpty() : val;
      }
    }, newSource, modifier);
  }
  private DelayedVal<? extends T> modifyMultiple(final DelayedVal<? extends Collection<? extends ET>> delayedElt,
                                                                  final DelayedVal<? extends T> delayedVal,
                                                                  final Source source, 
                                                                  final Modifier modifier) {
    return new DelayedVal<T>(String.format("%s+%s", delayedVal.desc, delayedElt.desc)) {
      @Override
      public T force() throws IllegalValueException {
        T val = delayedVal.force();
        try {
          Collection<? extends ET> coll = delayedElt.force();
          boolean change = false;
          for (ET elt : coll) {
            elt = modifyElement(elt);
            if (modifier.modify(val, elt)) {
              change = true;
            }
          }
          if (change) {
            setVal(val, source);
          }
        } catch (IgnoreableIllegalValueException e) {
          // ignore
        }
        return val;
      }};
  }


  public void addElement(ET elt, Source newSource) throws IllegalValueException {
    Modifier modifier = new Modifier() {
      @Override
      boolean modify(T collection, ET elt) {
        return collection.add(elt);
      }
    };
    modify(elt, newSource, modifier);
  }
  
  public void addElement(DelayedVal<? extends ET> delayedElt, Source newSource) {
    Modifier modifier = new Modifier() {
      @Override
      boolean modify(T collection, ET elt) {
        return collection.add(elt);
      }
    };
    modify(delayedElt, newSource, modifier);
  }
  public void removeElement(ET elt, Source newSource) throws IllegalValueException {
    Modifier modifier = new Modifier() {
      @Override
      boolean modify(T collection, ET elt) {
        return collection.remove(elt);
      }
    };
    modify(elt, newSource, modifier);
  }
  
  public void removeElement(DelayedVal<? extends ET> delayedElt, Source newSource) {
    Modifier modifier = new Modifier() {
      @Override
      boolean modify(T collection, ET elt) {
        return collection.remove(elt);
      }
    };
    modify(delayedElt, newSource, modifier);
  }

  public void addElements(Collection<? extends ET> elts, Source newSource) throws IllegalValueException {
    Modifier modifier = new Modifier() {
      @Override
      boolean modify(T collection, ET elt) {
        return collection.add(elt);
      }
    };
    modifyMultiple(elts, newSource, modifier);
  }

  public void addElements(DelayedVal<? extends Collection<? extends ET>> elts, Source newSource) {
    Modifier modifier = new Modifier() {
      @Override
      boolean modify(T collection, ET elt) {
        return collection.add(elt);
      }
    };
    modifyMultiple(elts, newSource, modifier);
  }

  public void removeElements(Collection<? extends ET> elts, Source newSource) throws IllegalValueException {
    Modifier modifier = new Modifier() {
      @Override
      boolean modify(T collection, ET elt) {
        return collection.remove(elt);
      }
    };
    modifyMultiple(elts, newSource, modifier);
  }

  public void removeElements(DelayedVal<? extends Collection<? extends ET>> elts, Source newSource) {
    Modifier modifier = new Modifier() {
      @Override
      boolean modify(T collection, ET elt) {
        return collection.remove(elt);
      }
    };
    modifyMultiple(elts, newSource, modifier);
  }


  /**
   * @throws IllegalValueException when the value isn't legal and can't be 
   * coerced to be legal.  
   */
  protected ET modifyElement(ET newVal) throws IllegalValueException {
    return newVal;
  }
  
  public void readAndAdd(String s, Source newSource) throws ReadError, IllegalValueException {
    try {
      final ET elt = eltType.read(s);
      addElement(elt, newSource);
    } catch (ReadDelayedVal e) {
      addElement(e.<ET>delayedVal(), newSource);
    }
  }
  public void readAndRemove(String s, Source newSource) throws ReadError, IllegalValueException {
    try {
      final ET elt = eltType.read(s);
      removeElement(elt, newSource);
    } catch (ReadDelayedVal e) {
      removeElement(e.<ET>delayedVal(), newSource);
    }
  }
  public void readAndAddAll(String s, Source newSource) throws ReadError, IllegalValueException {
    try {
      final T elts = type.read(s);
      addElements(elts, newSource);
    } catch (ReadDelayedVal e) {
      addElements(e.<T>delayedVal(), newSource);
    }
  }
  public void readAndRemoveAll(String s, Source newSource) throws ReadError, IllegalValueException {
    try {
      final T elts = type.read(s);
      removeElements(elts, newSource);
    } catch (ReadDelayedVal e) {
      removeElements(e.<T>delayedVal(), newSource);
    }
  }
  
  public CollectionCP<ET, T> defaultVal(T defaultVal) {
    super.defaultVal(defaultVal);
    return this;
  };
  
  @Override
  public CollectionCP<ET, T> help(String helpString, Object...fmtArgs) {
    super.help(helpString, fmtArgs);
    return this;
  }


}
