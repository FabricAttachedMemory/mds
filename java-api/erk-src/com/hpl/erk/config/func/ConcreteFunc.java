/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.config.func;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.hpl.erk.ReadableString;
import com.hpl.erk.adt.IdentityHashSet;
import com.hpl.erk.config.DelayedVal;
import com.hpl.erk.config.PType;
import com.hpl.erk.config.ReadDelayedVal;
import com.hpl.erk.config.ValueConverter;
import com.hpl.erk.config.ex.ExpectedParamsError;
import com.hpl.erk.config.ex.IllegalValueException;
import com.hpl.erk.config.ex.ReadError;
import com.hpl.erk.config.func.Param.Kind;
import com.hpl.erk.util.CollUtils;
import com.hpl.erk.util.IterUtils;

public abstract class ConcreteFunc<T> extends ConfigFunc {
  private static Map<String, Set<ConcreteFunc<?>>> cfuncs = new HashMap<>();

  public abstract T make(ArgSet args) throws MFailed;
  public abstract PType<T> type();
  
  private ConcreteFunc(String name, Registration reg, Param...params) {
    super(name, params);
    String normalizedName = normalize(name);
    if (reg == Registration.REGISTERED) {
      Set<ConcreteFunc<?>> known = cfuncs.get(normalizedName);
      if (known == null) {
        known = new IdentityHashSet<>();
        cfuncs.put(normalizedName, known);
      }
      known.add(this);
    }
  }
  
  public ConcreteFunc(String name, Param...params) {
    this(name, Registration.REGISTERED, params);
  }  
  public boolean assignableTo(PType<?> other) {
    return other.typeToken.isAssignableFrom(type().typeToken);
  }
  
  public static Set<ConcreteFunc<?>> lookupCFuncs(String normalizedName) {
    Set<ConcreteFunc<?>> set = cfuncs.get(normalizedName);
    return CollUtils.maybeNullSet(set);
  }
  
  protected static final Pattern kwd = Pattern.compile("([\\p{IsLetter}_][\\p{IsLetter}\\p{IsDigit}_.]*(?>![_.]))\\s*:\\s*");

  
  public T read(PType<? super T> forType, boolean brackets, ReadableString input, int resetTo, int start) throws ReadError, ReadDelayedVal, MFailed { 
    
    final Map<String, Object> argMap = new HashMap<>();
    Map<String, Param> byKwd = byKwd();
    setDefaults(positional(), argMap);
    setDefaults(byKwd.values(), argMap);
    Iterator<Param> iter = positional().iterator();
    Param nextParam = nextParam(iter);
    String restName = null;
    PType<?> restType = null;
    List<Object> restVals = null;
    if (!brackets) {
      if (requiredParamsRemaining(nextParam)) {
        throw new ExpectedParamsError(input, resetTo, this, forType);
      }
      return makeOrDelay(argMap, restName, restVals, input, start);
    }
    List<PType<?>> bindings = forType.bindings();
    boolean first = true;
    while (true) {
      input.skipWS();
      if (input.consume("]")) {
        if (requiredParamsRemaining(nextParam)) {
          throw new ReadError(input, resetTo, forType, "Missing required parameters for %s", this);
        }
        return makeOrDelay(argMap, restName, restVals, input, start);
      }
      if (!first) {
        if (!input.consume(",")) {
          throw new ReadError(input, resetTo, forType, "Couldn't read %s", this);
        }
        input.skipWS();
      }
      first = false;
      Param param;
      Matcher km = input.consume(kwd);
      if (km == null) {
        if (nextParam == null) {
          throw new ReadError(input, resetTo, forType, "Too many positional parameters for %s", this);
        }
        param = nextParam;
        if (param.kind != Kind.REST) {
          nextParam = nextParam(iter);
        }
      } else {
        String kwd = km.group(1);
        String normalizedKwd = normalize(kwd);
        param = byKwd.get(normalizedKwd);
        if (param == null) {
          throw new ReadError(input, resetTo, forType, "Unknown keyword '%s' for %s", kwd, this);
        }
      }
      Object arg;
      try {
        PType<?> t;
        if (param.kind == Kind.REST) {
          if (restType == null) {
            restType = param.typeBase.reify(bindings);
            restName = param.name;
//            SeqType<?, ?> atype = (SeqType<?,?>)param.typeBase;
//            restType = atype.elementType();
            restVals = new ArrayList<>();
          }
          t = restType;
        } else {
          t = param.typeBase.reify(bindings);
        }
        arg = t.read(input, ",]");
      } catch (ReadDelayedVal e) {
        arg = e.delayedVal();
      }
      if (param.kind == Kind.REST) {
        @SuppressWarnings({ "unused", "null" })
        boolean add = restVals.add(arg);
      } else {
        argMap.put(param.name, arg);
      }
    }
    
  }

  private static boolean requiredParamsRemaining(Param nextParam) {
    return nextParam != null && nextParam.kind == Kind.REQUIRED;
  }
  
  private static Param nextParam(Iterator<Param> iter) {
    return IterUtils.nextOrNull(iter);
  }
  
  private static boolean anyDelays(Collection<? extends Object> collection) {
    if (collection != null) {
      for (Object o : collection) {
        if (o instanceof DelayedVal<?>) {
          return true;
        }
      }
    }
    return false;
  }

  private T makeOrDelay(final Map<String, Object> argMap, 
                        String restName, final List<Object> restVals, 
                        ReadableString input,
                        int start) throws ReadDelayedVal, MFailed {
    boolean hasDelayedArgs = anyDelays(argMap.values());
    if (restVals != null) {
      boolean restDelayed = anyDelays(restVals);
      if (restDelayed) {
        hasDelayedArgs = true;
        DelayedVal<List<Object>> dv = new DelayedVal<List<Object>>("???") {
          @Override
          public List<Object> force() throws IllegalValueException {
            List<Object> newList = new ArrayList<>(restVals.size());
            for (Object o : restVals) {
              if (o instanceof DelayedVal<?>) {
                o = ((DelayedVal<?>)o).force();
              }
              newList.add(o);
            }
            return newList;
          }
        };
        argMap.put(restName, dv);
      } else {
        argMap.put(restName, restVals);
      }
    }
    if (!hasDelayedArgs) {
      if (restVals != null) {
        argMap.put(restName, restVals);
      }
      return make(new ArgSet(argMap));
    }
    throw new ReadDelayedVal(new DelayedVal<T>(input.substring(start,input.getCursor())) {
      @Override
      public T force() throws IllegalValueException {
        for (Entry<String, Object> entry : argMap.entrySet()) {
          Object val = entry.getValue();
          if (val instanceof DelayedVal<?>) {
            @SuppressWarnings("unchecked")
            DelayedVal<Object> dv = (DelayedVal<Object>)val;
            entry.setValue(dv.force());
          }
        }
        try {
          return make(new ArgSet(argMap));
        } catch (MFailed e) {
          throw new IllegalValueException(String.format("Error processing '%s'", desc), e);
        }
      }});
  }

  private static void setDefaults(Iterator<Param> iter, Map<String, Object> argMap) {
    while (iter.hasNext()) {
      Param p = iter.next();
      p.addDefault(argMap);
    }
  }
  
  private static void setDefaults(Iterable<Param> iterable, Map<String, Object> argMap) {
    setDefaults(iterable.iterator(), argMap);
  }
/*
  public boolean readRequired(Type<? super T> forType, final List<Param> required,
                              ReadableString input, int resetTo,
                              Map<String, Object> argMap) throws ReadError {
    boolean first = true;
    for (Param param : required) {
      input.skipWS();
      if (input.consume("]")) {
        throw new ReadError(input, resetTo, forType, "Missing required parameters for %s", this);
      }
      if (!first) {
        if (!input.consume(",")) {
          throw new ReadError(input, resetTo, forType, "Couldn't read %s", this);
        }
        input.skipWS();
      }
      if (input.consume(kwd) != null) {
        throw new ReadError(input, resetTo, forType, "Missing required parameters for %s", this);
      }
      Object arg;
      try {
        arg = param.type.read(input, ",]");
      } catch (ReadDelayedVal e) {
        arg = e.delayedVal();
      }
      argMap.put(param.name, arg);
      first = false;
    }
    return first;
  }
  */
  public <X> ConcreteFunc<? extends X> convertedTo(final PType<X> type) {
    PType<T> myType = type();
    if (type.assignableFrom(myType)) {
      @SuppressWarnings("unchecked")
      final ConcreteFunc<? extends X> downcast = (ConcreteFunc<? extends X>)this;
      return downcast;
    }
    final ValueConverter<? super T, ? extends X> converter = type.converterFrom(myType);
    final ConcreteFunc<T> me = this;
    if (converter != null) {
      return new ConcreteFunc<X>(getName(), Registration.UNREGISTERED, params()) {
        @Override
        public X make(ArgSet args) throws MFailed {
          return converter.convert(me.make(args));
        }

        @Override
        public PType<X> type() {
          return type;
        }};
    }
    return null;
  }
  
  @Override
  public String toString() {
    return String.format("%s %s", type(), super.toString());
  }


}
