/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.config;

import java.io.PrintStream;
import java.util.Collection;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.hpl.erk.Marker;
import com.hpl.erk.NonLocalControlException;
import com.hpl.erk.ReadableString;
import com.hpl.erk.config.TypeCache.Factory;
import com.hpl.erk.config.ex.CantReadError;
import com.hpl.erk.config.ex.ExpectedParamsError;
import com.hpl.erk.config.ex.IllegalValueException;
import com.hpl.erk.config.ex.ReadError;
import com.hpl.erk.config.ex.UnknownHeadError;
import com.hpl.erk.config.func.ArgSet;
import com.hpl.erk.config.func.ConcreteFunc;
import com.hpl.erk.config.func.ConfigFunc;
import com.hpl.erk.config.func.ConfigFunc.MFailed;
import com.hpl.erk.config.func.Param;
import com.hpl.erk.config.type.ArrayType;
import com.hpl.erk.config.type.BuiltInTypes;
import com.hpl.erk.config.type.EnumSetType;
import com.hpl.erk.config.type.EnumType;
import com.hpl.erk.config.type.ListType;
import com.hpl.erk.config.type.MapType;
import com.hpl.erk.config.type.SetType;
import com.hpl.erk.config.type.SimpleType;
import com.hpl.erk.config.type.TypeBase;
import com.hpl.erk.config.type.TypeParameter;
import com.hpl.erk.config.type.TypeTemplate;
import com.hpl.erk.formatters.SeqFormatter;
import com.hpl.erk.functional_test.FunctionalTest;
import com.hpl.erk.functional_test.FunctionalTestBase.Result;
import com.hpl.erk.types.GenericTypeToken;
import com.hpl.erk.types.TypeToken;

public abstract class PType<C> extends TypeBase implements FunctionReturnType {
//  private static final Map<TypeToken, Type<?>> byClass = Collections.synchronizedMap(new HashMap<TypeToken, Type<?>>());
  private static final TypeCache cache = new TypeCache();
  
  public final TypeToken typeToken;
  
  public abstract List<PType<?>> bindings();
  
  protected PType(TypeToken typeToken) {
    this.typeToken = typeToken;
  }

  static {
    BuiltInTypes.registerTypes();
  }
  

  private final class ReadTest extends FunctionalTest<C> {
    private final String form;

    private ReadTest(String form, Class<? extends Exception> expected) {
      super(form, expected);
      this.form = form;
    }

    public ReadTest(String form, C expected) {
      super(form, expected);
      this.form = form;
    }

    @Override
    public C compute() throws ReadError, ReadDelayedVal {
      return read(form);
    }
  }

  public abstract class CFunc extends ConcreteFunc<C> {

    public CFunc(String name, Param...params) {
      super(name, params);
    }
    
    @Override
    public PType<C> type() {
      return PType.this;
    }
  }
  
  public static final class Sig<T> { 
    private Sig() {}
  }
  private static final Sig<Object> sigToken = new Sig<Object>();
  @SuppressWarnings("unchecked")
  public static <T> Sig<T> sig() {
    return (Sig<T>)sigToken;
  }
  @SuppressWarnings("unchecked")
  public static <T> Sig<? extends T> sigUnder() {
    return (Sig<? extends T>)sigToken;
  }
  
  public abstract class ConversionFrom<X> extends ValueConverter<X, C> {

    public ConversionFrom(PType<X> type) {
      super(type, PType.this);
    }
    
  }
  
  public CFunc constant(String name, final C val) {
    return new CFunc(name) {
      @Override
      public C make(ArgSet args) {
        return val;
      }
    };
  }
  
  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (!(obj instanceof PType)) {
      return false;
    }
    PType<?> other = (PType<?>)obj;
    return typeToken.equals(other.typeToken);
  }

  public void addFunctionTypesTo(Collection<FunctionReturnType> types) {
    types.add(this);
  }
  
  @Override
  public String toString() {
    return typeToken.toString();
  }
  
  @Override
  public int hashCode() {
    return typeToken.hashCode();
  }
  
  public boolean assignableFrom(PType<?> other) {
    return typeToken.isAssignableFrom(other.typeToken);
  }

  @Override
  public PType<C> reify(List<PType<?>> bindings) {
    return this;
  }
  
  public Class<C> rawClass() {
    return (Class<C>) typeToken.rawClass();
  }

  public C read(String s) throws ReadError, ReadDelayedVal {
    return read(new ReadableString(s), "");
  }
  
  public C read(ReadableString input, String valTerminators) throws ReadDelayedVal, ReadError {
    if (readNull(input)) {
      return null;
    }
    readAndThrowDelayed(input);
    String unknownFuncHead = null;
    ExpectedParamsError noParams = null;
    ReadError funcReadError = null;
    try {
      C val = readFuncForm(input);
      if (val != null) {
        return val;
      }
    } catch (UnknownFuncHead e) {
      unknownFuncHead = e.head;
    } catch (ExpectedParamsError e) {
      noParams = e;
    } catch (ReadError e) {
      funcReadError = e;
    } catch (FuncReturnedNull e) {
      return null;
    }
    try {
      return readVal(input, valTerminators);
    } catch (ReadError e) {
      if (unknownFuncHead != null) {
        // the real problem was that there was a function we couldn't deal with
        throw new UnknownHeadError(input, input.getCursor(), unknownFuncHead, this);
      } else if (funcReadError != null) {
        throw funcReadError;
      } else if (noParams != null) {
        throw noParams;
      } else {
        throw e;
      }
    }
  }
  
  public String format(C val) {
    return String.format("%s", val);
  }
/*
  public static final <T> void register(Class<T> clss, Type<T> type) {
    TypeToken token = TypeToken.find(clss);
    register(token, type);
  }
  private static <T> void register(TypeToken token, Type<T> type) {
    byClass.put(token, type);
  }
  @SafeVarargs
  public static final <T> void register(SimpleType<T> type, Class<T>...aliases) {
    register(type.typeToken, type);
    for (Class<T> c : aliases) {
      register(c, type);
    }
  }
*/
  
  public PType<C> register() {
    cache.cache(typeToken, this);
    return this;
  }  
  public final PType<C> alias(Class<C> alias) {
    cache.cache(TypeToken.find(alias), this);
    return this;
  }
  
  public static final Pattern nullPat = Pattern.compile("\\s*null\\b", Pattern.CASE_INSENSITIVE);
  protected boolean readNull(ReadableString s) {
    return s.consume(nullPat) != null;
  }
  
  protected static final Pattern funStart = Pattern.compile("\\s*(?:(\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*)\\.)?([\\p{IsLetter}_][\\p{IsLetter}\\p{IsDigit}_.]*)(\\[)?");
  
  @SuppressWarnings("serial")
  protected static class UnknownFuncHead extends NonLocalControlException {
    final String head;

    protected UnknownFuncHead(String match) {
      this.head = match;
    }
  }
  
  @SuppressWarnings("serial")
  protected static class FuncReturnedNull extends NonLocalControlException {
  }
  
  protected C readFuncForm(ReadableString input) throws ReadError, UnknownFuncHead, FuncReturnedNull, ReadDelayedVal {
    int resetTo = input.getCursor();
    Matcher m = input.consume(funStart);
    if (m == null) {
      return null;
    }
    final String className = m.group(1);
    final String head = m.group(2);
    final boolean brackets = m.group(3) != null;
    final Collection<ConcreteFunc<? extends C>> readers;
    if (className != null) {
      readers = ConfigFunc.lookup(head, this, className);
    } else {
      readers = ConfigFunc.lookup(head, this);
    }
    if (readers == null || readers.isEmpty()) {
      input.setCursor(resetTo);
      throw new UnknownFuncHead(head);
    }
//    Map<ConcreteFunc<? extends C>, C> values = new IdentityHashMap<>();
    Map<ConcreteFunc<? extends C>, ReadError> errors = new IdentityHashMap<>();
    Map<ConcreteFunc<? extends C>, DelayedVal<? extends C>> delays = new IdentityHashMap<>();
    Map<ConcreteFunc<? extends C>, MFailed> makeErrors = new IdentityHashMap<>();
    Map<C, List<ConcreteFunc<? extends C>>> byVal = new HashMap<C, List<ConcreteFunc<? extends C>>>();

    int before = input.getCursor();
    int afterward = before;
    for (ConcreteFunc<? extends C> r : readers) {
      try {
        input.setCursor(before);
        C val = r.read(this, brackets, input, resetTo, m.start());
        List<ConcreteFunc<? extends C>> withVal = byVal.get(val);
        if (withVal == null) {
          withVal = new LinkedList<>();
          byVal.put(val, withVal);
        }
        withVal.add(r);
//        values.put(r, val);
        afterward = input.getCursor();
      } catch (ReadDelayedVal e) {
        delays.put(r, e.<C>delayedVal());
        afterward = input.getCursor();
      } catch (ReadError e) {
        errors.put(r, e);
      } catch (MFailed e) {
        makeErrors.put(r, e);
      }
    }
    input.setCursor(afterward);
    // We're going to assume that either everybody delayed or nobody did.
    if (byVal.size() == 1 && makeErrors.isEmpty()) {
      C val = byVal.keySet().iterator().next();
      if (val == null) {
        throw new FuncReturnedNull();
      }
      return val;
    }
    if (!delays.isEmpty()) {
      if (delays.size() == 1) {
        DelayedVal<? extends C> dv = delays.values().iterator().next();
        throw new ReadDelayedVal(dv);
      }
      DelayedVal<C> dv = new AmbiguousDelayedVal<>(this, delays);
      throw new ReadDelayedVal(dv);
    }
    int nMatched = makeErrors.size();
    for (List<?> list : byVal.values()) {
      nMatched += list.size();
    }
    if (nMatched > 1) {
      SeqFormatter<String> options = SeqFormatter.<String>withSep("\n  ").close("\n");
      for (Entry<C, List<ConcreteFunc<? extends C>>> entry : byVal.entrySet()) {
        C val = entry.getKey();
        List<ConcreteFunc<? extends C>> funcs = entry.getValue();
        for (ConcreteFunc<? extends C> func : funcs) {
          options.addFormatted("%s: %s", func, val);
        }
      }
      for (Entry<ConcreteFunc<? extends C>, MFailed> entry : makeErrors.entrySet()) {
        ConcreteFunc<? extends C> func = entry.getKey();
        MFailed e = entry.getValue();
        options.addFormatted("%s: %s", func, e.getMessage());
      }
      throw new ReadError(input, resetTo, this, "Ambiguous head '%s' for %s.  Could be\n  %s", head, this, options);
    }
    if (nMatched == 0) {
      if (errors.size() == 1) {
        throw errors.values().iterator().next();
      }
      SeqFormatter<Object> options = SeqFormatter.withSep("\n  ");
      for (Entry<ConcreteFunc<? extends C>, ReadError> entry : errors.entrySet()) {
        options.add(entry.getKey());
        options.add("  "+entry.getValue().getMessage());
      }
      throw new ReadError(input, resetTo, this, "No option for '%s' for %s worked.\n  %s", head, this, options);
    }
    MFailed e = makeErrors.values().iterator().next();
    throw new ReadError(input, resetTo, this, "%s", e.getMessage());
//    throw new IllegalStateException();
  }
  
  public static <T> PType<T> of(final Class<T> clss) {
    TypeToken token = TypeToken.find(clss);
    final Factory<T> factory = new Factory<T>() {
      @Override
      public PType<T> create() {
        if (Enum.class.isAssignableFrom(clss)) {
          return EnumType.ofChecked(clss);
        } else if (clss.isArray()) {
          @SuppressWarnings("unchecked")
          PType<T> arrayType = (PType<T>)arrayOf(clss.getComponentType());
          return arrayType;
        } else {
          return new SimpleType<>(clss);
        }
      }
    };
    return of(token, factory);
  }
  
  public static <GT, T extends GT> PType<T> of(Sig<T> sig, GenericType<GT> generic, PType<?> ...bounds) {
    return generic.concreteType(sig, bounds);
  }
  public static <GT> PType<? extends GT> of(GenericType<GT> generic, PType<?>...bounds) {
    return PType.of(PType.<GT>sigUnder(), generic, bounds);
  }
  
  public static <T> PType<T> of(TypeToken token, final Factory<T> factory) {
    return cache.lookup(token, factory);
  }
  
  public static <T> PType<T> of(Sig<T> sig, TypeToken token) {
    // TODO
    return null;
  }
  
  public static <T> GenericType<T> generic(Class<T> raw) {
    return GenericType.of(raw);
  }
  
  public static <T> GenericType<T> Generic(GenericTypeToken token) {
    return GenericType.of(token);
  }
  
//  public static Type<?> of(final TypeToken token) {
//    return cache.lookup(token,  new Factory<?>() {});
//    Type<?> type = knownType(token);
//    if (type != null) {
//      return type;
//    }
//    if (!token.isParameterized()) {
//      return Type.of(token.rawClass());
//    }
//    if (token.isArray()) {
//      return Type.arrayOf(Type.of(token.elementType()));
//    }
//     // TODO handle generics
//    throw new IllegalArgumentException(String.format("Don't know how to make a type for %s", token));
//  }
  
  public static <T> PType<List<T>> listOf(PType<T> type) {
    return ListType.of(type);
  }
  
  public static <T> PType<List<T>> listOf(Class<T> clss) {
    return listOf(PType.of(clss));
  }

  public static <T> PType<Set<T>> setOf(PType<T> type) {
    return SetType.of(type);
  }
  
  public static <T> PType<Set<T>> setOf(Class<T> clss) {
    return setOf(PType.of(clss));
  }

  public static <E extends Enum<E>> PType<EnumSet<E>> enumSetOf(PType<E> type) {
    return EnumSetType.of(type);
  }

  public static <E extends Enum<E>> PType<EnumSet<E>> enumSetOf(Class<E> clss) {
    return enumSetOf(EnumType.ofEnum(clss));
  }
  
  public static <T> PType<T[]> arrayOf(PType<T> type) {
    return ArrayType.of(type);
  }
  
  public static <T> PType<T[]> arrayOf(Class<T> clss) {
    return arrayOf(PType.of(clss));
  }
  
  public static <K,V> PType<Map<K, V>> mapOf(PType<K> key, PType<V> val) {
    return MapType.of(key, val);
  }
  public static <K,V> PType<Map<K, V>> mapOf(Class<K> key, PType<V> val) {
    return mapOf(PType.of(key), val);
  }
  public static <K,V> PType<Map<K, V>> mapOf(PType<K> key, Class<V> val) {
    return mapOf(key, PType.of(val));
  }
  public static <K,V> PType<Map<K, V>> mapOf(Class<K> key, Class<V> val) {
    return mapOf(PType.of(key), PType.of(val));
  }
  
  public static TypeParameter param(int n) {
    return TypeParameter.number(n);
  }
  
  public static <GT> TypeTemplate<GT> template(GenericType<GT> g, TypeBase...params) {
    return new TypeTemplate<>(g, params);
  }
  
  public ConfigParam<C> configParam(RunContext context, String name) {
    return new ConfigParam<C>(context, name, this);
  }
  
  public <X> ValueConverter<? super X, ? extends C> converterFrom(PType<X> type) {
    if (assignableFrom(type)) {
      return new ValueConverter<X, C>(type, this) {
        @SuppressWarnings("unchecked")
        @Override
        public C convert(X val) {
          return (C)val;
        }};
    }
    return ValueConverter.lookup(type, this);
  }
  
  protected String readQuoted(ReadableString input, char open, char close)  throws ReadError {
    int resetTo = input.getCursor();
    if (!input.consume(open)) {
      return null;
    }
    StringBuilder bldr = new StringBuilder();
    for (char c; (c=input.nextChar()) != 0; ) {
      if (c == close) {
        return bldr.toString();
      }
      if (c == '\\') {
        c = input.nextChar();
        if (c == 0) {
          throw new ReadError(input, resetTo, this, "Unterminated string");
        }
        c = escapeSequence(c, input, resetTo, this);
      }
      bldr.append(c);
    }
    throw new ReadError(input, resetTo, this, "Unterminated string");
  }

  protected String readUnquoted(ReadableString input, String terminators) throws ReadError {
    int resetTo = input.getCursor();
    StringBuilder bldr = new StringBuilder();
    while (!input.atEnd() && !input.atAny(terminators)) {
      char c=input.nextChar();
      if (c == '\\') {
        c = input.nextChar();
        if (c == 0) {
          throw new ReadError(input, resetTo, this, "Unquoted string ended after backslash");
        }
        c = escapeSequence(c, input, resetTo, this);
      }
      bldr.append(c);
    }
    return bldr.toString().trim();
  }

  private static <C> char escapeSequence(char c, ReadableString input, int resetTo, PType<C> pType) throws ReadError {
    switch (c) {
    case 'n' : return '\n';
    case 't' : return '\t';
    case 'b' : return '\b';
    case 'f' : return '\f';
    case '0' : return octalEscape(input);
    case 'u' : return unicodeEscape(input, resetTo, pType);
    case '\'' :
    case '\"' :
    case '\\' :
      return c;
    default:
      return c;
//      throw new ReadError(input, resetTo, pType, "Unknown string escape '\\%s'", c);
    }
  }
  
  private static final Pattern octalSeq = Pattern.compile("(?:[0-3]?[0-7])?[0-7]");
  private static char octalEscape(ReadableString input) {
    Matcher m = input.consume(octalSeq);
    if (m != null) {
      return (char)Integer.parseInt(m.group(), 8);
    }
    return 0;
  }
  
  private static final Pattern unicodeSeq = Pattern.compile("\\p{XDigit}{4}");
  private static <C> char unicodeEscape(ReadableString input, int resetTo, PType<C> pType) throws ReadError {
    Matcher m = input.consume(unicodeSeq);
    if (m != null) {
      return (char)Integer.parseInt(m.group(), 8);
    }
    throw new ReadError(input, resetTo, pType, "Can't parse unicode escape sequence");
  }
  
  
  protected void readAndThrowDelayed(ReadableString input) throws ReadDelayedVal, ReadError {
    int resetTo = input.getCursor();
    ConfigParam<?> cp = ConfigParam.readRef(input, resetTo, this);
    if (cp != null) {
      DelayedVal<C> dv = cp.delayedValTo(this);
      if (dv == null) {
        throw new ReadError(input, resetTo, this, "Can't use %s param as %s value", cp.type(), this);
      }
      throw new ReadDelayedVal(dv);
    }
  }


  /**
   * @throws ReadDelayedVal  
   */
  public C readVal(ReadableString s, String valTerminators) throws ReadError, ReadDelayedVal {
    throw new CantReadError(s, s.getCursor(), this);
  }
  
  public <X> DelayedVal<C> delayedValFrom(final ConfigParam<X> cp) {
    PType<X> other = cp.type();
    if (other == this || assignableFrom(other)) {
      @SuppressWarnings("unchecked")
      ConfigParam<? extends C> castCP = (ConfigParam<? extends C>)cp;
      return DelayedVal.referencing(castCP);
    }
    final ValueConverter<? super X, ? extends C> vc = ValueConverter.lookup(cp.type(), this);
    if (vc != null) {
      return new DelayedVal<C>("@"+cp.fullName()) {
        @Override
        public C force() throws IllegalValueException {
          return vc.convert(cp.getVal());
        }};
    }
    return null;
  }
  
  public String describe() {
    return null;
  }

  public String syntax() {
    return null;
  }
  
  public static <T> Marker<T> marker() {
    return Marker.<T>inst();
  }
  
  public static <T> Marker<T> marker(Class<T> c) {
    return Marker.<T>inst();
  }
  

  public FunctionalTest<C> readTest(final String form, Class<? extends ReadError> expected) {
    return new ReadTest(form, expected);
  }
  public FunctionalTest<C> readTest(final String form, C expected) {
    return new ReadTest(form, expected);
  }


  public String testRead(final String form, Class<? extends ReadError> expected) {
    return readTest(form, expected).perform().toString();
  }

  public String testRead(String form, C expected) {
    return readTest(form, expected).perform().toString();
  }
  
  public boolean testRead(PrintStream out, String form, Class<? extends ReadError> expected) {
    final Result result = readTest(form, expected).perform();
    if (out != null) {
      out.println(result);
    }
    return result.passed;
  }
  
  public boolean testRead(PrintStream out, String form, C expected) {
    final Result result = readTest(form, expected).perform();
    if (out != null) {
      out.println(result);
    }
    return result.passed;
  }
  
}
