/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;

import com.hpl.erk.formatters.SeqFormatter;

/**
 * {@link Chooser} is an object that performs weighted random selection among a set of objects
 * in a cyclic manner such that in each cycle each choice will be selected exactly the number of 
 * times specified by its weight.  The next object is selected by calling {@link #select()}.  
 * <p/>
 * Calling {@link #note(obj)} tells the system to pretend that the object has been selected.  If calling
 * note() causes the choices to become out of balance (i.e., one choice has a weight of 5, but note() has
 * been called ten times, that choice will be excluded from selection until the overall count of 
 * selections and notes is in balance relative to the relative weights of the choices.
 * 
 * 
 * @author Evan Kirshenbaum
 *
 * @param <T> the type of object being chosen
 */

public class Chooser<T> {
  private List<Choice> choices;
  private Map<T, Choice> byOption;
  int base;
  int currentBase;
  Random rnd = new Random();
  
  private class Choice {
    final T option;
    final int desired;
    int expected = 0;

    private Choice(T option, int desired) {
      this.option = option;
      this.desired = desired;
      expected = desired;
    }
    
    @Override
    public String toString() {
      return String.format("%s[d: %,d, e: %,d]", option, desired, expected);
    }
  }
  
  public Chooser(Map<T, Integer> spec) {
    choices = new ArrayList<Choice>();
    byOption = new HashMap<T, Choice>(spec.size());
    base = 0;
    for (Entry<T, Integer> entry : spec.entrySet()) {
      T option = entry.getKey();
      int desired = entry.getValue();
      Choice choice = new Choice(option, desired);
      choices.add(choice);
      byOption.put(option, choice);
      base += desired;
    }
    currentBase = base;
  }
  
  public Chooser(Collection<T> collection, int nPer) {
    this(makeMap(collection, nPer));
  }
  public Chooser(Collection<T> collection) {
    this(collection, 1);
  }
  
  private static <T> Map<T, Integer> makeMap(Collection<T> collection, int nPer) {
    Map<T, Integer> map = new HashMap<>(collection.size());
    for (T choice : collection) {
      map.put(choice, nPer);
    }
    return map;
  }

  /**
   * Choose an object
   * @return the chosen object
   */
  synchronized public T select() {
    int n = rnd.nextInt(currentBase);
    Choice which = pick(n);
    note(which);
    return which.option;
  }
  
  /**
   * Pretend that an object was selected.
   * @param which the object
   * @return <code>false</code> if the object is not one of the choices, <code>true</code> otherwise.
   */
  synchronized public boolean note(T which) {
    Choice c = byOption.get(which);
    if (c == null) {
      return false;
    }
    note(c);
    return true;
  }

  private void note(Choice which) {
    /*
     * The logic here is that base is the length of the 
     * cycle and always represents the sum of choice.expected.
     * The noted object's expected goes down by base-its desired,
     * and everybody else goes up by desired, maintaining that
     * invariant.  Choices that have been fully handed out
     * get a non-positive expected value and are excluded from
     * consideration.  Eventually, there will be one choice whose
     * expected number is equal to base, with all other choices
     * zero.  When that is chosen in the next call to select(),
     * the expected weights for each choice will equal their
     * desired weights and the cycle begins again.
     */
    which.expected -= base;
    int n = 0;
    for (Choice c : choices) {
      int val = (c.expected += c.desired);
      if (val > 0) {
        n += val;
      }
    }
    currentBase = n;
  }
  

  private Choice pick(int n) {
    for (Choice c : choices) {
      int e = c.expected;
      if (e > 0) {
        if (n <= e) {
          return c;
        }
        n -= e;
      }
    }
    throw new IllegalStateException();
  }
  
  public static void main(String[] args) {
    Map<Integer, Integer> spec = new HashMap<Integer, Integer>();
    spec.put(0, 1);
    spec.put(1, 2);
    spec.put(3, 0);
    spec.put(2, 7);
    Chooser<Integer> chooser = new Chooser<Integer>(spec);
    final int[] counts = new int[4];
    for (int i=1; i<=1000; i++) {
      int n;
      if (i <=5) {
        n = 3;
        chooser.note(n);
      } else if (i <= 50) {
        n = 1;
        chooser.note(n);
      } else {
        n = chooser.select();
      }
      counts[n]++;
      SeqFormatter<Integer> join = SeqFormatter.bracketList();
      for (int count : counts) {
        join.add(count);
      }
      System.out.format("%,5d: %d %s%n", i, n, join);
    }
  }
}
