/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.coroutines;

import java.util.Iterator;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import com.hpl.erk.Locked;
import com.hpl.erk.NonLocalControlException;
import com.hpl.erk.iter.ConstIterator;

/**
 * An {@link Iterator} implemented using a parallel thread.  The object's {@link #run()} method periodically calls
 * {@link #yield(X)} to identify the next item to be the value of {@link #next()}.  When <code>run()</code> exits, {@link #hasNext()}
 * returns <code>false</code>.  Condition variables are used so the <code>run()</code> method doesn't compute the next value until
 * it's wanted.  
 * <p/>
 * TODO: I should think about allowing it to get ahead
 * <p/>
 * Note that I haven't worked out how to ensure that things get cleaned up correctly when the iteration is done.  (They really
 * need to make Iterator auto-closeable.)
 * @author Evan Kirshenbaum
 *
 * @param <X>
 */
public abstract class ThreadedCoroutine<X> extends ConstIterator<X> {
  final Lock lock = new ReentrantLock();
  final Condition wantVal = lock.newCondition();
  final Condition haveVal = lock.newCondition();
  final WorkerThread thread = new WorkerThread();
  boolean valid;
  X val;
  boolean done = false;
  
  protected abstract void run() throws IteratorDisappeared; 
  
  public ThreadedCoroutine() {
    thread.start();
  }
  
  private static class IteratorDisappeared extends NonLocalControlException {
    private static final long serialVersionUID = 1720701093791233655L;
    static final IteratorDisappeared INSTANCE = new IteratorDisappeared();
  }

  private class WorkerThread extends Thread {
    
    public WorkerThread() {
      setDaemon(true);
    }

    @Override
    public void run() {
      try {
        ThreadedCoroutine.this.run();
      } catch (IteratorDisappeared e) {
        return;
      }
      ThreadedCoroutine.this.done();
    }
  }
  
  protected void yield(X val) throws IteratorDisappeared {
    try (Locked locked = new Locked(lock)) {
      while (valid) {
        wantVal.await();
      }
      if (done) {
        throw IteratorDisappeared.INSTANCE;
      }
      this.val = val;
      valid = true;
      haveVal.signal();
      return;
    } catch (InterruptedException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }

  public void done() {
    try (Locked locked = new Locked(lock)) {
      done = true;
      haveVal.signal();
    }
  }
  
  @Override
  public boolean hasNext() {
    try (Locked locked = new Locked(lock)) {
      while (!valid) {
        wantVal.signal();
        haveVal.await();
      }
      return !done;
    } catch (InterruptedException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
      return false;
    }
  }
  
  
  @Override
  public X next() {
    try (Locked locked = new Locked(lock)) {
      while (!valid) {
        wantVal.signal();
        haveVal.await();
      }
      X result = val;
      val = null;
      valid = false;
      return result;
    } catch (InterruptedException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
      return null;
    }
  }
  
//  @Override
//  protected void finalize() throws Throwable {
//    try (Locked locked = new Locked(lock)) {
//      if (!done) {
//        valid = false;
//        done = true;
//        wantVal.signal();
//      }
//    }
//  }
  
  
  public static void main(String[] args) {
    Iterable<Integer> ints = new Iterable<Integer>() {
      public Iterator<Integer> iterator() {
        return new ThreadedCoroutine<Integer>() {
          final int max = 20;
          @Override
          protected void run() throws IteratorDisappeared {
            for (int i=0; i<max; i++) {
              yield(i);
              yield(i*i);
            }
          }
        };
      }
    };
        
    int n = 0;
    for (int i : ints) {
      if (n++ == 11) {
        return;
      }
      System.out.println(i);
    }
  }

}
