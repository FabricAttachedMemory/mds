/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.iter;
import java.util.Iterator;
import java.util.NoSuchElementException;

import com.hpl.erk.func.Functions;
import com.hpl.erk.func.Predicate;
import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.impl_helper.ObjectDescription;

/**
 * A base class implementing the methods for {@link Iteration}, {@link MappedIteration}, {@link BasedIteration}, and
 * {@link BasedMappedIteration}.  See documentation for {@link Iteration} for details.
 */
class IterationBase<X,Y,C extends Iterable<? extends X>> {
  protected final C base;
  protected final Iterator<? extends X> underlyingIterator;
  protected final UnaryFunc<? super X, ? extends Y> transformer;
  protected Predicate<? super Y> filter = null;
  protected Predicate<? super X> baseFilter = null;
  protected boolean isFiltered = false;
  protected Y current;
  protected X baseCurrent;
  protected Y prior;
  protected X basePrior;
  protected int index = -1;
  protected int baseIndex = -1;
  protected int nSkipped;
  private boolean done;
  private boolean doneValid = false;
  private Y next;
  private boolean nextValid = false;
  private X baseNext;
  private int nextNSkipped;
  private boolean removeAllowed = false;
    
  protected IterationBase(C base, UnaryFunc<? super X, ? extends Y> transformer) {
    this.base = base;
    this.underlyingIterator = base.iterator();
    this.transformer = transformer;
  }

  /**
   * 
   * @return the {@link Iterable} object being iterated over.
   */
  public C base() {
    return base;
  }
  /**
   * The current element of the iteration.  If this object is a {@link MappedIteration} or
   * {@link BasedMappedIteration}, what is returned will be after the transformation is applied.
   * @return the current element
   * @throws IllegalStateException if {@link #next()} has not been called
   */
  public Y current() {
    checkIndex(0, "No current element until next() is called().");
    return current;
  }
  /**
   * The current element of the base {@link Iterable}.  If this object is a {@link MappedIteration} 
   * or {@link BasedMappedIteration}, what is returned will be before the transformation is applied, otherwise
   * it will be identical to the result of {@link #current()}.
   * @return the current element of the base {@link Iterable}.
   * @throws IllegalStateException if {@link #next()} has not been called
   */
  public X baseCurrent() {
    checkIndex(0, "No current element until next() is called().");
    return baseCurrent;
  }
  
  /**
   * The prior element of the iteration (i.e., the prior iteration's
   * result of {@link #current()}). If this object is a {@link MappedIteration} or
   * {@link BasedMappedIteration}, what is returned will be after the transformation is applied.
   * Note that if this object is filtered, this is the last element that passed the filters.
   * @return the prior element
   * @throws IllegalStateException if {@link #next()} has not been called twice
   * @see #safePrior()
   */
  public Y prior() {
    checkIndex(1, "No prior element until next() is called() twice.");
    return prior;
  }
  
  /**
   * The prior element of the iteration (i.e., the prior iteration's
   * result of {@link #current()}) or <code>null</code> if {@link #next()} has not been called twice.
   * If this object is a {@link MappedIteration} or
   * {@link BasedMappedIteration}, what is returned will be after the transformation is applied.
   * Note that if this object is filtered, this is the last element that passed the filters.
   * @return the prior element
   * @see #prior()
   */
  public Y safePrior() {
    if (index < 1) {
      return null;
    }
    return prior;
  }
  /**
   * The prior element of the base {@link Iterable} (i.e., the prior iteration's 
   * result of {@link #baseCurrent()}).
   * If this object is a {@link MappedIteration} 
   * or {@link BasedMappedIteration}, what is returned will be before the transformation is applied, otherwise
   * it will be identical to the result of {@link #prior()}.
   * Note that if this object is filtered, this is the last element that passed the filters, both before and
   * after any transformation.
   * @see #safeBasePrior()
   * @return the prior element of the base {@link Iterable}.
   * @throws IllegalStateException if {@link #next()} has not been called twice
   */
  public X basePrior() {
    checkIndex(1, "No prior element until next() is called() twice.");
    return basePrior;
  }
  
  /**
   * The prior element of the base {@link Iterable} (i.e., the prior iteration's 
   * result of {@link #baseCurrent()}) or <code>null</code> if {@link #next()} has not been called twice.
   * If this object is a {@link MappedIteration} 
   * or {@link BasedMappedIteration}, what is returned will be before the transformation is applied, otherwise
   * it will be identical to the result of {@link #prior()}.
   * Note that if this object is filtered, this is the last element that passed the filters, both before and
   * after any transformation.
   * @see #basePrior()
   * @return the prior element of the base {@link Iterable}.
   */
  public X safeBasePrior() {
    if (index < 1) {
      return null;
    }
    return basePrior;
  }
  /**
   * The current index number in the sequence of elements that pass any filters, starting from zero. 
   * @return the index number
   * @throws IllegalStateException if {@link #next()} has not been called
   */
  public int index() {
    checkIndex(0, "No index until next() is called().");
    return index;
  }
  /**
   * The current index number in the base sequence of elements, whether or not they pass filters.  For example,
   * if {@link #index()} is 5 and 10 elements from {@link #base()} have been omitted because they fail to pass the
   * filters, {@link #baseIndex()} will be 15.
   * @return the index number
   * @throws IllegalStateException if {@link #next()} has not been called
   */
  public int baseIndex() {
    checkIndex(0, "No index until next() is called().");
    return baseIndex;
  }
  /**
   * The number of elements that failed to pass the filters between the prior call to {@link #next()} and the last call 
   * or from the beginning if the last call was the first.  Note that this is not the complete count of elements from
   * the beginning that have been skipped.  That can be obtained as the difference between {@link #baseIndex()} and 
   * {@link #index()}.
   * @return the number of elements that failed the filters in the most recent call to {@link #next()}
   * @throws IllegalStateException if {@link #next()} has not been called
   */
  public int nSkipped() {
    checkIndex(0, "Nothing skipped until next() is called().");
    return nSkipped;
  }
  /**
   * 
   * @return <code>true</code> if a filter has been asserted via {@link #filter(Predicate)} or {@link #baseFilter(Predicate)}
   */
  public boolean isFiltered() {
    return isFiltered;
  }
  /**
   * Remove the current element from the underlying {@link Iterable} (i.e., {@link #base()}).
   * @throws IllegalStateException if this {@link #isFiltered()} and {@link #hasNext()} has been called since
   * the last call to {@link #next()}
   */
  public void removeCurrent() {
    if (!removeAllowed) {
      String msg = isFiltered ? 
                                "Filtered iterators do not allow remove() after hasNext() or peek()"
                                : "Cannot call remove() after peek()";
      throw new IllegalStateException(msg);
    }
    underlyingIterator.remove();
  }
  /**
   * 
   * @return <code>true</code> if a call to {@link #next()} would succeed 
   */
  public boolean hasNext() {
    if (doneValid) {
      return !done;
    }
    if (nextValid) {
      return true;
    }
    if (!isFiltered()) {
      done = !underlyingIterator.hasNext();
      doneValid = true;
    } else {
      tryPeek();
    }
    return !done;
  }
  private void tryPeek() {
    if (nextValid) {
      return;
    }
    removeAllowed = false;
    for (nextNSkipped=0; underlyingIterator.hasNext(); nextNSkipped++) {
      baseNext= underlyingIterator.next();
      if (baseFilter != null && !baseFilter.test(baseNext)) {
        continue;
      }
      next = transformer.call(baseNext);
      if (filter != null && !filter.test(next)) {
        continue;
      }
      nextValid = true;
      done = false;
      doneValid = true;
      return;
    }
    done = true;
    doneValid = true;
  }
  

  
  /**
   * 
   * @return the next element, transformed if applicable, that passes all filters
   * @throws NoSuchElementException if there are no further elements (i.e., {@link #hasNext()} 
   * would return <code>false</code>).
   */
  public Y next() {
    peek();
    removeAllowed = true;
    nextValid = false;
    doneValid = false;
    prior = current;
    basePrior = baseCurrent;
    current = next;
    baseCurrent = baseNext;
    index++;
    baseIndex += nextNSkipped+1;
    nSkipped = nextNSkipped;
    nextValid = false;
    return current;
  }
  
  /**
   * 
   * @return the element from the base {@link Iterable} that corresponds to the next element
   * that passes all of the filters.  Identical to calling {@link #next()} and then {@link #baseCurrent()}
   */
  public X nextBase() {
    next();
    return baseCurrent;
  }
  /**
   * 
   * @return the value that {@link #current()} will have after the next call to {@link #next()}.
   * @throws NoSuchElementException if calling {@link #next()} would (i.e., {@link #hasNext()} 
   * would return <code>false</code>). 
   */
  public Y peek() {
    if (!nextValid) {
      tryPeek();
    }
    if (done) {
      throw new NoSuchElementException();
    }
    return next;
  }
  /**
   * 
   * @return the value that {@link #current()} will have after the next call to {@link #next()} or <code>null</code>
   * if calling {@link #next()} would result in a {@link NoSuchElementException} exception being thrown (i.e., {@link #hasNext()} 
   * would return <code>false</code>).
   */
  public Y safePeek() {
    if (!nextValid) {
      tryPeek();
    }
    if (done) {
      return null;
    }
    return next;
  }
  
  /**
   * 
   * @return the value that {@link #baseCurrent()} will have after the next call to {@link #next()}.
   * @throws NoSuchElementException if calling {@link #next()} would (i.e., {@link #hasNext()} 
   * would return <code>false</code>). 
   */
  public X peekBase() {
    peek();
    return baseNext;
  }
  /**
   * 
   * @return the value that {@link #baseCurrent()} will have after the next call to {@link #next()} or <code>null</code>
   * if calling {@link #next()} would result in a {@link NoSuchElementException} exception being thrown
   *  (i.e., {@link #hasNext()} 
   * would return <code>false</code>).
   */
  public X safePeekBase() {
    peek();
    return nextValid ? baseNext : null;
  }

  /**
   * @param min minimum index
   * @param msg message to use
   * @throws IllegalStateException if the current index is less than the minimum
   */
  protected final void checkIndex(int min, String msg) {
    if (index < min) {
      throw new IllegalStateException(msg);
    }
  }
  
  /**
   * An {@link Iterable} that walks over this {@link IterationBase} and returns successive elements
   * by calling a {@link UnaryFunc}
   * @param extractor a {@link UnaryFunc} to use to extract the elements
   * @return the {@link Iterable}
   */
  public <T> Iterable<T> extracted(final UnaryFunc<? super IterationBase<X,Y,C>, T> extractor) {
    return new Iterable<T>() {
      @Override
      public Iterator<T> iterator() {
        return new Iterator<T>() {
          @Override
          public boolean hasNext() {
            return IterationBase.this.hasNext();
          }

          @Override
          public T next() {
            IterationBase.this.next();
            return extractor.call(IterationBase.this);
          }

          @Override
          public void remove() {
            IterationBase.this.removeCurrent();
          }};
      }
    };
  }
  
  /**
   * @return an {@link Iterable} that iterates over the values of {@link #current()}
   */
  public Iterable<Y> values() {
    return extracted(new UnaryFunc<IterationBase<X,Y,C>, Y>() {
      @Override
      public Y call(IterationBase<X, Y, C> val) {
        return val.current;
      }});
  }
  /**
   * @return an {@link Iterable} that iterates over the values of {@link #baseCurrent()}
   */
  public Iterable<X> baseValues() {
    return extracted(new UnaryFunc<IterationBase<X,Y,C>, X>() {
      @Override
      public X call(IterationBase<X, Y, C> val) {
        return val.baseCurrent;
      }});
  }
  /**
   * @return an {@link Iterable} that iterates over the values of {@link #baseIndex()}
   */
  public Iterable<Integer> baseIndices() {
    return extracted(new UnaryFunc<IterationBase<X,Y,C>, Integer>() {
      @Override
      public Integer call(IterationBase<X, Y, C> val) {
        return val.baseIndex;
      }});
  }
  /**
   * @return an {@link Iterable} that iterates over pairs (of type {@link Indexed}) that include
   * {@link #index()} and {@link #current()}.  Note that the same value is returned each time, updated.
   */
  public Iterable<Indexed<Y>> indexed() {
    return extracted(new UnaryFunc<IterationBase<X,Y,C>, Indexed<Y>>() {
      final Indexed<Y> indexed = new Indexed<>();
      @Override
      public Indexed<Y> call(IterationBase<X, Y, C> val) {
        return indexed.update(index, current);
      }});
  }
  /**
   * @return an {@link Iterable} that iterates over pairs (of type {@link Indexed}) that include
   * {@link #index()} and {@link #baseCurrent()}.  Note that the index used is {@link #index()} and
   * not {@link #baseIndex()}.  Note that the same value is returned each time, updated.
   */
  public Iterable<Indexed<X>> baseIndexed() {
    return extracted(new UnaryFunc<IterationBase<X,Y,C>, Indexed<X>>() {
      final Indexed<X> indexed = new Indexed<>();
      @Override
      public Indexed<X> call(IterationBase<X, Y, C> val) {
        return indexed.update(index, baseCurrent);
      }});
  }
  /**
   * A helper function that allows subtypes to be declared to be declared as {@link Iterable}s over that
   * subtype. 
   * @param subtypeThis this object at the correct level
   * @return an Iterable that always returns <code>subtypeThis</code>
   */
  protected <ST extends IterationBase<X,Y,C>> Iterator<ST> subtypeIterator(final ST subtypeThis) {
    return extracted(Functions.toConst(subtypeThis)).iterator();
  }
  
  /**
   * Set the post-transformation filter.  All transformed elements that don't pass this filter will be skipped.
   * If there is no transformation asserted, either {@link #filter(Predicate)} or {@link #baseFilter(Predicate)}
   * can be used.  (If both are used, elements must pass both.) 
   * @param filter the {@link Predicate} to apply.  Elements pass if {@link Predicate#test(Object)} returns <code>true</code>
   * @return this object
   */
  protected IterationBase<X,Y,C> filter(Predicate<? super Y> filter) {
    this.filter = filter;
    isFiltered = this.filter != null || baseFilter != null;
    return this;
  }
  /**
   * Set the pre-transformation filter.  All elements from {@link #base()} that don't pass this filter will be skipped.
   * If there is no transformation asserted, either {@link #filter(Predicate)} or {@link #baseFilter(Predicate)}
   * can be used.  (If both are used, elements must pass both.) 
   * @param filter the {@link Predicate} to apply.  Elements pass if {@link Predicate#test(Object)} returns <code>true</code>
   * @return this object
   */
  protected IterationBase<X,Y,C> baseFilter(Predicate<? super X> filter) {
    this.baseFilter = filter;
    isFiltered = this.filter != null || baseFilter != null;
    return this;
  }
  
  @Override
  public String toString() {
    boolean knownDone = doneValid && done; 
    return ObjectDescription.braces()
        .classHead(this)
        .addIf(knownDone, "DONE")
        .add("index", index)
        .addIf(index >= 0, "current", current)
        .addIf(index >= 1, "prior", prior)
        .addIf(index >= 0 && current != baseCurrent, "baseCurrent", baseCurrent)
        .addIf(index >= 1 && prior != basePrior, "basePrior", basePrior)
        .addIf(index != baseIndex, "baseIndex", baseIndex)
        .addIf(index != baseIndex, "nSkipped", nSkipped)
        .addIf(nextValid, "next", next)
        .addIf(nextValid && next != baseNext, "baseNext", baseNext)
        .addIf(filter != null, "Filtered")
        .addIf(baseFilter != null, "Base Filtered")
        .toString();
  }

}
