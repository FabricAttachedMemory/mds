/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.iter;

import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

import com.hpl.erk.func.Functions;
import com.hpl.erk.func.Predicate;
import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.util.CollUtils;
import com.hpl.erk.util.Strings;

/**
 * {@link Iteration} (and its sister classes {@link MappedIteration}, {@link BasedIteration}, and {@link BasedMappedIteration})
 * provide a facility for conveniently iterating over collections (and other {@link Iterable} objects) and arrays.  Each of
 * these classes declares itself to be an {@link Iterable} returning that class, so they can be used in <code>for</code> loops,
 * returning the updated {@link Iteration} object at each iteration, and they can also provide {@link Iterable} objects of
 * other values.  Within each {@link Iteration}, you have access to the {@link #current()} value, the {@link #prior()} value, 
 * the upcomig value (via {@link #peek()}),
 * and the {@link #index()} of the value in the sequence. 
 * <p/>
 * Iterations can be used in two ways.  They can be used directly in the <code>for</code> loop, e.g.,
 * <pre>
 *    <b>for</b> (Iteration&lt;String&gt; iter : Iteration.over(strings)) {
 *      System.out.format("%,5d: %s%n" iter.index(), iter.current());
 *    }
 * </pre>
 * or you can create an Iteration object and iterate over the values directly, e.g.,
 * <pre>
 *    Iteration&lt;String&gt; iter = Iteration.over(strings);
 *    <b>for</b> (String s : iter.values()) {
 *      System.out.format("%,5d: %s%n" iter.index(), s);
 *    }
 * </pre>
 * The latter is more appropriate when you are primarily working with the values and only occasionally need to get
 * access to the index or prior values or to peek at the upcoming value.
 * <p/>
 * {@link #filter(Predicate)} can be used to assert a filter on the values.  Only those elements for which the predicate
 * returns <code>true</code> will be yielded. 
 * {@link #filter(Predicate)} return <code>this</code>, so it can be applied to the result of {@link #over(Iterable)}, as
 * in
 * <pre>
 *    Iteration&lt;String&gt; iter = Iteration.over(strings).filter(Strings.notEmpty());
 * </pre>
 * When filters are used, {@link #index()} returns the number of times {@link #next()} has succeeded, 
 * <b>not</b> the index of the current element in the underlying sequence.  For that, use {@link #baseIndex()}.  
 * {@link #nSkipped()} returns the number of elements that failed to pass the filter in the most recent call to
 * {@link #next()}.
 * <p/>
 * You can iterate over the current values by calling {@link #values()} and over the values of {@link #baseIndex()} 
 * (the index in the base sequence when filtering is used) by calling {@link #baseIndices()}.
 * <p/>
 * An {@link Iteration} also has {@link Iterator}-like functions. {@link #hasNext()} returns <code>true</code> if 
 * a subsequent call to {@link #next()} would succeed,
 * {@link #next()} changes the state of the object to reflect the next element and returns the new value of {@link #current()},
 * and {@link #removeCurrent()} removes the current object from the underlying sequence.  Note that unlike with {@link Iterator#next()}
 * {@link #removeCurrent()} will throw an {@link IllegalStateException} if it is called if the Iteration {@link #isFiltered()}
 * and {@link #hasNext()} has been called since the last call to {@link #next()}.  Note also that if you call {@link #removeCurrent()}
 * on an Iteration created by {@link Iteration#over(Object[])}, the list backed by the array will throw an
 * {@link UnsupportedOperationException}.
 * <p/> {@link #prior()} and {@link #peek()} will throw exceptions if the corresponding element does not exist.
 * {@link #safePeek()} and {@link #safePrior()} return <code>null</code> instead in that circumstance.
 * <p/>
 * A {@link MappedIteration} is like an {@link Iteration}, but it contains a {@link UnaryFunc} that converts values in 
 * the base sequence into new values, possibly of a different type.  In addition to the methods described above, a 
 * MappedIteration also provides {@link #baseCurrent()}, {@link #basePrior()}, and {@link #peekBase()} (and {@link #safeBasePrior()}
 * and {@link #safePeekBase()})
 * to access the pre-transformation values and
 * {@link #baseValues()} to iterate through them.
 * They also accept a {@link #baseFilter(Predicate)} that is used to filter out elements before the transformation takes place.
 * (As with {@link #filter(Predicate)}, elements for which the predicate returns <code>true</code> are retained.)
 * {@link MappedIteration} objects are created by calling {@link Iteration#over(Iterable, UnaryFunc)}, as in
 * <pre>
 *    for (MappedIteration&lt;String,String&gt; iter 
 *           : Iteration.over(strings, Strings.toLowerCase()) {
 *      ... 
 *    }
 * </pre>
 * The classes {@link BasedIteration} and {@link BasedMappedIteration} are identical to {@link Iteration} and 
 * {@link MappedIteration} except that they have an extra type parameter of the actual type of the Iterable passed in
 * so that {@link #base()} will return an object of that type.  This can be useful when you need to refer to an
 * underlying collection during the loop, but was ugly to have to require the programmer to specify it all the time (even as
 * "?"), so it isn't required unless you ask for it.  These classes are obtained by calling {@link Iteration#overBased(Iterable)}
 * and {@link Iteration#overBased(Iterable, UnaryFunc)} (and their array variants) respectively.
 * 
 * 
 * 
 * 
 * 
 *
 * @param <T> The type of objects in the underlying sequence
 */
public class Iteration<T> extends IterationBase<T, T, Iterable<? extends T>> implements Iterable<Iteration<T>> {
  private Iteration(Iterable<? extends T> base) {
    super(base, Functions.<T>identity());
  }

  @Override
  public Iterator<Iteration<T>> iterator() {
    return subtypeIterator(this);
  }
  
  @Override
  public Iteration<T> filter(Predicate<? super T> filter) {
    super.filter(filter);
    return this;
  }
  
  /**
   * Create a new {@link Iteration} over a provided {@link Iterable}.
   * Its {@link #base()} will be of type {@link Iterable}.
   * @param base the base {@link Iterable}
   * @return a new {@link Iteration} over <code>base</code>
   */
  public static <T> Iteration<T> over(Iterable<? extends T> base) {
    return new Iteration<>(base);
  }
  
  /**
   * Create a new {@link Iteration} over a provided  array
   * Its {@link #base()} will be of type {@link Iterable}.
   * @param base an array underlying the base {@link Iterable}
   * @return a new {@link Iteration} over <code>base</code>
   */
  public static <T> Iteration<T> over(T[] array) {
    return over(Arrays.asList(array));
  }
  
  /**
   * Create a new {@link MappedIteration} over a provided {@link Iterable} using a {@link UnaryFunc}
   * to map between {@link #baseCurrent()} and {@link #current()}.  
   * Its {@link #base()} will be of type {@link Iterable}.
   * @param base the base {@link Iterable}
   * @param transformer the transformation to use
   * @return a new {@link MappedIteration} over <code>base</code>
   */
  public static <X,T> MappedIteration<X, T> over(Iterable<? extends X> base, 
                                                 UnaryFunc<? super X, ? extends T> transformer) {
    return MappedIteration.over(base, transformer);
  }
  /**
   * Create a new {@link MappedIteration} over a provided array using a {@link UnaryFunc}
   * to map between {@link #baseCurrent()} and {@link #current()}.  
   * Its {@link #base()} will be of type {@link Iterable}.
   * @param array the array underlying base {@link Iterable}
   * @param transformer the transformation to use
   * @return a new {@link MappedIteration} over <code>base</code>
   */
  public static <X,T> MappedIteration<X, T> over(X[] array, 
                                                 UnaryFunc<? super X, ? extends T> transformer) {
    return over(Arrays.asList(array), transformer);
  }
  
  /**
   * Create a new {@link BasedIteration} over a provided {@link Iterable}.
   * Its {@link #base()} will be of the actual type passed in.
   * @param base the base {@link Iterable}
   * @return a new {@link BasedIteration} over <code>base</code>
   */
  public static <T, C extends Iterable<? extends T>> BasedIteration<T, C> overBased(C base) {
    return BasedIteration.over(base);
  }
  /**
   * Create a new {@link BasedIteration} over a provided array.
   * Its {@link #base()} will be a {@link List} of the element type of the array.
   * @param array the array underlying base {@link List }
   * @return a new {@link BasedIteration} over <code>base</code>
   */
  public static <T, C extends T> BasedIteration<T, List<C>> overBased(C[] array) {
    return overBased(Arrays.asList(array));
  }
  
  /**
   * Create a new {@link BasedMappedIteration} over a provided {@link Iterable} using a {@link UnaryFunc}
   * to map between {@link #baseCurrent()} and {@link #current()}.  
   * Its {@link #base()} will be of the actual type passed in.
   * @param base the base {@link Iterable}
   * @param transformer the transformation to use
   * @return a new {@link BasedMappedIteration} over <code>base</code>
   */
  public static <X,T,C extends Iterable<? extends X>>
  BasedMappedIteration<X, T, C> overBased(C base, UnaryFunc<? super X, ? extends T> transformer) {
    return BasedMappedIteration.over(base, transformer);
  }
  
  /**
   * Create a new {@link BasedMappedIteration} over a provided array using a {@link UnaryFunc}
   * to map between {@link #baseCurrent()} and {@link #current()}.  
   * Its {@link #base()} will be a {@link List} of the element type of the array.
   * @param array the array underlying base {@link List }
   * @param transformer the transformation to use
   * @return a new {@link BasedMappedIteration} over <code>base</code>
   */
  public static <X,T,C extends X>
  BasedMappedIteration<X, T, List<C>> overBased(C[] base, UnaryFunc<? super X, ? extends T> transformer) {
    return overBased(Arrays.asList(base), transformer);
  }
  
  
  public static void main(String[] args) {
    List<String> list = CollUtils.listOf("abc", "d", "e", "fg", "hij", "", "k", "lmn");
    Predicate<String> filter = Functions.not(Strings.isEmpty());
    for (Iteration<String> iter : Iteration.over(list).filter(filter)) {
      System.out.format("%s%n", iter);
    }
    System.out.format("-----------%n");
    for (MappedIteration<String, Integer> iter : Iteration.over(list, Strings.length()).baseFilter(filter)) {
      System.out.format("%s%n", iter);
    }
    System.out.format("-----------%n");
    for (String iter : Iteration.over(list).values()) {
      System.out.format("%s%n", iter);
    }
    System.out.format("-----------%n");
    for (Indexed<String> iter : Iteration.over(list).indexed()) {
      System.out.format("%s%n", iter);
    }
    System.out.format("-----------%n");
    {
      Iteration<String> iter = Iteration.over(list);
      for (String s : iter.values()) {
        System.out.format("%,d: %s (%s)%n", iter.index(), s, iter.safePeek());
      }
    }
    
    Iteration<String> iter = Iteration.over(list);
    @SuppressWarnings("unused")
    Iterable<? extends String> iterBase = iter.base();
    
    BasedIteration<String, List<String>> bmi = Iteration.overBased(list);
    @SuppressWarnings("unused")
    List<String> bmiBase = bmi.base();
  }

}
