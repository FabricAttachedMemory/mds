/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.permutations;

import java.util.Arrays;
import java.util.BitSet;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import cern.colt.GenericSorting;
import cern.colt.Swapper;
import cern.colt.function.IntComparator;

import com.hpl.erk.adt.Deck;
import com.hpl.erk.adt.Deck.OnEmpty;
import com.hpl.erk.adt.IndexDeck;
import com.hpl.erk.chain.Chain;
import com.hpl.erk.formatters.SeqFormatter;
import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.func.UnaryFuncToDouble;
import com.hpl.erk.func.UnaryFuncToInt;
import com.hpl.erk.func.UnaryFuncToLong;
import com.hpl.erk.util.ArrayUtils;
import com.hpl.erk.util.CollUtils;

public class Permutation implements Iterable<Integer> {
  private final int[] perm;
  
  public final class State {
    private final BitSet bits = new BitSet(perm.length);
    private int last = -1;
    
    void clear() {
      bits.clear();
      last = -1;
    }
    
    int nextLeader() {
      return bits.nextClearBit(last+1);
    }
    
    void did(int pos) {
      bits.set(pos);
    }
    
    @Override
    public String toString() {
      return String.format("%,d @ %s", last, bits);
    }
  }
  
  public Permutation(int[] perm) {
    this.perm = perm;
  }
  
  /** @return a new permutation that is the reverse order of the current one.  mysorter = Permutations.toSorted(nums).reverse(); */
  public Permutation reverse() {
	  int[] tmp = Arrays.copyOf(perm, perm.length);
	  ArrayUtils.reverse(tmp);
	  return new Permutation(tmp);
  }
  
  /** @return a new permutation that is a prefix of the current one.  lowScoreSelector = Permutations.toSorted(nums).prefix(nums.length/2); */
  public Permutation prefix(int newSize) {
	  assert newSize <= perm.length;
	  int[] tmp = new int[newSize];
	  System.arraycopy(perm, 0, tmp, 0, newSize);
	  return new Permutation(tmp);
  }

  public static Permutation toSorted(final IntComparator cptr, int n) {
    final int[] perm = new int[n];
    for (int i=0; i<n; i++) {
      perm[i] = i;
    }
    final Swapper swapper = new Swapper() {
      @Override
      public void swap(int arg0, int arg1) {
        int tmp = perm[arg0];
        perm[arg0] = perm[arg1];
        perm[arg1] = tmp;
      }
    };
    final IntComparator mappedCptr = new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return cptr.compare(perm[arg0], perm[arg1]);
      }
    };
    GenericSorting.quickSort(0, n, mappedCptr, swapper);
    return new Permutation(perm);
  }

  public static Permutation toSorted(Sortable sortable) {
    return toSorted(sortable.comparator(), sortable.size());
  }
  
  public static <T extends Comparable<? super T>> Permutation toSorted(final List<T> list) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return list.get(arg0).compareTo(list.get(arg1));
      }
    }, list.size());
  }
  public static <T> Permutation toSorted(final List<T> list, final Comparator<? super T> c) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return c.compare(list.get(arg0), list.get(arg1));
      }
    }, list.size());
  }
  
  public static <T,M extends Comparable<? super M>> Permutation toSorted(final List<T> list, final UnaryFunc<? super T, ? extends M> func) {
    List<M> mapped = CollUtils.map(list, func);
    return toSorted(mapped);
  }
  public static <T,M> Permutation toSorted(final List<T> list, final UnaryFunc<? super T, ? extends M> func, final Comparator<? super M> c) {
    List<M> mapped = CollUtils.map(list, func);
    return toSorted(mapped, c);
  }
  public static <T> Permutation toSorted(final List<T> list, final UnaryFuncToInt<? super T> func) {
    int[] array = CollUtils.mappedArrayFrom(list, func);
    return toSorted(array);
  }
  public static <T> Permutation toSorted(final List<T> list, final UnaryFuncToLong<? super T> func) {
    long[] array = CollUtils.mappedArrayFrom(list, func);
    return toSorted(array);
  }
  public static <T> Permutation toSorted(final List<T> list, final UnaryFuncToDouble<? super T> func) {
    double[] array = CollUtils.mappedArrayFrom(list, func);
    return toSorted(array);
  }

  public static <T> Permutation toSorted(final T[] array, final Comparator<? super T> c) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return c.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }

  public static <T extends Comparable<? super T>> Permutation toSorted(final T[] array) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return array[arg0].compareTo(array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final long[] array) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return Long.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final int[] array) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return Integer.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final short[] array) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return Short.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final byte[] array) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return Byte.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final double[] array) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return Double.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final float[] array) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return Float.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final char[] array) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return Character.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  
  public static Permutation toSorted(final long[] array, final Comparator<? super Long> c) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return c.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final int[] array, final Comparator<? super Integer> c) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return c.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final short[] array, final Comparator<? super Short> c) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return c.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final byte[] array, final Comparator<? super Byte> c) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return c.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final double[] array, final Comparator<? super Double> c) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return c.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final float[] array, final Comparator<? super Float> c) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return c.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final char[] array, final Comparator<? super Character> c) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return c.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }
  public static Permutation toSorted(final boolean[] array, final Comparator<? super Boolean> c) {
    return toSorted(new IntComparator() {
      @Override
      public int compare(int arg0, int arg1) {
        return c.compare(array[arg0], array[arg1]);
      }
    }, array.length);
  }

  public static Permutation random(int len) {
    final IndexDeck deck = Deck.ofIntsTo(len);
    final int[] perm = new int[len];
    deck.dealInto(perm, OnEmpty.THROW);
    return new Permutation(perm);
  }
  
  public static Permutation identity(int len) {
    final int[] perm = new int[len];
    for (int i=0; i<len; i++) {
      perm[i] = i;
    }
    return new Permutation(perm);
  }
  
  public State newState() {
    return new State();
  }
  
  private final class Rotator {
    final State state;
    final Permuter permuter;
    public Rotator(State state, Permuter permuter) {
      this.state = state == null ? newState() : state;
      this.permuter = permuter;
    }
    
    void rotateFrom(int leader) {
      int next = perm[leader];
      if (next != leader) {
        permuter.remember(leader);
        int last;
        for (last = leader; next != leader; last = next, next = perm[next]) {
          permuter.move(next, last);
          state.did(next);
          last = next;
        }
        permuter.moveRemembered(last);
      }
      state.did(leader);
    }
    
    void permute() {
      state.clear();
      final int len = perm.length;
      for (int leader = state.nextLeader(); leader < len; leader = state.nextLeader()) {
        rotateFrom(leader);
      }
    }
  }
  
  public void permute(Permuter p, State state) {
    Rotator r = new Rotator(state, p);
    r.permute();
  }
  public void permute(Permuter p) {
    permute(p, null);
  }  

  public void permute(Permutable p, State state) {
    permute(p.getPermuter(), state);
  }
  public void permute(Permutable p) {
    permute(p, null);
  }  
  
  public void permute(final Object[] array, State state) {
    permute(new ObjArrayPermuter(array), state);
  }
  
  public <T> void permute(final T[] array) {
    permute(array, null);
  }

  public <T> void permute(final List<T> list, State state) {
    permute(new ListPermuter<>(list), state);
  }
  public <T> void permute(final List<T> list) {
    permute(list, null);
  }
  
  public void permute(final int[] array, State state) {
    permute(new IntArrayPermuter(array), state);
  }
  public void permute(final int[] array) {
    permute(array, null);
  }
  
  public void permute(final long[] array, State state) {
    permute(new LongArrayPermuter(array), state);
  }
  public void permute(final long[] array) {
    permute(array, null);
  }
  
  public void permute(final short[] array, State state) {
    permute(new ShortArrayPermuter(array), state);
  }
  public void permute(final short[] array) {
    permute(array, null);
  }
  
  public void permute(final byte[] array, State state) {
    permute(new ByteArrayPermuter(array), state);
  }
  public void permute(final byte[] array) {
    permute(array, null);
  }
  
  public void permute(final char[] array, State state) {
    permute(new CharArrayPermuter(array), state);
  }
  public void permute(final char[] array) {
    permute(array, null);
  }
  
  public void permute(final double[] array, State state) {
    permute(new DoubleArrayPermuter(array), state);
  }
  public void permute(final double[] array) {
    permute(array, null);
  }
  
  public void permute(final float[] array, State state) {
    permute(new FloatArrayPermuter(array), state);
  }
  public void permute(final float[] array) {
    permute(array, null);
  }
  
  public void permute(final boolean[] array, State state) {
    permute(new BooleanArrayPermuter(array), state);
  }
  public void permute(final boolean[] array) {
    permute(array, null);
  }
  
  public void permute(final BitSet bits, State state) {
    permute(new BitSetPermuter(bits), state);
  }
  public void permute(final BitSet bits) {
    permute(bits, null);
  }
  
  private static Permuter permuterFor(Object a) {
    if (a instanceof List) {
      return ListPermuter.make((List<?>)a);
    }
    if (a instanceof BitSet) {
      return new BitSetPermuter((BitSet)a);
    }
    final Class<? extends Object> arrayClass = a.getClass();
    if (!arrayClass.isArray()) {
      throw new IllegalArgumentException(String.format("Parameter '%s' is %s, not permutable", a, arrayClass));
    }
    Class<?> cptClass = arrayClass.getComponentType();
    if (!cptClass.isPrimitive()) {
      return new ObjArrayPermuter((Object[])a);
    }
    if (cptClass == Long.TYPE) {
      return new LongArrayPermuter((long[])a);
    }
    if (cptClass == Integer.TYPE) {
      return new IntArrayPermuter((int[])a);
    }
    if (cptClass == Double.TYPE) {
      return new DoubleArrayPermuter((double[])a);
    }
    if (cptClass == Byte.TYPE) {
      return new ByteArrayPermuter((byte[])a);
    }
    if (cptClass == Character.TYPE) {
      return new CharArrayPermuter((char[])a);
    }
    if (cptClass == Short.TYPE) {
      return new ShortArrayPermuter((short[])a);
    }
    if (cptClass == Float.TYPE) {
      return new FloatArrayPermuter((float[])a);
    }
    if (cptClass == Boolean.TYPE) {
      return new BooleanArrayPermuter((boolean[])a);
    }
    throw new IllegalArgumentException(String.format("Unknown primitive array type", arrayClass));
  }
  
  public void permuteAll(Object ...arrays) {
    State state = newState();
    permuteAllWithState(state, arrays);
  }

  private void permuteAllWithState(State state, Object... arrays) {
    if (state == null) {
      state = newState();
    }
    for (Object a : arrays) {
      Permuter p = permuterFor(a);
      Rotator r = new Rotator(state, p);
      r.permute();
    }
  }

  @Override
  public Iterator<Integer> iterator() {
    return new Iterator<Integer>() {
      int next = 0;
      @Override
      public void remove() {
        throw new UnsupportedOperationException();
      }
      
      @Override
      public Integer next() {
        return perm[next++];
      }
      
      @Override
      public boolean hasNext() {
        return next < perm.length;
      }
    };
  }
  
  public int[] toArray() {
    return Arrays.copyOf(perm, perm.length);
  }
  
  @Override
  public String toString() {
    return String.format("Perm"+SeqFormatter.bracketList().format(Chain.from(perm)));
  }

}
