/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.hpl.erk.func.Predicate;
import com.hpl.erk.func.UnaryFunc;

public class Patterns {
  private static final Map<String, Pattern> constantPatterns = new HashMap<>();
  public static final Pattern NL_PATTERN = singleton("\n");
  public static final Pattern TAB_PATTERN = singleton("\t");
  public static final Pattern WS_PATTERN = singleton("\\p{Space}+");
  public static final Pattern INITIAL_SPACE_PATTERN = singleton("^\\p{Space}*");
  public static final Pattern TRAILING_SPACE_PATTERN = singleton("\\p{Space}*$");
  public static final Pattern COMMA_PATTERN = singleton(",");
  
  
  private Patterns() {}
  
  public static interface Action {
    /**
     * 
     * @param matcher
     * @return <code>true</code> if the action handled the input.
     */
    boolean apply(Matcher matcher);
  }
  
  public static abstract class Rule implements Action {
    public final Pattern pattern;

    protected Rule(Pattern pattern) {
      this.pattern = pattern;
    }
    
    public boolean findIn(String s) {
      Matcher m = pattern.matcher(s);
      if (m.find()) {
        return apply(m);
      }
      return false;
    }
    
    public boolean match(String s) {
      Matcher m = pattern.matcher(s);
      if (m.matches()) {
        return apply(m);
      }
      return false;
    }
    
    public void forEachMatch(String s) {
      Matcher m = pattern.matcher(s);
      while (m.find()) {
        if (apply(m)) {
          return;
        }
      }
    }
  }
  
  public static class RuleSet {
    private final List<Rule> rules;
    public RuleSet(Rule ...rules) {
      this.rules = new ArrayList<>(Arrays.asList(rules));
    }
    
    public RuleSet add(Rule rule) {
      rules.add(rule);
      return this;
    }
    
    public RuleSet add(Pattern pattern, Action action) {
      return add(rule(pattern, action));
    }
    public RuleSet add(String regexp, Action action) {
      return add(rule(regexp, action));
    }
    
    public boolean dispatch(String s) {
      for (Rule rule : rules) {
        if (rule.findIn(s)) {
          return true;
        }
      }
      return false;
    }
  }
  
  public static Rule rule(Pattern pattern, final Action action) {
    return new Rule(pattern) {
      @Override
      public boolean apply(Matcher matcher) {
        return action.apply(matcher);
      }
    };
  }
  
  public static Rule rule(String regexp, Action action) {
    return rule(Pattern.compile(regexp), action);
  }
  
  public static void forEachMatch(Pattern pattern, String s, Action action) {
    rule(pattern, action).forEachMatch(s);
  }
  public static void forEachMatch(String regexp, String s, Action action) {
    rule(regexp, action).forEachMatch(s);
  }
  public static boolean ifFind(Pattern pattern, String s, Action action) {
    return rule(pattern, action).findIn(s);
  }
  public static boolean ifFind(String regexp, String s, Action action) {
    return rule(regexp, action).findIn(s);
  }
  public static boolean ifMatches(Pattern pattern, String s, Action action) {
    return rule(pattern, action).match(s);
  }
  public static boolean ifMatches(String regexp, String s, Action action) {
    return rule(regexp, action).match(s);
  }
  
  public static Pattern singleton(String regexp) {
    synchronized (constantPatterns) {
      Pattern p = constantPatterns.get(regexp);
      if (p == null) {
        p = Pattern.compile(regexp);
        constantPatterns.put(regexp, p);
      }
      return p;
    }
  }
  
  public static Pattern caseInsensitive(String regexp) {
    return Pattern.compile(regexp, Pattern.CASE_INSENSITIVE);
  }
  
  public static Predicate<CharSequence> matches(final Pattern p) {
    return new Predicate<CharSequence>() {
      @Override
      public boolean test(CharSequence val) {
        return p.matcher(val).matches();
      }
    };
  }
  public static Predicate<CharSequence> matches(String regexp, int flags) {
    return matches(Pattern.compile(regexp, flags));
  }
  public static Predicate<CharSequence> matches(String regexp) {
    return matches(Pattern.compile(regexp));
  }
  public static Predicate<CharSequence> contains(final Pattern p) {
    return new Predicate<CharSequence>() {
      @Override
      public boolean test(CharSequence val) {
        return p.matcher(val).find();
      }
    };
  }
  public static Predicate<CharSequence> contains(String regexp, int flags) {
    return contains(Pattern.compile(regexp, flags));
  }
  public static Predicate<CharSequence> contains(String regexp) {
    return contains(Pattern.compile(regexp));
  }
  public static UnaryFunc<String, Pattern> compile() {
    return new UnaryFunc<String, Pattern>() {
      @Override
      public Pattern call(String regexp) {
        return Pattern.compile(regexp);
      }
    };
  }
  public static UnaryFunc<String, Pattern> compile(final int flags) {
    return new UnaryFunc<String, Pattern>() {
      @Override
      public Pattern call(String regexp) {
        return Pattern.compile(regexp, flags);
      }
    };
  }
  public static UnaryFunc<String, Pattern> compileCaseInsensitive() {
    return compile(Pattern.CASE_INSENSITIVE);
  }

  public static UnaryFunc<String, String> replacing(final Pattern pattern, final String replacement) {
    return new UnaryFunc<String, String>() {
      @Override
      public String call(String val) {
        Matcher matcher = pattern.matcher(val);
        return matcher.replaceAll(replacement);
      }
    };
  }
  

}
