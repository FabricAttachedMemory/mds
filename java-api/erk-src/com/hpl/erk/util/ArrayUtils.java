/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.util;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.List;

import com.hpl.erk.Portion;
import com.hpl.erk.func.Functions;
import com.hpl.erk.func.NullaryFunc;
import com.hpl.erk.func.NullaryFuncToBoolean;
import com.hpl.erk.func.NullaryFuncToDouble;
import com.hpl.erk.func.NullaryFuncToInt;
import com.hpl.erk.func.NullaryFuncToLong;
import com.hpl.erk.func.Predicate;
import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.func.UnaryFuncToBoolean;
import com.hpl.erk.func.UnaryFuncToDouble;
import com.hpl.erk.func.UnaryFuncToInt;
import com.hpl.erk.func.UnaryFuncToLong;
import com.hpl.erk.func.UnaryIntFuncToBoolean;
import com.hpl.erk.func.UnaryIntFuncToDouble;
import com.hpl.erk.func.UnaryIntFuncToInt;
import com.hpl.erk.func.UnaryIntFuncToLong;
import com.hpl.erk.iter.Iteration;

public class ArrayUtils {
  public static <T> T[] fillWith(Class<? extends T> clss, T[] array) {
    return fillWith(Functions.makeNew(clss), array);
  }
  public static <T,X> T[] fillWith(Class<? extends T> clss, T[] array, X arg1) {
    return fillWith(Functions.makeNew(clss, arg1), array);
  }
  public static <T,X,Y> T[] fillWith(Class<? extends T> clss, T[] array, X arg1,Y arg2) {
    return fillWith(Functions.makeNew(clss, arg1, arg2), array);
  }

  public static <T> T[] fillWith(NullaryFunc<? extends T> func, T[] array) {
    if (array == null) {
      return null;
    }
    for (int i=0; i<array.length; i++) {
      array[i] = func.call();
    }
    return array;
  }
  
  public static int[] fillWith(NullaryFuncToInt func, int[] array) {
    if (array == null) {
      return null;
    }
    for (int i=0; i<array.length; i++) {
      array[i] = func.primCall();
    }
    return array;
  }
  public static long[] fillWith(NullaryFuncToLong func, long[] array) {
    if (array == null) {
      return null;
    }
    for (int i=0; i<array.length; i++) {
      array[i] = func.primCall();
    }
    return array;
  }
  public static double[] fillWith(NullaryFuncToDouble func, double[] array) {
    if (array == null) {
      return null;
    }
    for (int i=0; i<array.length; i++) {
      array[i] = func.primCall();
    }
    return array;
  }
  public static boolean[] fillWith(NullaryFuncToBoolean func, boolean[] array) {
    if (array == null) {
      return null;
    }
    for (int i=0; i<array.length; i++) {
      array[i] = func.primCall();
    }
    return array;
  }
  public static <T> T[] fillWith(UnaryFunc<Integer, ? extends T> func, T[] array) {
    if (array == null) {
      return null;
    }
    for (int i=0; i<array.length; i++) {
      array[i] = func.call(i);
    }
    return array;
  }
  
  public static int[] fillWith(UnaryIntFuncToInt func, int[] array) {
    if (array == null) {
      return null;
    }
    for (int i=0; i<array.length; i++) {
      array[i] = func.primCall(i);
    }
    return array;
  }
  public static long[] fillWith(UnaryIntFuncToLong func, long[] array) {
    if (array == null) {
      return null;
    }
    for (int i=0; i<array.length; i++) {
      array[i] = func.primCall(i);
    }
    return array;
  }
  public static double[] fillWith(UnaryIntFuncToDouble func, double[] array) {
    if (array == null) {
      return null;
    }
    for (int i=0; i<array.length; i++) {
      array[i] = func.primCall(i);
    }
    return array;
  }
  public static boolean[] fillWith(UnaryIntFuncToBoolean func, boolean[] array) {
    if (array == null) {
      return null;
    }
    for (int i=0; i<array.length; i++) {
      array[i] = func.primCall(i);
    }
    return array;
  }
  
  
  
  @SuppressWarnings("unchecked")
  public static <T> T[] newArray(Class<T> arrayClass, int len) {
    return (T[])Array.newInstance(arrayClass, len);
  }
  public static <T> T[] newArray(Class<T> arrayClass, int len, NullaryFunc<? extends T> creator) {
    return fillWith(creator, newArray(arrayClass, len));
  }

  public static <T> T[] newArray(Class<T> arrayClass, int len, Class<? extends T> valClass) {
    return fillWith(valClass, newArray(arrayClass, len));
  }
  public static <T,X> T[] newArray(Class<T> arrayClass, int len, Class<? extends T> valClass, X arg1) {
    return fillWith(valClass, newArray(arrayClass, len), arg1);
  }
  public static <T,X,Y> T[] newArray(Class<T> arrayClass, int len, Class<? extends T> valClass, X arg1, Y arg2) {
    return fillWith(valClass, newArray(arrayClass, len), arg1, arg2);
  }
  
  
//  private static final Object[] empty = new Object[0];
//  @SuppressWarnings("unchecked")
//  public static <T> T[] empty() {
//    return (T[])empty;
//  }
  public static <T> T[] no(Class<T> clss) {
    return newArray(clss, 0);
  }
  
  public static <T> int lengthOf(T[] array) {
    return array == null ? 0 : array.length;
  }
  
  public static int[] ints(final int min, final int max, final int step) {
    int n = (max-min)/step+1;
    if (n < 0) {
      return new int[0];
    }
    int[] array = new int[n];
    int next = min;
    for (int i=0; i<n; i++) {
      array[i] = next;
      next += step;
    }
    return array;
  }
  
  public static int[] ints(int min, int max) {
    return ints(min, max, min > max ? -1 : 1);
  }
  
  public static int[] zeroThrough(int max) {
    return ints(0, max, 1);
  }
  public static int[] zeroTo(int max) {
    return ints(0, max-1, 1);
  }
  public static int[] oneThrough(int max) {
    return ints(1, max, 1);
  }
  public static int[] oneTo(int max) {
    return ints(1, max-1, 1);
  }
  
  public static <X,Y> Y[] map(X[] array, UnaryFunc<? super X, ? extends Y> func, Class<? extends Y> clss) {
    if (array == null) {
      return null;
    }
    Y[] newArray = newArray(clss, array.length);
    for (Iteration<X> iter : Iteration.over(array)) {
      Y mapped = func.call(iter.current());
      newArray[iter.index()] = mapped;
    }
    return newArray;
  }
  
  public static <X> int[] map(X[] array, UnaryFuncToInt<? super X> func) {
    if (array == null) {
      return null;
    }
    int[] newArray = new int[array.length];
    for (Iteration<X> iter : Iteration.over(array)) {
      int mapped = func.primCall(iter.current());
      newArray[iter.index()] = mapped;
    }
    return newArray;
  }
  public static <X> long[] map(X[] array, UnaryFuncToLong<? super X> func) {
    if (array == null) {
      return null;
    }
    long[] newArray = new long[array.length];
    for (Iteration<X> iter : Iteration.over(array)) {
      long mapped = func.primCall(iter.current());
      newArray[iter.index()] = mapped;
    }
    return newArray;
  }
  public static <X> double[] map(X[] array, UnaryFuncToDouble<? super X> func) {
    if (array == null) {
      return null;
    }
    double[] newArray = new double[array.length];
    for (Iteration<X> iter : Iteration.over(array)) {
      double mapped = func.primCall(iter.current());
      newArray[iter.index()] = mapped;
    }
    return newArray;
  }
  public static <X> boolean[] map(X[] array, UnaryFuncToBoolean<? super X> func) {
    if (array == null) {
      return null;
    }
    boolean[] newArray = new boolean[array.length];
    for (Iteration<X> iter : Iteration.over(array)) {
      boolean mapped = func.primCall(iter.current());
      newArray[iter.index()] = mapped;
    }
    return newArray;
  }
  public static <X> void reverse(X[] array) {
    for (int i=0, j=array.length-1; i<j; i++,j--) {
      X tmp = array[i];
      array[i] = array[j];
      array[j] = tmp;
    }
  }
  public static void reverse(int[] array) {
    for (int i=0, j=array.length-1; i<j; i++,j--) {
      int tmp = array[i];
      array[i] = array[j];
      array[j] = tmp;
    }
  }
  public static void reverse(long[] array) {
    for (int i=0, j=array.length-1; i<j; i++,j--) {
      long tmp = array[i];
      array[i] = array[j];
      array[j] = tmp;
    }
  }
  public static void reverse(short[] array) {
    for (int i=0, j=array.length-1; i<j; i++,j--) {
      short tmp = array[i];
      array[i] = array[j];
      array[j] = tmp;
    }
  }
  public static void reverse(byte[] array) {
    for (int i=0, j=array.length-1; i<j; i++,j--) {
      byte tmp = array[i];
      array[i] = array[j];
      array[j] = tmp;
    }
  }
  public static void reverse(char[] array) {
    for (int i=0, j=array.length-1; i<j; i++,j--) {
      char tmp = array[i];
      array[i] = array[j];
      array[j] = tmp;
    }
  }
  public static void reverse(double[] array) {
    for (int i=0, j=array.length-1; i<j; i++,j--) {
      double tmp = array[i];
      array[i] = array[j];
      array[j] = tmp;
    }
  }
  public static void reverse(float[] array) {
    for (int i=0, j=array.length-1; i<j; i++,j--) {
      float tmp = array[i];
      array[i] = array[j];
      array[j] = tmp;
    }
  }
  public static void reverse(boolean[] array) {
    for (int i=0, j=array.length-1; i<j; i++,j--) {
      boolean tmp = array[i];
      array[i] = array[j];
      array[j] = tmp;
    }
  }

  public static <T> T[] filter(T[] array, Predicate<? super T> pred) {
    return filter(array, pred, Portion.all());
  }
  public static <T> T[] filter(T[] array, Predicate<? super T> pred, Portion expectation) {
    if (array == null) {
      return null;
    }
    if (expectation == null) {
      expectation = Portion.all();
    }
    List<T> kept = new ArrayList<T>(expectation.of(array.length));
    for (T elt : array) {
      if (pred.test(elt)) {
        kept.add(elt);
      }
    }
    /*
     * This isn't quite right.  Because of the Java type rules, a T[] may actually be something that
     * extends T, so getClass().getComponentType() may not actually be a Class<T>, but rather
     * Class<? extends T>, which means that the array returned will, in fact, be the real type of the
     * array, but that's about all you can do with Java covariant arrays. 
     */
    @SuppressWarnings("unchecked")
    final Class<T> cType = (Class<T>) array.getClass().getComponentType();
    return CollUtils.arrayFrom(kept, cType);
  }



  
  
  



  /** @return max value in array; else Long.MIN_VALUE if empty */
  public static long max(long[] array) {
	  return max(array, array.length);
  }
  /** @return max value in array[0..len-1]; else Long.MIN_VALUE if empty */
  public static long max(long[] array, int len) {
	  long max = Long.MIN_VALUE;
	  for (int i=0; i<len; i++) {
		  long v = array[i];
		  if (max < v) {
			  max = v;
		  }
	  }
	  return max;
  }

  /** @return min value in array; else Long.MAX_VALUE if empty */
  public static long min(long[] array) {
	  return min(array, array.length);
  }
  /** @return min value in array[0..len-1]; else Long.MAX_VALUE if empty */
  public static long min(long[] array, int len) {
	  long min = Long.MAX_VALUE;
	  for (int i=0; i<len; i++) {
		  long v = array[i];
		  if (min > v) {
			  min = v;
		  }
	  }
	  return min;
  }


  /** @return max value in array; else Integer.MIN_VALUE if empty */
  public static int max(int[] array) {
	  return max(array, array.length);
  }
  /** @return max value in array[0..len-1]; else Integer.MIN_VALUE if empty */
  public static int max(int[] array, int len) {
	  int max = Integer.MIN_VALUE;
	  for (int i=0; i<len; i++) {
		  int v = array[i];
		  if (max < v) {
			  max = v;
		  }
	  }
	  return max;
  }

  /** @return min value in array; else Integer.MAX_VALUE if empty */
  public static int min(int[] array) {
	  return min(array, array.length);
  }
  /** @return min value in array[0..len-1]; else Integer.MAX_VALUE if empty */
  public static int min(int[] array, int len) {
	  int min = Integer.MAX_VALUE;
	  for (int i=0; i<len; i++) {
		  int v = array[i];
		  if (min > v) {
			  min = v;
		  }
	  }
	  return min;
  }

  /** @return max value in array; else Double.NEGATIVE_INFINITY if empty */
  public static double max(double[] array) {
	  return max(array, array.length);
  }
  /** @return max value in array[0..len-1]; else Double.NEGATIVE_INFINITY if empty */
  public static double max(double[] array, int len) {
	  double m = Double.NEGATIVE_INFINITY;
	  for (int i = 0; i < len; i++) {
		  double d = array[i];
		  if (m < d) {
			  m = d;
		  }
	  }
	  return m;
  }

  /** @return min value in array; else Double.POSITIVE_INFINITY if empty */
  public static double min(double[] array) {
	  return min(array, array.length);
  }
  /** @return min value in array[0..len-1]; else Double.POSITIVE_INFINITY if empty */
  public static double min(double[] array, int len) {
	  double m = Double.POSITIVE_INFINITY;
	  for (int i = 0; i < len; i++) {
		  double d = array[i];
		  if (m > d) {
			  m = d;
		  }
	  }
	  return m;
  }


  public static double sum(double[] array) {
	  return sum(array, array.length);
  }
  public static double sum(double[] array, int len) {
	  double sum = 0;
	  for (int i = 0; i < len; i++) {
		  sum += array[i];
	  }
	  return sum;
  }

  public static double average(double[] array) {
	  return average(array, array.length);
  }
  public static double average(double[] array, int len) {
	  return sum(array,len) / len;
  }

  public static int sum(int[] array) {
	  return sum(array, array.length);
  }
  public static int sum(int[] array, int len) {
	  int sum = 0;
	  for (int i = 0; i < len; i++) {
		  sum += array[i];
	  }
	  return sum;
  }



  /** @return true iff v is in array[0..len-1] */
  public static boolean in(long v, long[] array) {
	  return in(v, array, array.length);
  }
  /** @return true iff v is in array[0..len-1].  IMPL: linear search */
  public static boolean in(long v, long[] array, int len) {
	  return find(v, array, len) >= 0;
  }

  /** @return first index of v in array by linear search; else -1 */
  public static int find(long v, long[] array) {
	  return find(v, array, array.length);
  }
  /** @return first index of v in array[0..len-1] by linear search; else -1 */
  public static int find(long v, long[] array, int len) {
	  for (int i = 0; i < len; i++) {
		  if (v == array[i]) {
			  return i;
		  }
	  }
	  return -1;
  }


  /** @return true iff v is in array[0..len-1] */
  public static boolean in(int v, int[] array) {
	  return in(v, array, array.length);
  }
  /** @return true iff v is in array[0..len-1].  IMPL: linear search */
  public static boolean in(int v, int[] array, int len) {
	  return find(v, array, len) >= 0;
  }

  /** @return first index of v in array by linear search; else -1 */
  public static int find(int v, int[] array) {
	  return find(v, array, array.length);
  }
  /** @return first index of v in array[0..len-1] by linear search; else -1 */
  public static int find(int v, int[] array, int len) {
	  for (int i = 0; i < len; i++) {
		  if (v == array[i]) {
			  return i;
		  }
	  }
	  return -1;
  }


}
