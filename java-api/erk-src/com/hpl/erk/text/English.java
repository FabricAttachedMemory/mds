/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.text;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.hpl.erk.PatternSwitch;
import com.hpl.erk.chain.Chain;
import com.hpl.erk.formatters.IntFormatter;
import com.hpl.erk.formatters.IntFormatter.MagnitudeFormatter;
import com.hpl.erk.formatters.SeqFormatter;
import com.hpl.erk.formatters.SeqFormatter.Option;
import com.hpl.erk.func.Functions;
import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.text.English.Pronoun.Case;
import com.hpl.erk.util.Patterns;
import com.hpl.erk.util.Strings;


public class English {
  public static interface FormatFunction<W extends Word<W>> {
    public String format(long quantity, W word, FormatChain<W> prior);
  }
  
  public static class FormatChain<W extends Word<W>> {
    private final FormatChain<W> prior;
    private final FormatFunction<W> formatter;
    private final Element<W> element;
    protected FormatChain(FormatFunction<W> formatter, Element<W> element, FormatChain<W> prior) {
      this.formatter = formatter;
      this.element = element;
      this.prior = prior;
    }
    
    protected FormatChain(Element<W> element) {
      this(FormatChain.<W>basicFormatter(), element, null);
    }
    
    FormatChain<W> chain(FormatFunction<W> f) {
      return new FormatChain<W>(f, element, this);
    }
    
    private static <W extends Word<W>> FormatFunction<W> basicFormatter() {
      return new FormatFunction<W>() {
        @Override
        public String format(long quantity, W word, FormatChain<W> prior) {
          return word.format(quantity);
        }};
    }

    public String format(long quantity) {
      return formatter.format(quantity, element.word, prior);
    }
    
  }
  
  public static UnaryFunc<String, String> replaceSuffix(final int size, final String replacement) {
    return new UnaryFunc<String, String>() {
      @Override
      public String call(String val) {
        return Strings.chopFromEnd(size, val)+replacement;
      }
    };
  }
  public static UnaryFunc<String, String> removeSuffix(final int size) {
    return new UnaryFunc<String,String>() {
      @Override
      public String call(String val) {
        return Strings.chopFromEnd(size, val);
      }
      
    };
  }
  public static UnaryFunc<String, String> addSuffix(final String suffix) {
    return new UnaryFunc<String,String>() {
      @Override
      public String call(String val) {
        return val+suffix;
      }
      
    };
  }
  private static enum PartOfSpeech { 
    N() {
      final PatternSwitch<String> rules = PatternSwitch.yielding(String.class)
          .onFind(Patterns.caseInsensitive("ies$"), replaceSuffix(3, "y"))
          .onFind(Patterns.caseInsensitive("ices$"), replaceSuffix(4, "ex"))
          .onFind(Patterns.caseInsensitive("(?:[szc]h|[^aeiou][sz])es$"), removeSuffix(2))
          .onFind(Patterns.caseInsensitive("[^s]s$"), removeSuffix(1))
          .onFind(Patterns.caseInsensitive("men$"), replaceSuffix(3, "man"))
          .onFind(Patterns.caseInsensitive("i$"), replaceSuffix(1, "us"))
          .onFind(Patterns.caseInsensitive("ae"), replaceSuffix(2, "a"))
          .otherwise(Functions.<String>identity());      
      @Override
      protected UnaryFunc<String, String> singularMaker() {
        return rules;
      }

      @Override
      protected InflectedWord<?> newWord(String singular, String plural) {
        return new Noun(singular, plural);
      }
    },
    V() {
      final PatternSwitch<String> rules = PatternSwitch.yielding(String.class)
          .onFind(Patterns.caseInsensitive("[^aeiou]y$"), replaceSuffix(1, "ies"))
          .onFind(Patterns.caseInsensitive("(?:[szc]h|[sz])$"), addSuffix("es"))
          .otherwise(addSuffix("s"));

      @Override
      protected UnaryFunc<String, String> singularMaker() {
        return rules;
      }

      @Override
      protected InflectedWord<?> newWord(String singular, String plural) {
        return new Verb(singular, plural);
      }
    },
    ;
    
    final Map<String, InflectedWord<?>> known = new HashMap<>();
    
    public String regularSingular(String plural) {
      UnaryFunc<String, String> transformer = singularMaker();
      if (transformer != null) {
        String singular = transformer.call(plural);
        if (singular != null) {
          return singular;
        }
      }
      throw new IllegalArgumentException(String.format("%s doesn't know how to make singular for '%s'", this, plural));
    }
    
    protected UnaryFunc<String, String> singularMaker() {
      return null;
    }
    
    public InflectedWord<?> find(String plural) {
      InflectedWord<?> word;
      synchronized (known) {
        word = known.get(plural);
      }
      if (word == null) {
        word = newWord(regularSingular(plural), plural);
        synchronized (known) {
          known.put(plural, word);
        }
      }
      return word;
    }
    
    public <W extends InflectedWord<W>> W find(Class<W> clss, String plural) {
      return clss.cast(find(plural));
    }

    protected abstract InflectedWord<?> newWord(String singular, String plural);
    

    public void setSingular(String plural, String singular) {
      if (singular == null) {
        singular = regularSingular(plural);
      }
      InflectedWord<?> word;
      synchronized (known) {
        word = known.get(plural);
      }
      if (word == null) {
        word = newWord(singular, plural);
        known.put(plural, word);
      } else {
        word.setSingular(singular);
      }
    }
    
    public void setInvariant(String plural) {
      setSingular(plural, plural);
    }
    
  }
  
  public static abstract class Word<W extends Word<W>> {
    public abstract String format(long quantity);
    public abstract Words<W, ?> extend(Words<?,?> prior, long quantity);
    
    public FormatFunction<W> uc() {
      return new FormatFunction<W>() {
        @Override
        public String format(long quantity, W word, FormatChain<W> prior) {
          return prior.format(quantity).toUpperCase();
        }};
    }
    public FormatFunction<W> cap() {
      return new FormatFunction<W>() {
        @Override
        public String format(long quantity, W word, FormatChain<W> prior) {
          return Strings.ucFirst(prior.format(quantity));
        }};
    }
    

  }
  
  public static class Element<W extends Word<W>> {
    W word;
    private FormatChain<W> formatters;

    protected Element(W word) {
      this.word = word;
      formatters = new FormatChain<W>(this);
    }

    public String format(long quantity) {
      return formatters.format(quantity);
    }
    
    public void add(FormatFunction<W> formatter) {
      formatters = formatters.chain(formatter);
    }
    
    
  }
  
  public static class Words<Last extends Word<Last>, This extends Words<Last, This>> {
    protected Element<Last> lastWord;
    final protected Words<?,?> previous;
    protected long quantity;
    
    protected Words(Last lastWord, Words<?, ?> previous, long n) {
      this.lastWord = new Element<Last>(lastWord);
      this.previous = previous;
      this.quantity = n;
    }
    
    @Override
    public String toString() {
      SeqFormatter<String> formatter = SeqFormatter.spaceSep();
      formatInto(formatter);
      return formatter.toString();
    }

    protected void formatInto(SeqFormatter<String> formatter) {
      if (previous != null) {
        previous.formatInto(formatter);
      }
      formatter.add(lastWord.format(quantity));
    }
    
    @SuppressWarnings("unchecked")
    public This uc() {
      lastWord.add(lastWord.word.uc());
      return (This)this;
    }
    @SuppressWarnings("unchecked")
    public This cap() {
      lastWord.add(lastWord.word.cap());
      return (This)this;
    }
    
    public NounFinalWords noun(long n, String singular, String plural) {
      return Noun.find(singular, plural).extend(this, n);
    }
    public NounFinalWords noun(long n, String singular) {
      return Noun.find(singular).extend(this, n);
    }
    public NounFinalWords noun(String singular, String plural) {
      return noun(quantity, singular, plural);
    }
    public NounFinalWords noun(String singular) {
      return noun(quantity, singular);
    }
    public NumberFinalWords num(long n) {
      return new Number().extend(this, n);
    }
    public NumberFinalWords num() {
      return num(quantity);
    }
    public AffixFinalWords suffix(String s) {
      return new Affix(s, true, false).extend(this, quantity);
    }
    public AffixFinalWords prefix(String s) {
      return new Affix(s, false, true).extend(this, quantity);
    }
    public AffixFinalWords infix(String s) {
      return new Affix(s, true, true).extend(this, quantity);
    }
    public AffixFinalWords openParen() {
      return prefix("(");
    }
    public AffixFinalWords closeParen() {
      return suffix(")");
    }
    public AffixFinalWords openQuotes() {
      return prefix("\"");
    }
    public AffixFinalWords closeQuotes() {
      return suffix("\"");
    }
    public AffixFinalWords dash() {
      return infix("--");
    }
    public AffixFinalWords slash() {
      return infix("/");
    }
    public AffixFinalWords period() {
      return suffix(".");
    }
    public AffixFinalWords comma() {
      return suffix(",");
    }
    public AffixFinalWords colon() {
      return suffix(":");
    }
    public VerbFinalWords verb(long n, String base, String thirdSingular) {
      return Verb.find(base, thirdSingular).extend(this, n);
    }
    public VerbFinalWords verb(long n, String base) {
      return Verb.find(base).extend(this, n);
    }
    public VerbFinalWords verb(String base, String thirdSingular) {
      return verb(quantity, base, thirdSingular);
    }
    public VerbFinalWords verb(String base) {
      return verb(quantity, base);
    }
    public ModalFinalWords verb(long n, String base, String thirdSingular, boolean positive) {
      return Modal.bind(Verb.find(base, thirdSingular), positive).extend(this, n);
    }
    public ModalFinalWords verb(long n, String base, boolean positive) {
      return Modal.bind(Verb.find(base), positive).extend(this, n);
    }
    public ModalFinalWords verb(String base, String thirdSingular, boolean positive) {
      return verb(quantity, base, thirdSingular, positive);
    }
    public ModalFinalWords verb(String base, boolean positive) {
      return verb(quantity, base, positive);
    }
    
    public NoiseFinalWords word(String word) {
      return new Noise(word).extend(this, quantity);
    }
    public NoiseFinalWords words(String words) {
      return word(words);
    }
    
    public PronounFinalWords subjectPro(long n) {
      return new Pronoun(Pronoun.ThirdNeut, Pronoun.Case.Nom).extend(this, n);
    }
    public PronounFinalWords objectPro(long n) {
      return new Pronoun(Pronoun.ThirdNeut, Pronoun.Case.Acc).extend(this, n);
    }
    public PronounFinalWords possessivePro(long n) {
      return new Pronoun(Pronoun.ThirdNeut, Pronoun.Case.Gen).extend(this, n);
    }
    public PronounFinalWords absolutivePro(long n) {
      return new Pronoun(Pronoun.ThirdNeut, Pronoun.Case.Abs).extend(this, n);
    }
    public PronounFinalWords reflexivePro(long n) {
      return new Pronoun(Pronoun.ThirdNeut, Pronoun.Case.Rfx).extend(this, n);
    }
    public PronounFinalWords subjectPro() {
      return new Pronoun(Pronoun.ThirdNeut, Pronoun.Case.Nom).extend(this, quantity);
    }
    public PronounFinalWords objectPro() {
      return new Pronoun(Pronoun.ThirdNeut, Pronoun.Case.Acc).extend(this, quantity);
    }
    public PronounFinalWords possessivePro() {
      return new Pronoun(Pronoun.ThirdNeut, Pronoun.Case.Gen).extend(this, quantity);
    }
    public PronounFinalWords absolutivePro() {
      return new Pronoun(Pronoun.ThirdNeut, Pronoun.Case.Abs).extend(this, quantity);
    }
    public PronounFinalWords reflexivePro() {
      return new Pronoun(Pronoun.ThirdNeut, Pronoun.Case.Rfx).extend(this, quantity);
    }
    public PronounFinalWords they(int n) {
      return subjectPro(n);
    }
    public PronounFinalWords them(int n) {
      return objectPro(n);
    }
    public PronounFinalWords their(int n) {
      return possessivePro(n);
    }
    public PronounFinalWords theirs(int n) {
      return absolutivePro(n);
    }
    public PronounFinalWords themselves(int n) {
      return reflexivePro(n);
    }
    public PronounFinalWords they() {
      return subjectPro(quantity);
    }
    public PronounFinalWords them() {
      return objectPro(quantity);
    }
    public PronounFinalWords their() {
      return possessivePro(quantity);
    }
    public PronounFinalWords theirs() {
      return absolutivePro(quantity);
    }
    public PronounFinalWords themselves() {
      return reflexivePro(quantity);
    }

    public NegationFinalWords not(boolean guard) {
      return new Negation("not", false, guard).extend(this, quantity);
    }
    public NegationFinalWords nt(boolean guard) {
      return new Negation("n't", true, guard).extend(this, quantity);
    }

  }
  
  public static abstract class InflectedWord<W extends Word<W>> extends Word<W> {
    public final PartOfSpeech partOfSpeech;
    public final String plural;
    public String singular;

    protected InflectedWord(PartOfSpeech partOfSpeech, String singular, String plural) {
      this.partOfSpeech = partOfSpeech;
      this.plural = plural;
      this.singular = singular;
    }

    @Override
    public String format(long quantity) {
      return quantity == 1 ? singular : plural;
    }
    
    public void setSingular(String singular) {
      this.singular = singular;
    }

    @Override
    public String toString() {
      return String.format("%s[%s, %s]", partOfSpeech, plural, singular);
    }


  }
  
  public static class Noun extends InflectedWord<Noun> {
    static {
      PartOfSpeech.N.setInvariant("sheep");
      PartOfSpeech.N.setInvariant("fish");
      PartOfSpeech.N.setInvariant("deer");
      PartOfSpeech.N.setSingular("children", "child");
      PartOfSpeech.N.setSingular("matrices", "matrix");
      PartOfSpeech.N.setSingular("lives", "life");
      PartOfSpeech.N.setSingular("wives", "wife");
      PartOfSpeech.N.setSingular("leaves", "leaf");
      PartOfSpeech.N.setSingular("knives", "knife");
      PartOfSpeech.N.setSingular("thieves", "thief");
      
    }

    protected Noun(String singular, String plural) {
      super(PartOfSpeech.N, singular, plural);
    }


    @Override
    public NounFinalWords extend(Words<?, ?> prior, long n) {
      return new NounFinalWords(this, prior, n);
    }
    
    public static Noun find(String plural, String singular) {
      return PartOfSpeech.N.find(Noun.class, plural);
    }
    
    public static Noun find(String plural) {
      return find(plural, null);
    }

    public static void setSingular(String plural, String singular) {
      PartOfSpeech.N.setSingular(plural, singular);
    }


  }
  
  public static class NounFinalWords extends Words<Noun, NounFinalWords> {
    protected NounFinalWords(Noun lastWord, Words<?, ?> previous, long n) {
      super(lastWord, previous, n);
    }
  }
  
  public static class Number extends Word<Number> {
    private IntFormatter intFormatter = IntFormatter.decimal().commas();
    
    @Override
    public NumberFinalWords extend(Words<?, ?> prior, long n) {
      return new NumberFinalWords(this, prior, n);
    }
    @Override
    public String format(long quantity) {
      return intFormatter.format(quantity);
    }

     public static FormatFunction<Number> nAs(final int n, final String nForm) {
      return new FormatFunction<English.Number>() {
        @Override
        public String format(long quantity, Number word, FormatChain<Number> prior) {
          if (quantity == n) {
            return nForm;
          }
          return prior.format(quantity);
        }
      };
    }
    public static FormatFunction<Number> zeroAs(final String zeroForm) {
      return nAs(0, zeroForm);
    }
    public static FormatFunction<Number> oneAs(final String oneForm) {
      return nAs(1, oneForm);
    }
   }
  
  public static class NumberFinalWords extends Words<Number, NumberFinalWords> {
    protected NumberFinalWords(Number lastWord, Words<?, ?> previous, long n) {
      super(lastWord, previous, n);
    }
    
    public NumberFinalWords magFmt(MagnitudeFormatter mf) {
      lastWord.word.intFormatter.formatter(mf);
      return this;
    }
    public NumberFinalWords group(String sep, int groupSize) {
      lastWord.word.intFormatter.group(sep, groupSize);
      return this;
    }
    public NumberFinalWords grouped(boolean b) {
      lastWord.word.intFormatter.grouped(b);
      return this;
    }
    public NumberFinalWords grouped() {
      lastWord.word.intFormatter.grouped();
      return this;
    }
    public NumberFinalWords ungrouped() {
      lastWord.word.intFormatter.ungrouped();
      return this;
    }
    public NumberFinalWords groupSep(String sep) {
      lastWord.word.intFormatter.groupSep(sep);
      return this;
    }
    public NumberFinalWords groupWidth(int width) {
      lastWord.word.intFormatter.groupWidth(width);
      return this;
    }
    public NumberFinalWords commas() {
      lastWord.word.intFormatter.commas();
      return this;
    }
    public NumberFinalWords underscores() {
      lastWord.word.intFormatter.underscores();
      return this;
    }
    public NumberFinalWords dots() {
      lastWord.word.intFormatter.dots();
      return this;
    }
    public NumberFinalWords periods() {
      lastWord.word.intFormatter.periods();
      return this;
    }
    public NumberFinalWords colons() {
      lastWord.word.intFormatter.colons();
      return this;
    }
    public NumberFinalWords spaces() {
      lastWord.word.intFormatter.spaces();
      return this;
    }
    public NumberFinalWords dashes() {
      lastWord.word.intFormatter.commas();
      return this;
    }
    public NumberFinalWords commas(int width) {
      lastWord.word.intFormatter.commas(width);
      return this;
    }
    public NumberFinalWords underscores(int width) {
      lastWord.word.intFormatter.underscores(width);
      return this;
    }
    public NumberFinalWords dots(int width) {
      lastWord.word.intFormatter.dots(width);
      return this;
    }
    public NumberFinalWords periods(int width) {
      lastWord.word.intFormatter.periods(width);
      return this;
    }
    public NumberFinalWords colons(int width) {
      lastWord.word.intFormatter.colons(width);
      return this;
    }
    public NumberFinalWords spaces(int width) {
      lastWord.word.intFormatter.spaces(width);
      return this;
    }
    public NumberFinalWords dashes(int width) {
      lastWord.word.intFormatter.commas(width);
      return this;
    }
    public NumberFinalWords minDigits(int min) {
      lastWord.word.intFormatter.minDigits(min);
      return this;
    }
    public NumberFinalWords base(int radix) {
      lastWord.word.intFormatter.base(radix);
      return this;
    }
    public NumberFinalWords signed(boolean b) {
      lastWord.word.intFormatter.signed(b);
      return this;
    }
    public NumberFinalWords signed() {
      lastWord.word.intFormatter.signed();
      return this;
    }
    public NumberFinalWords unsigned() {
      lastWord.word.intFormatter.unsigned();
      return this;
    }
    public NumberFinalWords negativesAs(String fmt) {
      lastWord.word.intFormatter.formatNeg(fmt);
      return this;
    }
    public NumberFinalWords padTo(int width) {
      lastWord.word.intFormatter.padTo(width);
      return this;
    }
    public NumberFinalWords padTo(int width, String pad) {
      lastWord.word.intFormatter.padTo(width, pad);
      return this;
    }
    public NumberFinalWords padWith(String pad) {
      lastWord.word.intFormatter.padWith(pad);
      return this;
    }
    
    
    
    public NumberFinalWords zeroAs(String zeroForm) {
      lastWord.add(Number.zeroAs(zeroForm));
      return this;
    }
    public NumberFinalWords zeroAsNone() {
      return zeroAs("none");
    }
    public NumberFinalWords zeroAsNo() {
      return zeroAs("no");
    }
    public NumberFinalWords oneAs(String oneForm) {
      lastWord.add(Number.oneAs(oneForm));
      return this;
    }
    public NumberFinalWords oneAsA() {
      return oneAs("a");
    }
    public NumberFinalWords oneAsAn() {
      return oneAs("an");
    }
    
    public NumberFinalWords inWordsTo(long max) {
      lastWord.word.intFormatter.inWords().maxAsWords(max);
      return this;
    }
    public NumberFinalWords inWords() {
      return inWordsTo(Long.MAX_VALUE);
    }
    public NumberFinalWords ordinal() {
      lastWord.word.intFormatter.ordinal();
      return this;
    }
    public NumberFinalWords cardinal() {
      lastWord.word.intFormatter.cardinal();
      return this;
    }
    
    public NumberFinalWords th() {
      return ordinal();
    }
  }
  
  public static class Affix extends Word<Affix> {
    final String affix;
    final boolean joinBefore;
    final boolean joinAfter;
    
    protected Affix(String affix, boolean joinBefore, boolean joinAfter) {
      this.affix = affix;
      this.joinBefore = joinBefore;
      this.joinAfter = joinAfter;
    }

    @Override
    public String format(long quantity) {
      return affix;
    }

    @Override
    public AffixFinalWords extend(Words<?, ?> prior, long quantity) {
      return new AffixFinalWords(this, prior, quantity);
    }
    
  }
  
  public static class AffixFinalWords extends Words<Affix, AffixFinalWords> {

    protected AffixFinalWords(Affix lastWord, Words<?, ?> previous, long quantity) {
      super(lastWord, previous, quantity);
    }
    
    @Override
    protected void formatInto(SeqFormatter<String> formatter) {
      if (previous != null) {
        previous.formatInto(formatter);
      }
      Affix affix = lastWord.word;
      if (affix.joinBefore) {
        formatter.join();
      }
      formatter.add(lastWord.format(quantity));
      if (affix.joinAfter) {
        formatter.join();
      }
    }
  }
  
  public static class Verb extends InflectedWord<Verb> {
    static {
      PartOfSpeech.V.setSingular("were", "was");
      PartOfSpeech.V.setSingular("are", "is");
      PartOfSpeech.V.setSingular("have", "has");
      PartOfSpeech.V.setSingular("do", "does");
      PartOfSpeech.V.setSingular("go", "goes");
      PartOfSpeech.V.setInvariant("did");
      PartOfSpeech.V.setInvariant("had");
      PartOfSpeech.V.setInvariant("will");
      PartOfSpeech.V.setInvariant("shall");
      PartOfSpeech.V.setInvariant("would");
      PartOfSpeech.V.setInvariant("can");
      PartOfSpeech.V.setInvariant("could");
      PartOfSpeech.V.setInvariant("might");
      PartOfSpeech.V.setInvariant("should");
      PartOfSpeech.V.setInvariant("must");

    }

    protected Verb(String singular, String plural) {
      super(PartOfSpeech.V, singular, plural);
    }

    public static Verb find(String plural, String singular) {
      return PartOfSpeech.V.find(Verb.class, plural);
    }
    
    public static Verb find(String plural) {
      return find(plural, null);
    }

    public static void setSingular(String plural, String singular) {
      PartOfSpeech.V.setSingular(plural, singular);
    }

    @Override
    public VerbFinalWords extend(Words<?, ?> prior, long quantity) {
      return new VerbFinalWords(this, prior, quantity);
    }

  }
  
  public static class VerbFinalWords extends Words<Verb, VerbFinalWords> {
    protected VerbFinalWords(Verb lastWord, Words<?, ?> previous, long quantity) {
      super(lastWord, previous, quantity);
    }
  }
  
  public static class Noise extends Word<Noise> {
    final String form;
    
    protected Noise(String form) {
      this.form = form;
    }

    @Override
    public String format(long quantity) {
      return form;
    }

    @Override
    public NoiseFinalWords extend(Words<?, ?> prior, long quantity) {
      return new NoiseFinalWords(this, prior, quantity);
    }
  }
  
  public static class NoiseFinalWords extends Words<Noise, NoiseFinalWords> {
    protected NoiseFinalWords(Noise lastWord, Words<?, ?> previous, long quantity) {
      super(lastWord, previous, quantity);
    }
  }
  
  public static class Negation extends Word<Negation> {
    private final String word;
    private final boolean suffix;
    private final boolean guard;
    
    private Negation(String word, boolean suffix, boolean guard) {
      this.word = word;
      this.suffix = suffix;
      this.guard = guard;
    }

    @Override
    public String format(long quantity) {
      return word;
    }

    @Override
    public NegationFinalWords extend(Words<?, ?> prior, long quantity) {
      return new NegationFinalWords(this, prior, quantity);
    }
    
  }
  
  public static class NegationFinalWords extends Words<Negation, NegationFinalWords> {
    protected NegationFinalWords(Negation lastWord, Words<?, ?> previous, long quantity) {
      super(lastWord, previous, quantity);
    }
    
    @Override
    protected void formatInto(SeqFormatter<String> formatter) {
      if (previous != null) {
        previous.formatInto(formatter);
      }
      if (!lastWord.word.guard) {
        String s = lastWord.format(quantity);
        if (lastWord.word.suffix) {
          formatter.suffix(s);
        } else {
          formatter.add(s);
        }
      }
    }
  }
  public static class Pronoun extends Word<Pronoun> {
    
    static final Person First = new Person(1, new String[] {"I", "we", "me", "us", "my", "our", "mine", "ours", "myself", "ourselves"});
    static final Person Second = new Person(2, new String[] {"you", "you", "you", "you", "your", "your", "yours", "yours", "yourself", "yourselves"});
    static final Person SecondGuys = new Person(2, new String[] {"you", "you guys", "you", "you guys", "your", "you guys'", "yours", "you guys'", "yourself", "yourselves"});
    static final Person SecondAll= new Person(2, new String[] {"you", "y'all", "you", "y'all", "your", "y'all's'", "yours", "y'all's'", "yourself", "yourselves"});
    static final Person ThirdNeut = new Person(3, new String[] {"it", "they", "it", "them", "its", "their", "its", "theirs", "itself", "themselves"});
    static final Person ThirdMasc = new Person(3, new String[] { "he", "they", "him", "them", "his", "their", "his", "theirs", "himself", "themselves"});
    static final Person ThirdFem= new Person(3, new String[] {"she", "they", "her", "them", "her", "their", "hers", "theirs", "herself", "themselves"});
    static final Person ThirdSingThey= new Person(3, new String[] { "they", "they", "them", "them", "their", "their", "theirs", "theirs", "themself", "themselves"});
    static final Person ThirdHeShe= new Person(3, new String[] { "he/she", "they", "him/her", "them", "his/her", "their", "his/hers", "theirs", "himself/herself", "themselves"});
    
    enum Case { 
      Nom(0,1),
      Acc(2,3),
      Gen(4,5),
      Abs(6,7),
      Rfx(8,9);
      
      final int singIndex;
      final int plurIndex;
      
      private Case(int singIndex, int plurIndex) {
        this.singIndex = singIndex;
        this.plurIndex = plurIndex;
      }

      public String format(Person person, boolean isSingular) {
        return person.forms[isSingular ? singIndex : plurIndex];
      }
    }
    
    static class Person {
      final int person;
      final String[] forms;
      protected Person(int person, String[] forms) {
        this.forms = forms;
        this.person = person;
      }
      @Override
      public String toString() {
        return String.format("Person%s", SeqFormatter.bracketList().format(forms));
      }
      public boolean samePerson(Person other) {
        return person == other.person;
      }
      public String ordinal() {
        switch (person) {
        case 1:
          return "1st";
        case 2:
          return "2nd";
        case 3:
          return "3rd";
        }
        throw new IllegalStateException();
      }
    }
    
    final Person person;
    final Case gramCase;
    
    protected Pronoun(Person person, Case gramCase) {
      this.person = person;
      this.gramCase = gramCase;
    }

    @Override
    public String format(long quantity) {
      return gramCase.format(person, quantity == 1);
    }

    @Override
    public PronounFinalWords extend(Words<?, ?> prior, long n) {
      return new PronounFinalWords(this, prior, n);
    }
    
    @Override
    public String toString() {
      return String.format("Pronoun[%s, %s]", format(1), format(2));
    }
  }
  
  public static class PronounFinalWords extends Words<Pronoun, PronounFinalWords> {
    protected PronounFinalWords(Pronoun lastWord, Words<?, ?> previous, long n) {
      super(lastWord, previous, n);
    }
    
    public PronounFinalWords guys() {
      return replaceForm(Pronoun.SecondGuys, "guys");
    }
    public PronounFinalWords yall() {
      return replaceForm(Pronoun.SecondAll, "yall");
    }
    public PronounFinalWords masc() {
      return replaceForm(Pronoun.ThirdMasc, "masc");
    }
    public PronounFinalWords fem() {
      return replaceForm(Pronoun.ThirdFem, "fem");
    }
    public PronounFinalWords slashed() {
      return replaceForm(Pronoun.ThirdHeShe, "slashed");
    }
    public PronounFinalWords genNeut() {
      return replaceForm(Pronoun.ThirdSingThey, "genNeut");
    }
    public PronounFinalWords first() {
      return replacePerson(Pronoun.First);
    }
    public PronounFinalWords second() {
      return replacePerson(Pronoun.Second);
    }
    public PronounFinalWords third() {
      return replacePerson(Pronoun.ThirdNeut);
    }

    public PronounFinalWords replaceForm(final Pronoun.Person replacement,
                                         final String funcName) {
      final Pronoun pro = lastWord.word;
      if (!replacement.samePerson(pro.person)) {
        throw new IllegalArgumentException(String.format("%s() can only be called on a %s-person pronoun, not %s", funcName, replacement.ordinal(), pro)); 
      }
      return replacePerson(replacement);
    }
    public PronounFinalWords replacePerson(final Pronoun.Person replacement) {
      lastWord.word = new Pronoun(replacement, lastWord.word.gramCase);
      return this;
    }
    
    public void addReplacement(final Pronoun.Person replacement,
                               final Pronoun pro) {
      lastWord.add(new FormatFunction<English.Pronoun>() {
        @Override
        public String format(long quantity, Pronoun word,
                             FormatChain<Pronoun> prior) {
          return pro.gramCase.format(replacement, quantity == 1);
        }
      });
    }
  }
  
  public static class Modal extends Word<Modal> {
    static final Map<String, NegForms> known = new HashMap<>();
    static {
      cache(Verb.find("can"), basicNeg(Verb.find("can")).neg("not").contract("can't"));
      cache(Verb.find("will"), basicNeg(Verb.find("will")).contract("won't"));
      cache(Verb.find("shall"), basicNeg(Verb.find("shall")).contract("shan't"));
    }
    
    private final Verb verb;
    private final NegForms negForms;
    private final boolean positive;
    
    static void cache(Verb verb, NegForms forms) {
      synchronized (known) {
        known.put(verb.plural, forms);
      }
    }
    
    static void cache(Verb verb) {
      cache(verb, basicNeg(verb));
    }

    public static NegForms basicNeg(Verb verb) {
      return new NegForms(verb.singular, verb.plural);
    }
    
    static class NegForms {
      String neg;
      String singContract;
      String plurContract;
      
      NegForms(String singular, String plural) {
        this.neg = " not";
        this.singContract = singular+"n't";
        this.plurContract = plural+"n't";
      }
      NegForms(String s) {
        this(s, s);
      }
      NegForms neg(String s) {
        neg = s;
        return this;
      }
      NegForms contract(String s, String p) {
        singContract = s;
        plurContract = s;
        return this;
      }
      NegForms contract(String s) {
        return contract(s,s);
      }
    }
    
    private Modal(Verb verb, NegForms form, boolean positive) {
      this.verb = verb;
      this.negForms = form;
      this.positive = positive;
    }
    
    public static Modal bind(Verb verb, boolean positive) {
      synchronized (known) {
        NegForms forms = known.get(verb.plural);
        if (forms == null) {
          forms = basicNeg(verb);
          known.put(verb.plural, forms);
        }
        return new Modal(verb, forms, positive);
      }
    }

    @Override
    public String format(long quantity) {
      String s = verb.format(quantity);
      if (!positive) {
        s += negForms.neg;
      }
      return s;
    }

    @Override
    public ModalFinalWords extend(Words<?, ?> prior, long quantity) {
      return new ModalFinalWords(this, prior, quantity);
    }
  }
  
  public static class ModalFinalWords extends Words<Modal, ModalFinalWords> {
    protected ModalFinalWords(Modal lastWord, Words<?, ?> previous, long quantity) {
      super(lastWord, previous, quantity);
    }
    
    public ModalFinalWords nt() {
      lastWord.add(new FormatFunction<English.Modal>() {
        @Override
        public String format(long quantity, Modal word, FormatChain<Modal> prior) {
          if (word.positive) {
            return prior.format(quantity);
          }
          return quantity==1 ? word.negForms.singContract : word.negForms.plurContract;
        }
      });
      return this;
    }
    
  }
  
  public static NounFinalWords noun(long n, String singular, String plural) {
    return Noun.find(singular, plural).extend(null, n);
  }
  public static NounFinalWords noun(long n, String singular) {
    return Noun.find(singular).extend(null, n);
  }
  public static VerbFinalWords verb(long n, String base, String thirdSingular) {
    return Verb.find(base, thirdSingular).extend(null, n);
  }
  public static VerbFinalWords verb(long n, String base) {
    return Verb.find(base).extend(null, n);
  }
  public static ModalFinalWords verb(long n, String base, String thirdSingular, boolean positive) {
    return Modal.bind(Verb.find(base, thirdSingular), positive).extend(null, n);
  }
  public static ModalFinalWords verb(long n, String base, boolean positive) {
    return Modal.bind(Verb.find(base), positive).extend(null, n);
  }
  public static ModalFinalWords verb(String base, boolean positive) {
    return Modal.bind(Verb.find(base), positive).extend(null, 0);
  }


  public static NumberFinalWords num(long n) {
    return new Number().extend(null, n);
  }

  public static AffixFinalWords prefix(String s) {
    return new Affix(s, true, false).extend(null, -1);
  }
  public static NoiseFinalWords word(String word) {
    return new Noise(word).extend(null, -1);
  }
  public static NoiseFinalWords words(String word) {
    return new Noise(word).extend(null, -1);
  }
  
  public static AffixFinalWords openParen() {
    return prefix("(");
  }
  public static AffixFinalWords openQuotes() {
    return prefix("\"");
  }
  
  private static PronounFinalWords pro(long n, final Case c) {
    return new Pronoun(Pronoun.ThirdNeut, c).extend(null, n);
  }
  
  public static PronounFinalWords subjectPro(long n) {
    return pro(n, Pronoun.Case.Nom);
  }
  public static PronounFinalWords objectPro(long n) {
    return pro(n, Pronoun.Case.Acc);
  }
  public static PronounFinalWords possessivePro(long n) {
    return pro(n, Pronoun.Case.Gen);
  }
  public static PronounFinalWords absolutivePro(long n) {
    return pro(n, Pronoun.Case.Abs);
  }
  public static PronounFinalWords reflexivePro(long n) {
    return pro(n, Pronoun.Case.Rfx);
  }
  public static PronounFinalWords they(long n) {
    return subjectPro(n);
  }
  public static PronounFinalWords them(long n) {
    return objectPro(n);
  }
  public static PronounFinalWords their(long n) {
    return possessivePro(n);
  }
  public static PronounFinalWords theirs(long n) {
    return absolutivePro(n);
  }
  public static PronounFinalWords themselves(long n) {
    return reflexivePro(n);
  }

  public static NegationFinalWords not(boolean guard) {
    return new Negation(" not", false, guard).extend(null, 0);
  }
  public static NegationFinalWords nt(boolean guard) {
    return new Negation("n't", true, guard).extend(null, 0);
  }
  
  
  public static void main(String[] args) {
    for (int i=0; i<5; i++) {
      System.out.println(English.num(i).noun("files"));
    }
    for (int i=0; i<5; i++) {
      System.out.println(English.num(i).zeroAsNo().uc().noun("visits").cap());
    }
    for (int i=0; i<5; i++) {
      System.out.format("Transactions: %s%n", English.num(i).zeroAsNone());
    }
    for (int i=0; i<5; i++) {
      System.out.format("%s taken.%n", English.num(i).zeroAsNo().cap().noun("branches"));
    }
    for (int i=0; i<5; i++) {
      System.out.format("The program saw %s.%n", English.num(i).zeroAsNo().oneAsAn().noun("events"));
    }
    for (int i=0; i<5; i++) {
      List<Integer> ints = Chain.ints(1, i, 1).asList();
      final SeqFormatter<Object> formatter = SeqFormatter.commaSpaceSep(Option.oxfordComma).empty("none");
      System.out.format("%s: %s%n", English.noun(i, "Ints"), formatter.format(ints));
    }
    for (int i=0; i<20; i++) {
      System.out.format("%s %s%n", English.num(i), English.num(i).inWordsTo(10));
    }
    for (int i=0; i<25; i++) {
      System.out.format("%s%n", 
                        English
                        .num(i)
                        .openParen().num().inWords().zeroAsNo().closeParen()
                        .noun("dollars")
                        .verb("were", true)
                        .word("found")
                        .period());
    }
    
    for (int i=1; i<3; i++) {
      System.out.format("%s%n",
                        English
                        .num(i).inWords().cap()
                        .noun("boys")
                        .verb("were")
                        .word("walking in the forest.")
                        .they().masc().cap()
                        .word("saw me.")
                        .word("I said,")
                        .openQuotes()
                        .subjectPro().second().guys().cap()
                        .word("should come home now")
                        .period()
                        .closeQuotes()
                        );
    }
    
    for (int i=0; i<26; i++) {
      System.out.format("%s%n", 
                        English
                        .num(i)
                        .comma()
                        .num().ordinal()
                        .comma()
                        .num().inWords()
                        .comma()
                        .num().ordinal().inWords()
                        );
    }
    for (int i=995; i<1005; i++) {
      System.out.format("%s%n", 
                        English
                        .num(i)
                        .comma()
                        .num().ordinal()
                        .comma()
                        .num().inWords()
                        .comma()
                        .num().ordinal().inWords()
                        );
    }
    for (int i=999_995; i<1_000_005; i++) {
      System.out.format("%s%n", 
                        English
                        .num(i)
                        .comma()
                        .num().ordinal()
                        .comma()
                        .num().inWords()
                        .comma()
                        .num().ordinal().inWords()
                        );
    }
    for (long i=999_999_999_999_995L; i<1_000_000_000_000_005L; i++) {
      System.out.format("%s%n", 
                        English
                        .num(i)
                        .comma()
                        .num().ordinal()
                        .comma()
                        .num().inWords()
                        .comma()
                        .num().ordinal().inWords()
                        );
    }
    for (String v : Arrays.asList("are", "were", "have", "had", "do", "did", "will", "would", "can", "could", "might", "must", "should")) {
      for (int num = 1; num <=2; num++) {
        System.out.format("%s%n", 
                          English
                          .they(num).cap().verb(v, true).period()
                          .they(num).cap().verb(v, false).period()
                          .they(num).cap().verb(v, false).nt().period()
            );
      }
    }
    System.out.format("Files were%s read.%n", English.not(true));
    System.out.format("Files were%s read.%n", English.not(false));
    System.out.format("Files were%s read.%n", English.nt(true));
    System.out.format("Files were%s read.%n", English.nt(false));
  }

  
}
