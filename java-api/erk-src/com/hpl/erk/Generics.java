/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

public class Generics {
  public static Class<?> collectionParam(Field field, @SuppressWarnings("rawtypes") Class<? extends Collection> target) {
    if (!target.isAssignableFrom(field.getType())) {
      return null;
    }
    return collectionParam(field.getGenericType(), target);

  }

  public static Class<?> collectionParam(Type type, @SuppressWarnings("rawtypes") Class<? extends Collection> target) {
    Set<Type> seen = new HashSet<>();
    Type et = collectionParam(type, target, seen);
    if (et == null) {
      return null;
    }
    if (et instanceof Class) {
      return (Class<?>)et;
    }
    if (et instanceof ParameterizedType) {
      return (Class<?>)((ParameterizedType)et).getRawType();
    }
    throw new IllegalStateException(String.format("%s is a %s of %s", type, target, et));
  }

  private static Type collectionParam(Type type, @SuppressWarnings("rawtypes") Class<? extends Collection> target, Set<Type> seen) {
    if (!seen.add(type)) {
      return null;
    }
    if (type instanceof ParameterizedType) {
      ParameterizedType pt = (ParameterizedType)type;
      final Type[] args = pt.getActualTypeArguments();
      final Class<?> rawType = (Class<?>)pt.getRawType();
      final TypeVariable<?>[] params = rawType.getTypeParameters();
      return collectionParam(type, rawType, params, args, target, seen);
    }
    if (type instanceof Class) {
      final Class<?> c = (Class<?>)type;
      return collectionParam(type, c, null, null, target, seen);
    }
    throw new IllegalStateException(String.format("%s is neither a class nor a parameterized type", type));
  }
  
  private static Type collectionParam(Type type, Class<?> rawType, 
                                      TypeVariable<?>[] params, Type[] args,
                                      @SuppressWarnings("rawtypes") Class<? extends Collection> target,
                                      Set<Type> seen) 
  {
    if (rawType == target) {
      return args[0];
    }
    for (Type it : rawType.getGenericInterfaces()) {
//    System.out.format("%s%n", it);
      Type superTypeVal = checkSuperType(it, target, params, args, type, seen);
      if (superTypeVal != null) {
        return superTypeVal;
      }
    }
    return checkSuperType(rawType.getGenericSuperclass(), target, params, args, type, seen);
  }


  private static Type checkSuperType(Type type,
                                     @SuppressWarnings("rawtypes") Class<? extends Collection> target,
                                     TypeVariable<?>[] typeParameters, Type[] args, Type inType,
                                     Set<Type> seen) 
  {
    Type ct = collectionParam(type, target, seen);
    if (ct == null) {
      return null;
    }
//          System.out.format("%s%n", ct);
    if (ct instanceof TypeVariable) {
      TypeVariable<?> tv = (TypeVariable<?>)ct;
      for (int i=0; i<typeParameters.length; i++) {
        if (typeParameters[i] == tv) {
          return args[i];
        }
      }
      throw new IllegalStateException(String.format("Couldn't understand %s in %s", tv, inType));
    }
    return ct;
  }

}
