/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.chain;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

import com.hpl.erk.func.SourceExhausted;

public class WithoutReplacementLink<Head, Out> extends Link<Head, Out, Out> {
  protected final int wanted;
  protected final int expected;

  public WithoutReplacementLink(Chain<Head, ? extends Out> pred, int wanted, int expected) {
    super(pred);
    this.wanted = wanted;
    this.expected = expected;
  }

  public WithoutReplacementLink(Chain<Head, ? extends Out> pred, int wanted) {
    this(pred, wanted, Integer.MAX_VALUE);
  }

  @Override
  public int expectedSize() {
    return expected;
  }

  /*
   * Okay.  This probably warrants a comment.  If you do the math, picking and checking winds up costing
   * n(H(n)-H(n-k)).  By Knuth (v1p74eq3), H(n) is approx. ln n, so this is basically n ln(n/(n-k)).  Which 
   * means that it will be faster than the single-pass algorithm (O(n)) when k < ((e-1)/e) n.
   */
  private static final double cutoff = (Math.E-1)/Math.E;

  @Override
  public Flow pipeInto(final Receiver<? super Out> sink) {
    int n = pred.expectedSize();
    if (n <= wanted) {
      // If we don't expect to get all we want, just pipe into our sink.
      return passThroughFlow(sink);
    }
    if (n == Integer.MAX_VALUE) {
      return drawFromUnknownFlow(sink);
    }
    RandomAccessSource<? extends Out> source = pred.randomAccess();
    if (source != null) {
      if (wanted < cutoff*n) {
        return pickAndCheckFlow(sink, source, n);
      } else {
        return walkAndPick(sink, source, n);
      }
    }
    return walkAndPick(sink, n);
  }

  private Flow walkAndPick(final Receiver<? super Out> sink,
                           final int total)
  {
    return pred.pipeInto(new ChainedReceiver<Out,Out>(sink) {
      int n = total;
      int k = wanted;
      final ThreadLocalRandom rnd = ThreadLocalRandom.current();

      @Override
      public boolean receive(Out val) {
        if (k <=0) {
          return false;
        }
        if (rnd.nextInt(n--) < k) {
          k--;
          return sink.receive(val);
        }
        return true;
      }});
  }

  private Flow walkAndPick(final Receiver<? super Out> sink,
                           final RandomAccessSource<? extends Out> source,
                           final int total) 
  {
    return new Flow() {
      @Override
      public void perform() {
        int n = total;
        int k = wanted;
        final ThreadLocalRandom rnd = ThreadLocalRandom.current();
        for (int i=0; k>0; i++) {
          if (rnd.nextInt(n--) < k) {
            k--;
            if (!sink.receive(source.get(i))) {
              return;
            }
          }
        }
        sink.close();
      }
    };
  }

  private Flow pickAndCheckFlow(final Receiver<? super Out> sink,
                                final RandomAccessSource<? extends Out> source, 
                                final int n) 
  {
    return new Flow() {
      @Override
      public void perform() {
        final ThreadLocalRandom rnd = ThreadLocalRandom.current();
        final int[] indices = new int[wanted];
        LOOP:
          for (int i=0; i<wanted; i++) {
            int which = rnd.nextInt(n);
            for (int j=0; j<i; j++) {
              if (indices[j] == which) {
                continue LOOP;
              }
            }
            indices[i++] = which;
            if (!sink.receive(source.get(which))) {
              return;
            }
          }
        sink.close();
      }
    };
  }

  private Flow drawFromUnknownFlow(final Receiver<? super Out> sink) {
    @SuppressWarnings("unchecked")
    final Out[] chosen = (Out[])new Object[wanted];
    final FillerReceiver fillerReceiver = new FillerReceiver(chosen);
    Flow filler = pred.pipeInto(fillerReceiver);
    filler.perform();
    return new Flow() {
      @Override
      public void perform() {
        int k = fillerReceiver.k;
        for (int i=0; i<k; i++) {
          if (!sink.receive(fillerReceiver.chosen[i])) {
            return;
          }
        }
        sink.close();
      }
    };
  }

  protected Flow passThroughFlow(final Receiver<? super Out> sink) {
    return pred.pipeInto(new ChainedReceiver<Out,Out>(sink) {
      int i = 0;
      @Override
      public boolean receive(Out val) {
        if (i >= wanted) {
          return false;
        }
        i++;
        return sink.receive(val);
      }});
  }

  private final class FillerReceiver extends FinalReceiver<Out> {
    private final Out[] chosen;
    ThreadLocalRandom rnd = ThreadLocalRandom.current();
    int k = 0;
    int n = 0;

    private FillerReceiver(Out[] chosen) {
      this.chosen = chosen;
    }

    @Override
    public boolean receive(Out val) {
      if (n < wanted) {
        chosen[k++] = val;
      }else {
        int which = rnd.nextInt(n);
        if (which < k) {
          chosen[which] = val;
        }
      }
      n++;
      return true;
    }
  }


  @Override
  public Link<Head,Out,Out>.Context createContext() {
    int n = pred.expectedSize();
    if (n <= wanted) {
      // If we don't expect to get all we want, just passThrough
      return passThroughContext(n);
    }
    if (n == Integer.MAX_VALUE) {
      return drawFromUnknownContext();
    }
    RandomAccessSource<? extends Out> source = pred.randomAccess();
    if (source != null) {
      if (wanted < cutoff*n) {
        return pickAndCheckContext(source, n);
      } else {
        return walkAndPickContext(source, n);
      }
    }
    return walkAndPickContext(n);
 }

  private Context walkAndPickContext(final int total) {
    return new Context() {
      protected int n = total;
      protected int k = wanted;


      @Override
      public Out produce() throws SourceExhausted {
        exhaustedIf(k <= 0);
        while (true) {
          Out elt = source.produce();
          if (ThreadLocalRandom.current().nextInt(n--) < k) {
            k--;
            return elt;
          }
        }
      }
    };
  }

  private Context walkAndPickContext(final RandomAccessSource<? extends Out> raSource, final int total) {
    return new Context() {
      protected int n = total;
      protected int k = wanted;
      int i = 0;


      @Override
      public Out produce() throws SourceExhausted {
        exhaustedIf(k <= 0);
        for (;; i++) {
          if (ThreadLocalRandom.current().nextInt(n--) < k) {
            k--;
            return raSource.get(i);
          }
        }
      }
    };
  }


  private Context pickAndCheckContext(final RandomAccessSource<? extends Out> raSource, final int n) {
    return new Context() {
      public int[] indices = new int[wanted];
      int next = 0;

      @Override
      public Out produce() throws SourceExhausted {
        exhaustedIf(next >= n);
        final ThreadLocalRandom rnd = ThreadLocalRandom.current();
        LOOP:
        while (true) {
          int which = rnd.nextInt(n);
          for (int j=0; j<next; j++) {
            if (indices[j] == which) {
              continue LOOP;
            }
          }
          indices[next++] = which;
          return raSource.get(which);
        }
      }
    };
  }
  
  

  private Context drawFromUnknownContext() {  
    return new Context() {
      @SuppressWarnings("unchecked")
      protected final Out[] array = (Out[])new Object[wanted];
      protected int next = 0;
      protected int k;
      
      {
        ThreadLocalRandom rnd = ThreadLocalRandom.current();
        int n = 0;
        k = 0;
        for (Out elt : source) {
          if (n < wanted) {
            array[k++] = elt;
          }else {
            int which = rnd.nextInt(n);
            if (which < k) {
              array[which] = elt;
            }
          }
          n++;
        }
      }
      
      @Override
      public Out produce() throws SourceExhausted {
        exhaustedIf(next >= k);
        return array[next++];
      }
    };
  }

  private Context passThroughContext(final int n) {
    return new Context() {
      @Override
      public Out produce() throws SourceExhausted {
        return source.produce();
      }
    };
  }
 
  protected List<Out> drawToList() {
    final ArrayList<Out> list = new ArrayList<>(wanted);
    ThreadLocalRandom rnd = ThreadLocalRandom.current();
    int n = 0;
    
    for (Out elt : pred) {
      if (n < wanted) {
        list.add(elt);
        n++;
      }else {
        int which = rnd.nextInt(n);
        if (which < wanted) {
          list.set(which, elt);
         }
      }
    }
    return list;
    
  }

}
