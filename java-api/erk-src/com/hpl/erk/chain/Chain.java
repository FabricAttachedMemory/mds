/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.chain;

import java.io.BufferedReader;
import java.io.File;
import java.io.PrintStream;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.RandomAccess;
import java.util.Set;

import org.apache.log4j.Logger;

import com.hpl.erk.Chooser;
import com.hpl.erk.RandomChoice;
import com.hpl.erk.chain.kv.ForkLink;
import com.hpl.erk.chain.kv.IndexedLink;
import com.hpl.erk.chain.kv.KeyValChain;
import com.hpl.erk.chain.kv.MapHead;
import com.hpl.erk.files.FileOption;
import com.hpl.erk.func.Consumer;
import com.hpl.erk.func.Control;
import com.hpl.erk.func.Functions;
import com.hpl.erk.func.Generator;
import com.hpl.erk.func.GeneratorCreator;
import com.hpl.erk.func.NullaryFunc;
import com.hpl.erk.func.Observer;
import com.hpl.erk.func.Predicate;
import com.hpl.erk.func.Process;
import com.hpl.erk.func.Reducer;
import com.hpl.erk.func.SinkFull;
import com.hpl.erk.func.SourceExhausted;
import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.iter.ConstIterator;
import com.hpl.erk.util.ArrayUtils;
import com.hpl.erk.util.ObjUtils;
import com.hpl.erk.util.Strings;

/**
 * 
 * Chains can be used in two ways, either as Iterables or as pipes
 * that can route values into sinks that can consume their values.
 * The latter mode is actually a bit more efficient, especially if you
 * can decide after processing the last element you want that you're
 * done.  So you can say things like 'chain.into(consumer)' to process
 * the elements of a list or 'chain.into(System.out)' to print all of
 * the elements.  If you just want a collection of the values, you can
 * say something like 'chain.asList()', 'chain.asSet()', or
 * 'chain.into(collection)', or 'chain.asArray(X.class)'.
 */
public abstract class Chain<From, To> implements Iterable<To> {
  private static final Logger logger = Logger.getLogger(Chain.class);
  public static final SourceExhausted SOURCE_EXHAUSTED = SourceExhausted.INSTANCE;
  public static final SinkFull SINK_FULL = SinkFull.INSTANCE;
  public boolean complete;

  protected Chain(boolean complete) {
    this.complete = complete;
  }

  public static interface Receiver<X> {
    /**
     * 
     * @param val
     * @return <code>true</code> if the receiver can take more values
     */
    boolean receive(X val);
    void close();
  }
  
  public static abstract class ChainedReceiver<X,Y> implements Receiver<X> {
    protected final Receiver<? super Y> sink;

    protected ChainedReceiver(Receiver<? super Y> sink) {
      this.sink = sink;
    }
    
    @Override
    public void close() {
      sink.close();
    }
  }
  
  public static abstract class FinalReceiver<X> implements Receiver<X> {
    @Override
    public void close() {
      // do nothing
    }
  }
  

  public abstract Flow pipeInto(Receiver<? super To> sink);

  public RandomAccessSource<To> randomAccess() {
    return null;
  }

  public int expectedSize() {
    return Integer.MAX_VALUE;
  }

  public abstract class Context implements Iterable<To> {
    public abstract To produce() throws SourceExhausted;;
    
    
    public final void exhaustedIf(boolean exhaustedp) throws SourceExhausted {
      if (exhaustedp) {
        throw SOURCE_EXHAUSTED;
      }
    }
    
    @Override
    public Iterator<To> iterator() {
      return new ConstIterator<To>() {
        boolean done = false;
        To next = getNext();

        @Override
        public boolean hasNext() {
          return !done;
        }

        private To getNext() {
          if (done) {
            return null;
          }
          try {
            return produce();
          } catch (SourceExhausted e) {
            if (e.getCause() != null) {
              logger.warn("Iteration threw exception", e);
            }
            done = true;
            return null;
          }
        }

        @Override
        public To next() {
          To val = next;
          next = getNext();
          return val;
        }
      };
    }

  }

  public abstract Context createContext();

  public abstract <H,T extends From> Chain<H,To> prepend(Chain<H,T> chain); 

  @Override
  public final Iterator<To> iterator() {
    // return new Iter();
        final Context context = createContext();
        return context.iterator();
  }

  public void fill(Receiver<? super To> sink) {
    Flow flow = pipeInto(sink);
    flow.perform();
  }
  
  public void force() {
    fill(new FinalReceiver<To>() {
      @Override
      public boolean receive(To val) {
        return true;
      }
    });
  }

  protected <C extends Link<From, ? super To, ?>> C activate(C link) {
    link.activate();
    return link;
  }
  protected <C extends ForkLink<From, ? super To, ?, ?>> C activate(C link) {
    link.activate();
    return link;
  }
  // ----------------------------------------
  public static <T> Chain<T, T> from(Class<T> clss) {
    return new OpenHead<>(clss);
  }

  public static <T> Chain<Complete, T> from(final Generator<T> generator) {
    return from(generator, Integer.MAX_VALUE);
  }
  public static <T> Chain<Complete, T> from(final Generator<T> generator, int expected) {
    return from(new GeneratorCreator<T>() {
      @Override
      public Generator<T> call() {
        return generator;
      }}, expected);
  }
  public static <T> Chain<Complete, T> from(NullaryFunc<? extends Generator<? extends T>> creator, int expected) {
    return new GeneratorHead<>(creator, expected);
  }
  public static <T> Chain<Complete, T> from(NullaryFunc<? extends Generator<? extends T>> creator) {
    return new GeneratorHead<>(creator);
  }

  public static <T> Chain<Complete, T> from(final Iterable<? extends T> iterable) {
    if ((iterable instanceof Collection)) {
      Collection<? extends T> collection = (Collection<? extends T>)iterable;
      return from(collection);
    }
    return new IterableHead<>(iterable);
  }

  public static <T> Chain<Complete, T> from(final Collection<? extends T> collection) {
    if ((collection instanceof List) && (collection instanceof RandomAccess)) {
      List<? extends T> list = (List<? extends T>)collection;
      return new RAListHead<>(list);
    }
    return new CollectionHead<>(collection);
  }

  public static <T> Chain<Complete, T> from(final List<? extends T> list) {
    if (list instanceof RandomAccess) {
      return new RAListHead<>(list);
    }
    return new CollectionHead<>(list);
  }

  public static <K,V> KeyValChain<Complete, K,V> from(final Map<K, V> map) {
    return new MapHead<>(map);
  }

  public static <T> Chain<Complete, T> send(T val) {
    return from(Arrays.asList(val));
  }
  public static <T> Chain<Complete, T> from(final T[] array) {
    return new ArrayHead<>(array);
  }
  public static Chain<Complete, Integer> from(final int[] array) {
    return new IntArrayHead(array);
  }
  public static Chain<Complete, Long> from(final long[] array) {
    return new LongArrayHead(array);
  }
  public static Chain<Complete, Double> from(final double[] array) {
    return new DoubleArrayHead(array);
  }

  public static Chain<Complete, String> from(BufferedReader in) {
    return from(Functions.foreach(in));
  }

  public static Chain<Complete, String> from(final File file, final FileOption...options) {
    return new GeneratorHead<>(new NullaryFunc<Generator<String>>() {
      @Override
      public Generator<String> call() {
        return Functions.foreach(file, options);
      }});
  }
  
  public static Chain<Complete, String> from(final File file) {
    return from(file, ArrayUtils.no(FileOption.class));
  }
  public static Chain<Complete, String> from(final Path path, final FileOption...options) {
    return new GeneratorHead<>(new NullaryFunc<Generator<String>>() {
      @Override
      public Generator<String> call() {
        return Functions.foreach(path, options);
      }});
  }
  public static Chain<Complete, String> from(final Path path) {
    return from(path, ArrayUtils.no(FileOption.class));
  }

  public static Chain<Complete, String[]> fromTSV(BufferedReader in) {
    return from(in).map(Strings.tsv());
  }
  public static Chain<Complete, String[]> fromTSV(File file, FileOption...options) {
    return from(file, options).map(Strings.tsv());
  }
  public static Chain<Complete, String[]> fromTSV(Path path, FileOption...options) {
    return from(path, options).map(Strings.tsv());
  }

  public static Chain<Complete, String[]> fromCSV(BufferedReader in) {
    return from(in).run(Functions.csv());
  }
  public static Chain<Complete, String[]> fromCSV(File file, FileOption...options) {
    return from(file, options).run(Functions.csv());
  }
  public static Chain<Complete, String[]> fromCSV(Path path, FileOption...options) {
    return from(path, options).run(Functions.csv());
  }
 
  public static <T> Chain<Complete, T> from(final RandomAccessSource<T> ra) {
    return new ChainHead<T>() {
      @Override
      public Flow pipeInto(final Receiver<? super T> sink) {
        return new Flow() {
          @Override
          public void perform() {
            int n = ra.size();
            for (int i=0; i<n; i++) {
              if (!sink.receive(ra.get(i))) {
                return;
              }
            }
            sink.close();
          }
        };
      }
      
      @Override
      public RandomAccessSource<T> randomAccess() {
        return ra;
      }
      
      @Override
      public int expectedSize() {
        return ra.size();
      }

      @Override
      public Context createContext() {
        return new Context() {
          int next = 0;
          final int max = ra.size();
          @Override
          public T produce() throws SourceExhausted {
            exhaustedIf(next >= max);
            return ra.get(next++);
          }};
      }
    };
  }


  public static Chain<Complete, Integer> ints(int min, int max, int step) {
    return new IntSeqHead(min, max, step);
  }

  public static Chain<Complete, Integer> ints(int min, int max) {
    return ints(min, max, min > max ? -1 : 1);
  }
  
  public static Chain<Complete, Integer> intsFrom(int min, int step) {
    return ints(min, Integer.MAX_VALUE, step);
  }

  public static Chain<Complete, Integer> intsFrom(int min) {
    return intsFrom(min, 1);
  }

  public static Chain<Complete, Integer> randomInts(int min, int max) {
    return from(Functions.randomInts(min, max));
  }

  public static Chain<Complete, Double> randomDoubles() {
    return from(Functions.randomDoubles());
  }

  public static Chain<Complete, Double> gaussian(double mean, double stdDev) {
    return from(Functions.gaussian(mean, stdDev));
  }
  
  public static Chain<Complete, Boolean> booleans(double withProb) {
    return from(Functions.randomBooleans(withProb));
  }
  
  public static <T> Chain<Complete, T> from(final RandomChoice<? extends T> choices) {
    return from(new Generator<T>() {
      @Override
      public T generate() throws SourceExhausted {
        return choices.choose();
      }});
  }
  public static <T> Chain<Complete, T> from(final Chooser<? extends T> choices) {
    return from(new Generator<T>() {
      @Override
      public T generate() throws SourceExhausted {
        return choices.select();
      }});
  }
  
  // ---------------------------------------


  public <T> Chain<From,T> into(Chain<? super To,T> chain) {
    return chain.prepend(this);
  }

  public Chain<From, NoValue> into(Consumer<? super To> consumer) {
    /*
     * This (and the others like it) doesn't work under Java 8 if I
     * just return the call to activate(), even though activate() is
     * declared to return the type of its argument.
     */
    //    return activate(new ConsumerSink<From,To>(this, Functions.always(consumer)));
    ConsumerSink<From, To> c = new ConsumerSink<>(this, Functions.always(consumer));
    activate(c);
    return c;
  }

  public Chain<From, NoValue> into(PrintStream out) {
    return into(Functions.streamConsumer(out));
  }

  public <C extends Collection<? super To>> CollectorSink<From,To,C>into(C collection) {
    //    return activate(new CollectionSink<From,To,C>(this, collection));
    CollectionSink<From,To,C> c = new CollectionSink<>(this, collection);
    activate(c);
    return c;
  }

  public CollectorSink<From, To, List<To>> intoList() {
    return into((List<To>)new ArrayList<To>());
  }
  public CollectorSink<From, To, Set<To>> intoSet() {
    return into((Set<To>)new HashSet<To>());
  }

  public List<To> asList() {
    return intoList().val();
  }

  public Set<To> asSet() {
    return intoSet().val();
  }
  
  
  public <Y> Y[] asArray(Class<Y> clss) {
    List<To> list = asList();
    Y[] array = ArrayUtils.newArray(clss, list.size());
    return list.toArray(array);
  }


  public <X> CollectorSink<From, To, X> reduce(final Reducer<? super To, X> reducer, final X initial) {
    return activate(new ReducerSink<From, To, X>(this, Functions.always(reducer), initial));
  }

  public <X> CollectorSink<From, To, X> reduce(final Reducer<? super To, X> reducer) {
    return reduce(reducer, null);
  }

  public CollectorSink<From, To, To> max(Comparator<? super To> comparator) {
    return reduce(Functions.max(comparator), null);
  }

  public CollectorSink<From, To, To> max() {
    return max(Functions.<To>naturalOrder());
  }

  public CollectorSink<From, To, To> min(Comparator<? super To> comparator) {
    return reduce(Functions.min(comparator), null);
  }

  public CollectorSink<From, To, To> min() {
    return min(Functions.<To>naturalOrder());
  }
  
  public Chain<From, To> min(int n, Comparator<? super To> comparator) {
    //    return activate(new TopNLink<>(this, n, comparator));
    TopNLink<From,To> c = new TopNLink<>(this, n, comparator);
    activate(c);
    return c;
  }
  public Chain<From, To> min(int n) {
    return min(n, Functions.<To>naturalOrder());
  }
  public Chain<From, To> max(int n, Comparator<? super To> comparator) {
    return min(n, Functions.opposite(comparator));
  }
  public Chain<From, To> max(int n) {
    return max(n, Functions.<To>naturalOrder());
  }
  public Chain<From, To> minDistinct(int n, Comparator<? super To> comparator) {
    //    return activate(new TopNDistinctLink<>(this, n, comparator));
    TopNDistinctLink<From,To> c = new TopNDistinctLink<>(this, n, comparator);
    activate(c);
    return c;
  }
  public Chain<From, To> minDistinct(int n) {
    return minDistinct(n, Functions.<To>naturalOrder());
  }
  public Chain<From, To> maxDistinct(int n, Comparator<? super To> comparator) {
    return minDistinct(n, Functions.opposite(comparator));
  }
  public Chain<From, To> maxDistinct(int n) {
    return maxDistinct(n, Functions.<To>naturalOrder());
  }

  public CollectorSink<From, To, Integer> count() {
    return reduce(Functions.count(), 0);
  }
  
  public <Out> Chain<From, Out> running(NullaryFunc<? extends Reducer<? super To, Out>> creator, Out initial) {
    //    return activate(new RunningLink<From,To,Out>(this, creator, initial));
    RunningLink<From,To,Out> c = new RunningLink<>(this, creator, initial);
    activate(c);
    return c;

  }
  public <Out> Chain<From, Out> running(Reducer<? super To, Out> reducer, Out initial) {
    return running(Functions.always(reducer), initial);
  }
  public Chain<From, To> gate(NullaryFunc<? extends Control<? super To>> creator) {
    //    return activate(new GatingLink<>(this, creator));
    GatingLink<From,To> c = new GatingLink<>(this, creator);
    activate(c);
    return c;
  }
  public Chain<From, To> gate(Control<? super To> control) {
    return gate(Functions.always(control));
  }
  
  public CollectorSink<From, ?, To> first() {
    return activate(new CollectorSink<From, To, To>(this, null) {
      @Override
      protected boolean see(To elt) {
        val = elt;
        return false;
      }});
  }
  
  public To firstVal() {
    return first().val();
  }

  public Chain<From, To> first(final int n) {
    return gate(new NullaryFunc<Control<Object>>() {
      @Override
      public Control<Object> call() {
        return new Control<Object>() {
          int nSeen = 0;
          @Override
          public ControlVal check(Object val) {
            if (nSeen >= n) {
              return ControlVal.STOP;
            }
            nSeen++;
            return ControlVal.USE;
          }};
      }});
  }

  public Chain<From, To> skip(final int n) {
    return gate(new NullaryFunc<Control<Object>>() {
      @Override
      public Control<Object> call() {
        return new Control<Object>() {
          int nSeen = 0;
          @Override
          public ControlVal check(Object val) {
            if (nSeen >= n) {
              return ControlVal.USE;
            }
            nSeen++;
            return ControlVal.SKIP;
          }};
      }});
  }

  public Chain<From, To> observe(NullaryFunc<? extends Observer<? super To>> creator) {
    //    return activate(new ObserverLink<>(this, creator));
    ObserverLink<From,To> c = new ObserverLink<>(this, creator);
    activate(c);
    return c;
  }
  public Chain<From, To> observe(Observer<? super To> control) {
    return observe(Functions.always(control));
  }

  public <C extends Collection<? super To>> Chain<From, To> collect(final C collection) {
    return observe(new Observer<To>() {
      @Override
      public boolean observe(To val) {
        collection.add(val);
        return true;
      }});
  }

  public ObserverLink<From, To>monitor(final String format, final PrintStream out) {
    return (ObserverLink<From, To>)observe(new Observer<To>() {
      @Override
      public boolean observe(To val) {
        out.format(format, val);
        return true;
      }});
  }
  public Chain<From, To>monitor(final String format) {
    return monitor(format, System.out);
  }

  public <T> Chain<From, T> map(NullaryFunc<? extends UnaryFunc<? super To, ? extends T>> creator) {
    //    return activate(new TransformerLink<>(this, creator));
    TransformerLink<From,To, T> c = new TransformerLink<>(this, creator);
    activate(c);
    return c;
  }

  public <T> Chain<From, T> map(UnaryFunc<? super To, ? extends T> transformer) {
    return map(Functions.always(transformer));
  }
  
  public <T> Chain<From, String> asString() {
    return map(ObjUtils.asString());
  }

  public <T> Chain<From, T> run(NullaryFunc<? extends Process<? super To, ? extends T>> creator) {
    //    return activate(new ProcessLink<>(this, creator));
    ProcessLink<From,To,T> c = new ProcessLink<>(this, creator);
    activate(c);
    return c;
  }

  public <T> Chain<From, T> run(Process<? super To, ? extends T> process) {
    return run(Functions.always(process));
  }

  public Chain<From,To> remove(NullaryFunc<? extends Predicate<? super To>> creator) {
    //    return activate(new FilterLink<>(this, creator, false));
    FilterLink<From,To> c = new FilterLink<>(this, creator, false);
    activate(c);
    return c;
  }

  public Chain<From,To> remove(Predicate<? super To> pred) {
    return remove(Functions.always(pred));
  }

  public Chain<From,To> keep(NullaryFunc<? extends Predicate<? super To>> creator) {
    //    return activate(new FilterLink<>(this, creator, true));
    FilterLink<From,To> c = new FilterLink<>(this, creator, true);
    activate(c);
    return c;
  }

  public Chain<From, To> keep(Predicate<? super To> pred) {
    return keep(Functions.always(pred));
  }

  public <T> Chain<From,T> cat(NullaryFunc<? extends UnaryFunc<? super To, ? extends Iterable<? extends T>>> creator) {
    //    return activate(new CatLink<>(this, creator));
    CatLink<From,To,T> c = new CatLink<>(this, creator);
    activate(c);
    return c;
  }
  public <T> Chain<From, T> cat(UnaryFunc<? super To, ? extends Iterable<? extends T>> transformer) {
    return cat(Functions.always(transformer));
  }
  public <T> Chain<From, T> cat() {
    return cat(new UnaryFunc<To,Iterable<? extends T>>() {
      @SuppressWarnings("unchecked")
      @Override
      public Iterable<? extends T> call(To val) {
        if (val.getClass().isArray()) {
          return Arrays.asList((T[])val);
        }
        return (Iterable<? extends T>) val;
      }});
  }

  public CollectorSink<From,To,To> last() {
    //    return activate(new LastSink<>(this));
    LastSink<From,To> c = new LastSink<>(this);
    activate(c);
    return c;
  }

  public Chain<From,To> last(int n) {
    //    return activate(new LastNSink<>(this, n));
    LastNSink<From,To> c = new LastNSink<>(this, n);
    activate(c);
    return c;
  }

  public Chain<From,To> pickWithReplacement() {
    return pickWithReplacement(Integer.MAX_VALUE);
  
  }
  public Chain<From,To> pickWithReplacement(int n) {
    //    return activate(new WithReplacementLink<>(this, n));
    WithReplacementLink<From,To> c = new WithReplacementLink<>(this, n);
    activate(c);
    return c;
  }
  
  public Chain<From, To> pick(int k, int n) {
    //    return activate(new WithoutReplacementLink<>(this, k, n));
    WithoutReplacementLink<From,To> c = new WithoutReplacementLink<>(this, n);
    activate(c);
    return c;
  }
  public Chain<From, To> pick(int k) {
    return pick(k, Integer.MAX_VALUE);
  }

  public KeyValChain<From,Integer,To> indexed() {
    //    return activate(new IndexedLink<>(this));
    IndexedLink<From,To> c = new IndexedLink<>(this);
    activate(c);
    return c;
  }

  public Chain<From, To> unique() {
    return keep(Functions.unique());
  }
  
  public Chain<From,To> changed() {
    return keep(Functions.different());
  }
  
  public Chain<From,To> prefix(@SuppressWarnings("unchecked") final To...vals) {
    //    return activate(new Link<From,To,To>(this) {
    Link<From,To,To> c = new Link<From,To,To>(this) {

        @Override
        public Context createContext() {
          return new Context() {
            int i = 0;
            @Override
            public To produce() throws SourceExhausted {
              if (i >= vals.length) {
                return source.produce();
              }
              return vals[i++];
            }
          };
        }
      
        @Override
        public Flow pipeInto(Receiver<? super To> sink) {
          return pred.pipeInto(new ChainedReceiver<To, To>(sink) {
              boolean firstTime = true;
              @Override
              public boolean receive(To val) {
                if (firstTime) {
                  firstTime = false;
                  for (To v : vals) {
                    if (!sink.receive(v)) {
                      return false;
                    }
                  }
                }
                return sink.receive(val);
              }
            });
        }
      };
    activate(c);
    return c;
  }

  public Chain<From,To> suffix(@SuppressWarnings("unchecked") final To...vals) {
    //return activate(new Link<From,To,To>(this) {
    Link<From,To,To> c = new Link<From,To,To>(this) {

        @Override
        public Context createContext() {
          return new Context() {
            boolean sourceDone = false;
            int i = 0;
            @Override
            public To produce() throws SourceExhausted {
              if (!sourceDone) {
                try {
                  return source.produce();
                } catch (SourceExhausted e) {
                  sourceDone = true;
                }
              }
              if (i >= vals.length) {
                throw SOURCE_EXHAUSTED;
              }
              return vals[i++];
            }
          };
        }
      

        @Override
        public Flow pipeInto(Receiver<? super To> sink) {
          return pred.pipeInto(new ChainedReceiver<To, To>(sink) {
              @Override
              public boolean receive(To val) {
                return sink.receive(val);
              }
              @Override
              public void close() {
                for (To v : vals) {
                  if (!sink.receive(v)) {
                    return;
                  }
                }
              }
            });
        }
      };
    activate(c);
    return c;
  }
  
  public Chain<From,To> noting(LastException holder, boolean keep) {
    return noting(Functions.always(holder), keep);
  }
  public Chain<From,To> noting(final NullaryFunc<LastException> creator, final boolean keep) {
    //    return activate(new Link<From,To,To>(this) {
    Link<From,To,To> c = new Link<From,To,To>(this) {
        @Override
        public Context createContext() {
          return new Context() {
            final LastException holder = creator.call(); 
            @Override
            public To produce() throws SourceExhausted {
              holder.setThrowable(null);
              try {
                return source.produce();
              } catch (SourceExhausted e) {
                holder.setThrowable(e.getCause());
                throw keep ? e : SOURCE_EXHAUSTED;
              }
            }};
        }

        @Override
        public Flow pipeInto(Receiver<? super To> sink) {
          return pred.pipeInto(sink);
        }};
    activate(c);
    return c;
  }
  
  // ---------------------------------------
  @SuppressWarnings("unused")
  static void testSyntax() {
    Chain<Complete, Integer> x = ints(1, 100);
  }

  public static void main(String[] args) {
    //    Chain.ints(1, 100).max().into(System.out);
    //    Chain.gaussian(10, 5).into(System.out);
    //    GeneratorHead<Integer> head = ints(1, 10);
    //    ReducerSink<Number, Number> tail = Chain.from(Number.class).max();
    //    Chain<Complete, Number> newChain = head.into(tail);
    //    newChain.into(System.out);
    //    Chain.ints(1, 100).first(5).into(System.out);
    //    for (int i : Chain.ints(1, 5)) {
    //      System.out.format("Got: %,d%n", i);
    //    }
    //    Chain.ints(1, 100).last(5).into(System.out);
    //    int[] ints = {1,2,3,4,5};
    //    Chain.ints(1,100).first(10).running(Functions.intSum(), 0).into(System.out);
    Predicate<Integer> even = new Predicate<Integer>() {
      @Override
      public boolean test(Integer val) {
        return val % 2 == 0;
      }
    }; 
    //		Chain.ints(1,100).run(Functions.keep(even)).into(System.out);
    Chain.ints(1, 100).remove(even).count().into(System.out);
    Chain<String, String[]> asCSV = Chain.from(String.class)
        .map(Functions.namedFile())
        .cat(Functions.openFile(FileOption.utf8))
        .run(Functions.csv());
    //		for (String[] fields : Chain.from(new File("test.csv")).run(Functions.csv())) {
    //		for (String[] fields : Chain.from(new File("test.csv")).into(asCSV)) {
    for (String[] fields : Chain.send("test.csv").into(asCSV)) {
      System.out.format("Line%n");
      for (String f : fields) {
        System.out.format("Field: <%s>%n", f);
      }
    }
    Map<String, Integer> map = new HashMap<>();
    map.put("a", 1);
    map.put("b", 2);
    map.put("c", 2);
    //		TransformerLink<Complete, Pair<String, Integer>, Object> c = Chain.from(map).map(Functions.keys());
    Chain.from(map).keys().into(System.out);
    //	List<String> keys = Chain.from(map).map(Functions.<String>keys()).into(new ArrayList<String>()).val();
    List<String> keys = Chain.from(map).keys().asList();
    Set<Integer> vals = Chain.from(map).values().asSet();
    System.out.format("%s%n", keys);
    System.out.format("%s%n", vals);
    Chain.from(map).values().indexed().into(new HashMap<Number,Number>()).into(System.out);
    Chain.from(map).values().monitor("Val: %s%n").unique().into(System.out);
    for (int i : Chain.from(map).values().monitor("Val: %s%n").unique()) {
      System.out.format("%d%n", i);
    }
  }


}
