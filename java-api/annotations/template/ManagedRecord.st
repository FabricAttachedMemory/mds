/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

ManagedRecord(
	pkg, 
	simple_name, 
	type_name, 
	parent,
	superInterfaces, 
	fields,
	declaredFields,
	protectedFields,
	privateFields,
	publicFields,
	privateMethods,
	protectedMethods,
	publicMethods,
	userConstructors,
	creationMethodsImpl,
	publicCreationMethods,
	protectedCreationMethods,
	privateCreationMethods, 
	implModifier,
	publicStaticMethods,
	protectedStaticMethods,
	privateStaticMethods,
	ambiguousMethods) ::= <<
$if(pkg)$package $pkg$;$endif$

/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */
 
public interface $simple_name$ extends $if(parent)$$parent$$else$com.hpl.mds.ManagedRecord$endif$ $superInterfaces:{s |, $s$}$ {
	interface TypeDef {
		static final com.hpl.mds.RecordType<$simple_name$> TYPE
			= com.hpl.mds.RecordType.declare("$type_name$", Impl.class$if(parent)$, $parent$.TypeDef.TYPE$endif$);
		// field creation
		$fields$
		
		static final boolean created = TypeDef.TYPE.ensureCreated();
	}

	interface SMDefs $if(parent)$extends $parent$.SMDefs$endif$ {
		// public static method and field accessors declarations
		$publicStaticMethods$
		
		interface AsProtected extends SMDefs $if(parent)$, $parent$.SMDefs.AsProtected$endif$ {
			// protected static method and field accessor declarations
			$protectedStaticMethods$
		}
		interface AsPrivate extends AsProtected {
			// public, protected, and private static method and field accessor defaults
			$privateStaticMethods$
		}
	}
	
	class StaticMethod$if(parent)$ extends $parent$.StaticMethod$endif$ implements SMDefs.AsPrivate {
                static final StaticMethod instance = new StaticMethod();
        // definitions for diamond-ambiguous methods
    }

	final class Statics {
		// static members and init blocks, in order
		$declaredFields$
	}

	final class Create {
		// static public creation methods
	}

	interface Creator {
		// public creation method declarations
		$publicCreationMethods$
		
		interface AsProtected extends Creator {
			$protectedCreationMethods$
			// public and protected creation method declarations
		}
		interface AsPrivate extends AsProtected {
			$privateCreationMethods$
			// public, protected, and private creation method declarations
		}
		default Creator as(com.hpl.mds.ManagedRecord self) {
			return this;
		}
		default Creator as(com.hpl.mds.ManagedRecord.StaticAccess self) {
			return this;
		}

		AsProtected as($simple_name$.Protected self);
		AsProtected as($simple_name$.SMDefs.AsProtected access);
		AsPrivate as($simple_name$.Private self);
		AsPrivate as($simple_name$.SMDefs.AsPrivate access);

		class Instance implements Creator.AsPrivate {
			// creation method definitions
			$creationMethodsImpl$

			public AsProtected as($simple_name$.Protected self) {
				return this;
			}
			public AsProtected as($simple_name$.SMDefs.AsProtected access) {
				return this;
			}
			public AsPrivate as($simple_name$.Private self) {
				return this;
			}
			public AsPrivate as($simple_name$.SMDefs.AsPrivate access) {
				return this;
			}
		}
	}

	// public constant copies
	// public fields and accessors
	// public static member accessors
	// public methods
	// public static methods
	// public creation methods
	
	$publicFields$
	
	$publicMethods$
	
	public com.hpl.mds.RecordType<? extends $simple_name$> type();
	
	static final com.hpl.mds.RecordType<$simple_name$> TYPE = TypeDef.TYPE;
	static final Creator create = new Creator.Instance();
	
	$simple_name$ bindName(com.hpl.mds.naming.HName name);
	$simple_name$ bindName(CharSequence... segments);
	$simple_name$ bindName(com.hpl.mds.naming.Namespace namespace, CharSequence name);
	$simple_name$ bindName(char sep, CharSequence... segments);
	$simple_name$ bindName(java.util.List<? extends CharSequence> segments);
	$simple_name$ bindName(char sep, java.util.List<? extends CharSequence> segments);

	public $simple_name$ seeAs(com.hpl.mds.ManagedRecord access);
	public $simple_name$ seeAs(com.hpl.mds.ManagedRecord.StaticAccess access);
	public $simple_name$.Protected seeAs($simple_name$.Protected access);
	public $simple_name$.Protected seeAs($simple_name$.SMDefs.AsProtected access);
	public $simple_name$.Private seeAs($simple_name$.Private access);
	public $simple_name$.Private seeAs($simple_name$.SMDefs.AsPrivate access);
	
	public static SMDefs callAs(com.hpl.mds.ManagedRecord.StaticAccess access) {
                return StaticMethod.instance;
        }
        public static SMDefs.AsProtected callAs($simple_name$.Protected access) {
                return StaticMethod.instance;
        }
        public static SMDefs.AsProtected callAs($simple_name$.SMDefs.AsProtected access) {
                return StaticMethod.instance;
        }
        public static SMDefs.AsPrivate callAs($simple_name$.Private access) {
                return StaticMethod.instance;
        }
        public static SMDefs.AsPrivate callAs($simple_name$.SMDefs.AsPrivate access) {
                return StaticMethod.instance;
        }

	interface Protected extends $simple_name$ $if(parent)$, $parent$.Protected $endif${
		// protected constant copies
		// protected fields and accessors
		// protected static member accessors
		// protected methods
		// protected static methods
		// protected creation methods
		
		$protectedFields$
		
		$protectedMethods$
		
		public com.hpl.mds.RecordType<? extends $simple_name$> type();
		
		$simple_name$ bindName(com.hpl.mds.naming.HName name);
		$simple_name$ bindName(CharSequence... segments);
		$simple_name$ bindName(com.hpl.mds.naming.Namespace namespace, CharSequence name);
		$simple_name$ bindName(char sep, CharSequence... segments);
		$simple_name$ bindName(java.util.List<? extends CharSequence> segments);
		$simple_name$ bindName(char sep, java.util.List<? extends CharSequence> segments);
	} 

	interface Private extends Protected {
		// private constant copies
		// private fields and accessors
		// private static member accessors
		// private methods and defaults for public, protected:
		// private static methods
		// private creation methods
		// subclass init methods
		// super init methods
		$privateFields$
		
		$privateMethods$
		
		$simple_name$ bindName(com.hpl.mds.naming.HName name);
		$simple_name$ bindName(CharSequence... segments);
		$simple_name$ bindName(com.hpl.mds.naming.Namespace namespace, CharSequence name);
		$simple_name$ bindName(char sep, CharSequence... segments);
		$simple_name$ bindName(java.util.List<? extends CharSequence> segments);
		$simple_name$ bindName(char sep, java.util.List<? extends CharSequence> segments);

		default public $simple_name$.Protected seeAs($simple_name$.Protected access) {
			return this;
		}

		default public $simple_name$.Protected seeAs($simple_name$.SMDefs.AsProtected access) {
			return this;
		}

		default public $simple_name$.Private seeAs($simple_name$.Private access) {
			return this;
		}

		default public $simple_name$.Private seeAs($simple_name$.SMDefs.AsPrivate access) {
			return this;
		}
	} 

	$implModifier$ class Impl extends $if(parent)$$parent$.Impl$else$com.hpl.mds.impl.ManagedRecordProxy$endif$ implements Private {

		// user-defined constructors
		// definitions for diamond-ambiguous methods

        $ambiguousMethods$
        
		$userConstructors$
		
		public Impl(com.hpl.mds.RecordType<? extends $simple_name$> type) {
			super(type);
		}
		public Impl(FromHandle fh, long handle,
					com.hpl.mds.RecordType<? extends $simple_name$> type) {
			super(fh, handle, type);
		}
		public Impl(FromHandle fh, long handle) {
			this(fh, handle, $simple_name$.TYPE);
		}
	
		public com.hpl.mds.RecordType<? extends $simple_name$> type() {
			return typeOf(this);
		}
		
		public $packageFormat(pkg)$$simple_name$.Impl bindName(com.hpl.mds.naming.HName name) {
			return name.bind(this);
		}
		public $packageFormat(pkg)$$simple_name$.Impl bindName(CharSequence... segments) {
			return bindName(com.hpl.mds.naming.HName.from(segments));
		}
		public $packageFormat(pkg)$$simple_name$.Impl bindName(com.hpl.mds.naming.Namespace namespace, CharSequence name) {
            return namespace.bind(name, this);
        }
		public $packageFormat(pkg)$$simple_name$.Impl bindName(char sep, CharSequence... segments) {
			return bindName(com.hpl.mds.naming.HName.from(sep, segments));
		}
		public $packageFormat(pkg)$$simple_name$.Impl bindName(java.util.List<? extends CharSequence> segments) {
			return bindName(com.hpl.mds.naming.HName.from(segments));
		}
		public $packageFormat(pkg)$$simple_name$.Impl bindName(char sep, java.util.List<? extends CharSequence> segments) {
			return bindName(com.hpl.mds.naming.HName.from(sep, segments));
		}

		public $simple_name$ seeAs(com.hpl.mds.ManagedRecord access) {
			return this;
		}
		public $simple_name$ seeAs(com.hpl.mds.ManagedRecord.StaticAccess access) {
			return this;
		}

		public $simple_name$.Protected seeAs($simple_name$.Protected access) {
			return this;
		}

		public $simple_name$.Protected seeAs($simple_name$.SMDefs.AsProtected access) {
			return this;
		}

		public $simple_name$.Private seeAs($simple_name$.Private access) {
			return this;
		}

		public $simple_name$.Private seeAs($simple_name$.SMDefs.AsPrivate access) {
			return this;
		}
	}
}
>>
