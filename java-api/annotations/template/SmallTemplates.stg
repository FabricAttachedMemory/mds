/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */


/****************************************************/
/**													*/
/**			Common used small templates				*/
/**													*/
/****************************************************/

/** package format */
packageFormat(pkg) ::= "$if(pkg)$$pkg$.$endif$"

/** fields definition */
fieldDef(type, typeParams, name, creationMethod, methodArgs)  ::= << 
static final $type$<$typeParams; separator=", "$> $name$ = TYPE.$creationMethod$($methodArgs; separator=", "$);

>>

/** fields declaration at the required visibility level */
fieldMember(type, typeParams, name, recordType) ::= "static final $type$<$typeParams; separator=\", \"$> $name$ = $recordType$.TypeDef.$name$;$\n$"


/****************************************************/
/**				getters and setters					*/
/****************************************************/

/** getter implementation */
getterImpl(type, getterName, fieldName, getValueMethod, recordName) ::= <<
default $type$ $getterName$() {
    $\t$return $recordName$.Statics.$fieldName$.$getValueMethod$(this);
}

>>

/** getter declaration */
getterDeclaration(type, getterName) ::= "$type$ $getterName$();$\n$"

/** modifier implementation with no arguments*/
modifierImplNoArgs(modifierName, fieldName, fieldMethod, recordName, numType) ::= <<
default $numType$ $modifierName$() {
    return $recordName$.Statics.$fieldName$.$fieldMethod$(this, ($numType$)1);
}

>>

/** modifier declaration with no arguments*/
modifierDeclarationNoArgs(modifierName, typeParam) ::= "$typeParam$ $modifierName$();$\n$"

/** modifier implementation */
modifierImpl(modifierName, typeParam, fieldName, fieldMethod, recordName) ::= <<
default $typeParam$ $modifierName$($typeParam$ val) {
    return $recordName$.Statics.$fieldName$.$fieldMethod$(this, val);
}

>>

/** modifier declaration */
modifierDeclaration(modifierName, typeParam) ::= "$typeParam$ $modifierName$($typeParam$ val);$\n$"

/****************************************************/
/**						methods						*/
/****************************************************/

/** generic method declaration */
methodDeclaration(methodName, returnType, parameters) ::= "$returnType$ $methodName$($parameters$);$\n$"

/** instance method implementation */
methodImplementation(
    methodName, 
    returnType, 
    parameters, 
    schema, 
    arguments, 
    schemaMethod, 
    castStart, 
    castEnd) ::= <<
default $returnType$ $methodName$($parameters$) {
$\t$$castStart$$schema$.$schemaMethod$($arguments; separator=", "$)$castEnd$;
}

>>

/** ambiguous method implementation */
ambiguousMethod(
    methodName, 
    returnType, 
    parameters, 
    schema, 
    arguments, 
    schemaMethod, 
    castStart, 
    castEnd) ::= <<
public $returnType$ $methodName$($parameters$) {
$\t$$castStart$$schema$.$schemaMethod$($arguments; separator=", "$)$castEnd$;
}

>>

/** static method */
staticMethod(
    methodName, 
    returnType, 
    parameters, 
    schema, 
    arguments, 
    schemaMethod, 
    castStart, 
    castEnd) ::= <<
static $returnType$ $methodName$($parameters$) {
$\t$$castStart$$schema$.$schemaMethod$($arguments; separator=", "$)$castEnd$;
}

>>

/****************************************************/
/**     	constructors and creation methods		*/
/****************************************************/

/** user defined constructor */
userConstructor(
    recordName,
    parameters, 
    schema, 
    arguments) ::= <<
public Impl($parameters; separator=", "$) {
$\t$super($recordName$.TYPE);
$\t$$schema$.$recordName$(this$arguments:{a |, $a$}$);
}

>>

/** default constructor implementation */
defaultConstructor(recordName) ::= <<
public Impl() {
$\t$super($recordName$.TYPE);
}

>>

/** creation method implementation*/
creationMethodImpl(recordName, parameters, arguments) ::= <<
public $recordName$.Impl record($parameters$) {
$\t$return new Impl($arguments; separator=", "$);
}

>>

/** creation method declaration*/
creationMethodDec(returnType, parameters) ::= <<
$returnType$ record($parameters$);

>>