/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processors;

import static org.junit.Assert.assertTrue;

import java.io.ByteArrayOutputStream;
import java.io.OutputStream;

import org.junit.Test;

import com.hpl.mds.annotations.Paradigm;

public class AnnotationProcessorErrorTest {

    private static final String PATH = "com/hpl/mds/test/error/";

    private static final JCompiler COMPILER = JCompiler.getInstance();

    @Test
    public void shouldLogErrorWhenInvalidGetterFormat() throws Exception {
        compileSchema("RecordGetterNameInvalid", "ignoring getter name format, should contain %s");
    }

    @Test
    public void shouldLogErrorWhenEmptyBooleanGetterFormat() throws Exception {
        compileSchema("RecordGetterNameEmptyBoolean", "ignoring getter name format, empty format for boolean type");
    }

    @Test
    public void shouldLogErrorWhenEmptyNonBooleanGetterFormat() throws Exception {
        compileSchema("RecordGetterNameEmptyNonBoolean",
                "ignoring getter name format, empty format for non-boolean type");
    }

    @Test
    public void shouldLogErrorWhenReferencedClassIsNotAParadigm() throws Exception {
        OutputStream err = new ByteArrayOutputStream();
        String record = "RecordNotAParadigm";
        COMPILER.compileSchema(err, PATH + "NotAParadigm.java", PATH + record + "Schema.java");
        verifyRecordAndErrors(PATH + record + ".java", err, "not a paradigm");
    }

    @Test
    public void shouldLogErrorWhenSchemaWithParadigmNotFound() throws Exception {
        compileSchema("RecordParadigmNotFound", "paradigm not found");
    }

    @Test
    public void shouldLogErrorWhenSchemaWithNoArgumentsParadigm() throws Exception {
        compileSchema("Paradigm", "Empty value for: " + Paradigm.class.getName());
    }

    @Test
    public void shouldLogErrorWhenDuplicatedFieldInParent() throws Exception {
        OutputStream err = new ByteArrayOutputStream();
        String record = "InheritanceDuplicatedField";
        COMPILER.compileSchema(err, PATH + record + "Schema.java", PATH + "InheritanceParentSchema.java");
        verifyRecordAndErrors(PATH + record + ".java", err,
                "The name of the field myInt already exists in the parent record: ");
    }

    @Test
    public void shouldLogErrorForRecervedRecordNames() throws Exception {
        compileSchema("RecordReservedName", "Illegal record name");
    }

    @Test
    public void shouldLogErrorWhenAbstractMethodWithPrivateVisibility() throws Exception {
        compileSchema("MethodAbstractPrivate", "Illegal visibility level for abstract method");
    }

    @Test
    public void shouldLogErrorWhenAbstractMethodInNonAbstractSchema() throws Exception {
        compileSchema("MethodAbstractNonAbstractRecord", "abstract method found in non-abstract schema");
    }

    @Test
    public void shouldLogErrorWhenConstructorWithPrivateProtectedRecord() throws Exception {
        COMPILER.compileSchema(PATH + "RecordEmptyTypeSchema.java");
        compileSchema("ConstructorProtectedRecord", "Ignoring constructor");
    }

    @Test
    public void shouldLogErrorWhenCreationMethodWithSameSignature() throws Exception {
        compileSchema("MethodsSameCreationMethods", "A method with the same signature has already been generated");
    }

    @Test
    public void shouldLogErrorWhenMethodsWithSameSignature() throws Exception {
        compileSchema("MethodsSameSignature", "A method with the same signature has already been generated");
    }

    @Test
    public void shouldLogErrorWhenConstructorWithReturnType() throws Exception {
        compileSchema("ConstructorError", "Ignoring return type of constructor: ");
    }

    @Test
    public void shouldLogErrorWhenInstanceMethodWithAnnotatedNoManagedParameter() throws Exception {
        COMPILER.compileSchema(PATH + "FieldCharSchema.java");
        compileSchema("MethodMngError", "Ignoring annotation, invalid data type for annotation:");
    }

    @Test
    public void shouldLogErrorWhenProcessSchemaWithInvalidRecordNameFormat() throws Exception {
        compileSchema("RecordInvalidNameFormat", "Invalid format for record name:");
    }

    @Test
    public void shouldLogErrorWhenProcessSchemaWithInvalidRecordName() throws Exception {
        compileSchema("RecordInvalidClassName", "Illegal name");
    }

    @Test
    public void shouldLogErrorWhenProcessSchemaWithSameRecordName() throws Exception {
        compileSchema("RecordSameName", "Illegal record name, is equals to the schema");
    }

    @Test
    public void shouldLogErrorWhenProcessRecordWithoutSuffix() throws Exception {
        compileSchemaFile(PATH + "RecordSchemaWithoutSuffix.java", PATH + "SchemaWithoutSuffix.java",
                "Schema interface without \"Schema\" suffix");
    }

    @Test
    public void shouldLogErrorWhenProcessNestedRecord() throws Exception {
        compileSchemaFile(PATH + "RecordGrantParentOfRecordSchema.java", PATH + "NestedRecord.java",
                "Nested record schemas are not supported, parent type: ");
    }

    @Test
    public void shouldLogErrorWhenProcessRecordWithInvalidName() throws Exception {
        compileSchema("RecordInvalidName", "illegal record name");
    }

    @Test
    public void shouldLogErrorWhenInvalidMethodVisibility() throws Exception {
        String multipleVisibility = "only one visibility annotation allowed";
        compileSchema("MethodInstanceError", "Ignoring annotation. illegal visibility value", "Ignoring annotation",
                multipleVisibility, multipleVisibility, multipleVisibility);
    }

    @Test
    public void shouldLogErrorWhemEmptyType() throws Exception {
        compileSchema("RecordEmptyType", "Empty name in annotation: ");
    }

    @Test
    public void shouldLogErrorWithVoidField() throws Exception {
        compileFieldError("FieldVoidType", "Unsupported datatype:VOID");
    }

    @Test
    public void shouldLogErrorWithUnknownTypeField() throws Exception {
        compileFieldError("FieldUnknownType", "Unsupported datatype:");
    }

    @Test
    public void shouldLogErrorWithSetFieldWithoutValueType() throws Exception {
        compileFieldError("FieldSetWithoutValueType", "Illegal number of parameters for data type: SET");
    }

    @Test
    public void shouldLogErrorWithMapFieldWithoutParameterTypes() throws Exception {
        compileFieldError("FieldMapWithoutParameters", "Illegal number of parameters for data type: MAP");
    }

    @Test
    public void shouldLogErrorWithListFieldWithoutValueType() throws Exception {
        compileFieldError("FieldListWithoutValueType", "Illegal number of parameters for data type: LIST");
    }

    @Test
    public void shouldLogErrorWithCollectionFieldWithUnknownParameterType() throws Exception {
        compileFieldError("FieldColletionWithUnknownParameter", "Unknown parameter data type: ?");
    }

    @Test
    public void shouldLogErrorWithCharField() throws Exception {
        compileFieldError("FieldChar", "Unsupported datatype:CHAR");
    }

    @Test
    public void shouldLogErrorWhenSchemaExtendsRecord() throws Exception {
        OutputStream err = new ByteArrayOutputStream();
        COMPILER.compileSchema(err, PATH + "ExtendsWithRecordSchema.java");
        verifyRecordAndErrors(PATH + "ExtendsWithRecord.java", err,
                "Ignoring interface, use schema interface instead:");
    }

    // @Test TODO implement @Field annotation
    public void shouldLogErrorWithTwoFieldsOfSameName() throws Exception {
        compileSchema("TwoFieldSameName", "");
    }

    private void compileFieldError(String schema, String fieldError) throws Exception {
        compileSchema(schema, "Ignoring Field", fieldError);
    }

    private void compileSchema(String schemaSuffix, String... errorMsgs) throws Exception {
        compileSchemaFile(PATH + schemaSuffix + "Schema.java", PATH + schemaSuffix + ".java", errorMsgs);
    }

    private void compileSchemaFile(String schemaFile, String recordFile, String... errorMsgs) throws Exception {
        OutputStream err = new ByteArrayOutputStream();
        COMPILER.compileSchema(err, schemaFile);
        verifyRecordAndErrors(recordFile, err, errorMsgs);
    }

    private void verifyRecordAndErrors(String recordFile, OutputStream err, String... errorMsgs)
            throws ClassNotFoundException {
        String errLog = err.toString();
        System.err.print("log: " + errLog);
        int lastIndex = 0;
        for (String errorMsg : errorMsgs) {
            lastIndex = errLog.indexOf(errorMsg, lastIndex) + 1;
            assertTrue("error message not in log: " + errorMsg, lastIndex > 1);
        }
        COMPILER.compileLoadRecord(recordFile);
    }
}
