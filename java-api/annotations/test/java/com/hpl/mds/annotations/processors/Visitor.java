/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processors;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.function.BiPredicate;

import com.github.javaparser.ast.body.BodyDeclaration;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.ConstructorDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.FieldAccessExpr;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.ObjectCreationExpr;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.ReferenceType;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import com.hpl.mds.ManagedRecord;
import com.hpl.mds.RecordType;
import com.hpl.mds.impl.ManagedRecordProxy;

/**
 * TODO add bindName verifies
 */
public class Visitor extends VoidVisitorAdapter<Object> {

    private static final String RECORD_TYPE = RecordType.class.getCanonicalName();
    private static final String DEFAULT_PARENT_IMPL = ManagedRecordProxy.class.getCanonicalName();
    private static final String DEFAULT_PARENT = ManagedRecord.class.getCanonicalName();

    // sections to verfy
    private static final String TYPE_PROTECTED = "Protected";
    private static final String TYPE_PRIVATE = "Private";
    private static final String NESTED_IMPL = "nested type Impl";
    private static final String NESTED_PRIVATE = "nested type Private";
    private static final String NESTED_PROTECTED = "nested type Protected";
    private static final String NESTED_CREATE = "nested type Create";
    private static final String NESTED_CREATOR = "nested type Creator";
    private static final String NESTED_STATICS = "nested type Statics";
    private static final String NESTED_TYPEDEF = "nested type TypeDef";
    private static final String NESTED_CREATOR_PROTECTED = "nested type creator AsProtected";
    private static final String NESTED_CREATOR_PRIVATE = "nested type creatro AsPrivate";
    private static final String NESTED_CREATOR_INSTANCE = "nested type Instance";
    private static final String NESTED_STATIC_METHOD = "nested type StaticMethod";
    private static final String NESTED_SMDEFS = "nested type SMDefs";
    private static final String NESTED_SMDEFS_PROTECTED = "nested type SMDefs AsProtected";
    private static final String NESTED_SMDEFS_PRIVATE = "nested type SMDefs AsPrivate";
    private static final String METHOD_TYPE = "method type";
    private static final String FIELD_TYPE = "field TYPE";
    private static final String FIELD_CREATED = "field created";

    private final ParserConfig config;
    private final Collection<String> notVerified;

    public Visitor(ParserConfig config) {
        this.config = config;
        notVerified = new ArrayList<>();
        notVerified.add(NESTED_TYPEDEF);
        notVerified.add(NESTED_STATICS);
        notVerified.add(NESTED_CREATE);
        notVerified.add(NESTED_CREATOR);
        notVerified.add(NESTED_CREATOR_PROTECTED);
        notVerified.add(NESTED_CREATOR_PRIVATE);
        notVerified.add(NESTED_CREATOR_INSTANCE);
        notVerified.add(NESTED_PROTECTED);
        notVerified.add(NESTED_PRIVATE);
        notVerified.add(NESTED_IMPL);
        notVerified.add(NESTED_STATIC_METHOD);
        notVerified.add(NESTED_SMDEFS);
        notVerified.add(NESTED_SMDEFS_PROTECTED);
        notVerified.add(NESTED_SMDEFS_PRIVATE);
        notVerified.add(FIELD_CREATED);
        notVerified.add(FIELD_TYPE);
        notVerified.add(METHOD_TYPE);
    }

    @Override
    public void visit(ClassOrInterfaceDeclaration declaration, Object arg) {
        verifyExtends(declaration, getParent(), config.getSuperInterfaces());
        for (BodyDeclaration member : declaration.getMembers()) {
            if (member instanceof ClassOrInterfaceDeclaration) {
                verifyNestedType((ClassOrInterfaceDeclaration) member, declaration.getName());
            } else if (member instanceof FieldDeclaration) {
                verifyField((FieldDeclaration) member);
            } else if (member instanceof MethodDeclaration) {
                verifyMethod((MethodDeclaration) member);
            }
        }
        verityFieldsDeclaration(declaration, config.getPublicFields(), "Public");
        verifyNotStaticMethods(declaration, config.getPublicMethods(), "public methods");
        verifyStaticMethods(declaration, config.getPublicStaticMethods(), "public static methods");
    }

    private String getParent() {
        String parent = config.getParent();
        if (parent != null) {
            return parent;
        } else {
            return DEFAULT_PARENT;
        }
    }

    private void verifyNotStaticMethods(ClassOrInterfaceDeclaration type, List<MethodDesc> methods, String section) {
        verifyMembers(type, methods, this::verifyNotStaticMethod, MethodDeclaration.class, section);
    }

    private boolean verifyNotStaticMethod(MethodDeclaration method, MethodDesc expectedMethod) {
        if (Modifier.isStatic(method.getModifiers())) {
            return false;
        }
        verifyMethod(method, expectedMethod);
        return true;
    }

    private void verifyMethod(MethodDeclaration method, MethodDesc methodDesc) {
        assertEquals(methodDesc.getName(), method.getName());
        assertEquals("invalid return type for " + method.getName(), methodDesc.getReturnType(),
                method.getType().toString());
        List<Parameter> parameters = method.getParameters();
        List<String> args = methodDesc.getArgs();
        assertEquals("invalid number of arguments in method: " + method.getName(), args.size(), parameters.size());
        for (int i = 0; i < args.size(); i++) {
            assertEquals("different arguments in method:" + methodDesc.getName(), args.get(i),
                    parameters.get(i).toString());
        }
    }

    private void verifyMethod(MethodDeclaration method) {
        String name = method.getName();
        if ("type".equals(name)) {
            verifyMethodType(method);
        }
    }

    private void verifyMethodType(MethodDeclaration method) {
        assertTrue(Modifier.isPublic(method.getModifiers()));
        assertTrue(method.getParameters().isEmpty());
        assertTrue((method.getType().toString().contains(RECORD_TYPE)));
        notVerified.remove(METHOD_TYPE);
    }

    private void verifyNestedType(ClassOrInterfaceDeclaration nestedType, String mainType) {
        switch (nestedType.getName()) {
        case "TypeDef":
            verifyTypeDef(nestedType, mainType);
            break;
        case "SMDefs":
            verifySMDefs(nestedType, mainType);
            break;
        case "StaticMethod":
            verifyNestedStaticMethodType(nestedType);
            break;
        case "Statics":
            verifyStatics(nestedType);
            break;
        case "Creator":
            verifyCreator(nestedType);
            break;
        case "Create":
            verifyCreate(nestedType);
            break;
        case TYPE_PROTECTED:
            verifyProtected(nestedType, mainType);
            break;
        case TYPE_PRIVATE:
            verifyPrivate(nestedType);
            break;
        case "Impl":
            verifyImpl(nestedType);
        default:
            break;
        }
    }

    private void verifyNestedStaticMethodType(ClassOrInterfaceDeclaration nestedType) {
        List<BodyDeclaration> members = nestedType.getMembers();
        assertFalse(members.isEmpty());
        assertTrue(members.get(0) instanceof FieldDeclaration);
        FieldDeclaration field = (FieldDeclaration) members.get(0);
        VariableDeclarator variable = field.getVariables().get(0);
        assertEquals("instance", variable.getId().toString());
        Expression init = variable.getInit();
        assertTrue(init instanceof ObjectCreationExpr);
        ObjectCreationExpr creation = (ObjectCreationExpr) init;
        assertEquals("StaticMethod", creation.getType().toString());
        verifyImplements(nestedType, "SMDefs.AsPrivate");
        verifyParent(nestedType, ".StaticMethod");
        notVerified.remove(NESTED_STATIC_METHOD);
    }

    private void verifySMDefs(ClassOrInterfaceDeclaration smdefs, String mainType) {
        verifyParent(smdefs, ".SMDefs");
        verifyNotStaticMethods(smdefs, config.getPublicStaticMethods(), "public static methods");
        for (BodyDeclaration member : smdefs.getMembers()) {
            if (member instanceof ClassOrInterfaceDeclaration) {
                ClassOrInterfaceDeclaration nestedType = (ClassOrInterfaceDeclaration) member;
                switch (nestedType.getName()) {
                case "AsProtected":
                    verifyParent(nestedType, ".SMDefs.AsProtected");
                    verifyNotStaticMethods(nestedType, config.getProtectedStaticMethods(), "protected static methods");
                    notVerified.remove(NESTED_SMDEFS_PROTECTED);
                    break;
                case "AsPrivate":
                    verifyNotStaticMethods(nestedType, config.getPrivateStaticMethods(), "private static methods");
                    notVerified.remove(NESTED_SMDEFS_PRIVATE);
                    break;
                default:
                    break;
                }
            }
        }
        notVerified.remove(NESTED_SMDEFS);
    }

    private void verifyStaticMethods(ClassOrInterfaceDeclaration type, List<MethodDesc> methods, String section) {
        verifyMembers(type, methods, this::verifyStaticMethod, MethodDeclaration.class, section);
    }

    private boolean verifyStaticMethod(MethodDeclaration method, MethodDesc methodDesc) {
        if (Modifier.isStatic(method.getModifiers())) {
            verifyMethod(method, methodDesc);
            return true;
        }
        return false;
    }

    private void verifyParent(ClassOrInterfaceDeclaration type, String suffix) {
        String parent = config.getParent();
        if (parent != null) {
            verifyExtends(type, parent + suffix);
        }
    }

    private void verifyCreator(ClassOrInterfaceDeclaration creator) {
        verifyNotStaticMethods(creator, config.getPublicCreationMethods(), "public creation method");
        for (BodyDeclaration member : creator.getMembers()) {
            if (member instanceof ClassOrInterfaceDeclaration) {
                ClassOrInterfaceDeclaration nestedType = (ClassOrInterfaceDeclaration) member;
                switch (nestedType.getName()) {
                case "AsProtected":
                    verifyNotStaticMethods(nestedType, config.getProtectedCreationMethods(),
                            "protected creation method");
                    notVerified.remove(NESTED_CREATOR_PROTECTED);
                    break;
                case "AsPrivate":
                    verifyNotStaticMethods(nestedType, config.getPrivateCreationMethods(), "private creation method");
                    notVerified.remove(NESTED_CREATOR_PRIVATE);
                    break;
                case "Instance":
                    verifyNotStaticMethods(nestedType, config.getCreationMethodsImpl(), "Impl creation method");
                    notVerified.remove(NESTED_CREATOR_INSTANCE);
                    break;
                default:
                    break;
                }
            }
        }
        notVerified.remove(NESTED_CREATOR);
    }

    private void verifyImpl(ClassOrInterfaceDeclaration impl) {
        assertFalse(impl.isInterface());
        verifyImplements(impl, TYPE_PRIVATE);
        verifyParent(impl, ".Impl");
        verifyExtends(impl, getParentImpl());
        verifyAmbiguousMethods(impl, config.getAmbiguousMethods());
        verifyConstructors(impl, config.getConstructors());
        if (config.isAbstractRecord()) {
            assertTrue(Modifier.isAbstract(impl.getModifiers()));
        }
        notVerified.remove(NESTED_IMPL);
    }

    private void verifyAmbiguousMethods(ClassOrInterfaceDeclaration impl, List<MethodDesc> ambiguousMethods) {
        verifyMembers(impl, ambiguousMethods, this::verifyNotStaticMethod, MethodDeclaration.class,
                "ambiguous methods");
    }

    private void verifyImplements(ClassOrInterfaceDeclaration nestedType, String interface1) {
        List<ClassOrInterfaceType> implements1 = nestedType.getImplements();
        assertFalse(implements1.isEmpty());
        boolean found = false;
        for (ClassOrInterfaceType classOrInterfaceType : implements1) {
            if (interface1.equals(classOrInterfaceType.toString())) {
                found = true;
            }
        }
        assertTrue("parent not found: " + interface1 + " in " + implements1, found);
    }

    private String getParentImpl() {
        String parent = config.getParent();
        if (parent != null) {
            return parent + ".Impl";
        } else {
            return DEFAULT_PARENT_IMPL;
        }
    }

    /**
     * Verify the members of the given type
     * 
     * @param type
     *            the declaration to be inspected
     * @param expectedMembers
     *            the expected members
     * @param verify
     *            method to verify each member
     * @param class1
     *            members type
     * @param section
     *            the section to which this members belong, used for logging
     */
    private <T, U> void verifyMembers(ClassOrInterfaceDeclaration type, List<U> expectedMembers,
            BiPredicate<T, U> verify, Class<T> class1, String section) {
        if (expectedMembers.size() > 0) {
            List<BodyDeclaration> members = type.getMembers();
            int verifiedMembers = 0;
            for (BodyDeclaration member : members) {
                if (class1.isInstance(member)) {
                    T toVerify = class1.cast(member);
                    if (verify.test(toVerify, expectedMembers.get(verifiedMembers))) {
                        verifiedMembers++;
                    }
                    if (verifiedMembers == expectedMembers.size()) {
                        break;
                    }
                }
            }
            assertEquals("invalid number of members in " + section, expectedMembers.size(), verifiedMembers);
        }
    }

    private void verifyConstructors(ClassOrInterfaceDeclaration declaration, List<MethodDesc> constructors) {
        verifyMembers(declaration, constructors, this::verifyConstructor, ConstructorDeclaration.class, "constructors");
    }

    private boolean verifyConstructor(ConstructorDeclaration constructor, MethodDesc methodDesc) {
        assertEquals(methodDesc.getName(), constructor.getName());
        List<Parameter> parameters = constructor.getParameters();
        List<String> args = methodDesc.getArgs();
        assertEquals(args.size(), parameters.size());
        for (int i = 0; i < args.size(); i++) {
            assertEquals(args.get(i), parameters.get(i).toString());
        }
        return true;
    }

    private void verifyPrivate(ClassOrInterfaceDeclaration nestedType) {
        assertTrue(nestedType.isInterface());
        verifyExtends(nestedType, TYPE_PROTECTED);
        verityFieldsDeclaration(nestedType, config.getPrivateFields(), "Private");
        verifyNotStaticMethods(nestedType, config.getPrivateMethods(), "private methods");
        notVerified.remove(NESTED_PRIVATE);
    }

    private void verifyProtected(ClassOrInterfaceDeclaration nestedType, String mainType) {
        assertTrue(nestedType.isInterface());
        verifyExtends(nestedType, mainType);
        verifyParent(nestedType, ".Protected");
        verityFieldsDeclaration(nestedType, config.getProtectedFields(), "Protected");
        verifyNotStaticMethods(nestedType, config.getProtectedMethods(), "protected methods");
        notVerified.remove(NESTED_PROTECTED);
    }

    private void verityFieldsDeclaration(ClassOrInterfaceDeclaration nestedType, List<FieldDesc> fields,
            String parent) {
        verifyMembers(nestedType, fields, this::verifyFieldDeclaration, FieldDeclaration.class, "fields in " + parent);
    }

    private boolean verifyFieldDeclaration(FieldDeclaration member, FieldDesc fieldInfo) {
        FieldDeclaration field = (FieldDeclaration) member;
        verifyType(field.getType(), fieldInfo.getType(), fieldInfo.getTypeParams());
        assertFalse(field.getVariables().isEmpty());
        VariableDeclarator variable = field.getVariables().get(0);
        String name = fieldInfo.getName();
        assertEquals(name, variable.getId().toString());
        verifyFieldAccessExpression(variable.getInit(), config.getClassName() + ".TypeDef", name);
        return true;
    }

    private void verifyCreate(ClassOrInterfaceDeclaration nestedType) {
        assertFalse(nestedType.isInterface());
        notVerified.remove(NESTED_CREATE);
    }

    private void verifyStatics(ClassOrInterfaceDeclaration nestedType) {
        assertFalse(nestedType.isInterface());
        verityFieldsDeclaration(nestedType, config.getFields(), "Statics");
        notVerified.remove(NESTED_STATICS);
    }

    private void verifyTypeDef(ClassOrInterfaceDeclaration nestedType, String mainType) {
        assertTrue(nestedType.isInterface());
        List<BodyDeclaration> members = nestedType.getMembers();
        assertFalse(members.isEmpty());
        assertTrue(members.get(0) instanceof FieldDeclaration);
        // verify record type declaration
        List<String> expectedArgs = new ArrayList<>(3);
        expectedArgs.add("\"" + config.getMdsType() + "\"");
        expectedArgs.add("Impl.class");
        if (config.getParent() != null) {
            expectedArgs.add(config.getParent() + ".TypeDef.TYPE");
        }

        verifyFieldDef(members.get(0), RECORD_TYPE, Arrays.asList(mainType), "TYPE", RECORD_TYPE, "declare",
                expectedArgs);
        verifyFieldsDef(members);
        BodyDeclaration lastMember = members.get(members.size() - 1);
        assertTrue(lastMember instanceof FieldDeclaration);
        verifyFieldCreated((FieldDeclaration) lastMember);
        notVerified.remove(NESTED_TYPEDEF);
    }

    private void verifyFieldsDef(List<BodyDeclaration> members) {
        List<FieldDesc> fields = config.getFields();
        if (!fields.isEmpty()) {
            assertEquals(fields.size(), members.size() - 2);
            // verify fields declarationl
            for (int index = 0; index < fields.size(); index++) {
                FieldDesc fieldInfo = fields.get(index);
                verifyFieldDef(members.get(index + 1), fieldInfo.getType(), fieldInfo.getTypeParams(),
                        fieldInfo.getName(), "TYPE", fieldInfo.getCreationMethod(), fieldInfo.getMethodArgs());
            }
        }
    }

    private void verifyFieldDef(BodyDeclaration bodyDeclaration, String fieldType, List<String> params,
            String fieldName, String scope, String method, List<String> expectedArgs) {
        assertTrue(bodyDeclaration instanceof FieldDeclaration);
        FieldDeclaration fieldDeclaration = (FieldDeclaration) bodyDeclaration;
        verifyType(fieldDeclaration.getType(), fieldType, params);
        assertFalse(fieldDeclaration.getVariables().isEmpty());
        VariableDeclarator variable = fieldDeclaration.getVariables().get(0);
        assertEquals(fieldName, variable.getId().toString());
        verifyMethodCall(variable.getInit(), scope, method, expectedArgs);
    }

    private void verifyType(Type fieldDecType, String typeName, List<String> params) {
        assertTrue(fieldDecType instanceof ReferenceType);
        ReferenceType referenceType = (ReferenceType) fieldDecType;
        assertTrue(referenceType.getType() instanceof ClassOrInterfaceType);
        ClassOrInterfaceType classOrInterfaceType = (ClassOrInterfaceType) referenceType.getType();
        assertTrue("invalid type: " + classOrInterfaceType.toString() + ", should be of type: " + typeName,
                classOrInterfaceType.toString().startsWith(typeName));
        List<Type> typeArgs = classOrInterfaceType.getTypeArgs();
        assertEquals(typeArgs.size(), params.size());
        for (int i = 0; i < typeArgs.size(); i++) {
            assertEquals(params.get(i), typeArgs.get(i).toString());
        }
    }

    private void verifyMethodCall(Expression expression, String scope, String method, List<String> expectedArgs) {
        assertTrue(expression instanceof MethodCallExpr);
        MethodCallExpr methodCallExpr = (MethodCallExpr) expression;
        assertEquals(scope, methodCallExpr.getScope().toString());
        assertEquals(method, methodCallExpr.getName());
        List<Expression> args = methodCallExpr.getArgs();
        assertEquals(expectedArgs.size(), args.size());
        for (int i = 0; i < expectedArgs.size(); i++) {
            assertEquals(expectedArgs.get(i), args.get(i).toString());
        }
    }

    private void verifyField(FieldDeclaration field) {
        if (Modifier.isStatic(field.getModifiers()) && field.getType().toString().contains(RECORD_TYPE)) {
            VariableDeclarator variable = field.getVariables().get(0);
            assertEquals("TYPE", variable.getId().toString());
            Expression expression = variable.getInit();
            verifyFieldAccessExpression(expression, "TypeDef", "TYPE");
            notVerified.remove(FIELD_TYPE);
        }
    }

    private void verifyFieldAccessExpression(Expression expression, String scope, String fieldName) {
        assertTrue(expression instanceof FieldAccessExpr);
        FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) expression;
        assertEquals(scope, fieldAccessExpr.getScope().toString());
        assertEquals(fieldName, fieldAccessExpr.getField());
    }

    private void verifyFieldCreated(FieldDeclaration field) {
        VariableDeclarator variableDeclarator = field.getVariables().get(0);
        assertEquals("created", variableDeclarator.getId().toString());
        assertEquals("TypeDef.TYPE.ensureCreated()", variableDeclarator.getInit().toString());
        notVerified.remove(FIELD_CREATED);
    }

    public void verify() {
        if (!notVerified.isEmpty()) {
            throw new IllegalStateException("Generated code does not contain these members: " + notVerified);
        }
    }

    private void verifyExtends(ClassOrInterfaceDeclaration type, String parentType) {
        verifyExtends(type, parentType, Collections.emptyList());
    }
    
    private void verifyExtends(ClassOrInterfaceDeclaration type, String parentType, List<String> superTypes) {
        List<ClassOrInterfaceType> extends1 = type.getExtends();
        assertFalse(extends1.isEmpty());
        assertTrue("parent not found: " + parentType + " in " + extends1, findClassOrInterface(parentType, extends1));
        for (String superInterface : superTypes) {
            assertTrue("interface not found: " + superInterface + " in " + extends1,
                    findClassOrInterface(superInterface, extends1));
        }
    }

    private boolean findClassOrInterface(String parentType, List<ClassOrInterfaceType> extends1) {
        for (ClassOrInterfaceType classOrInterfaceType : extends1) {
            if (parentType.equals(classOrInterfaceType.toString())) {
                return true;
            }
        }
        return false;
    }

}
