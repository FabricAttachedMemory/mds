/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processors;

import static org.junit.Assert.assertTrue;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import org.junit.Before;
import org.junit.Test;

import com.github.javaparser.ParseException;

public class AnnotationProcessorWarningTest {

    private static final String FIELD_INT = "com.hpl.mds.prim.field.IntField";

    private static final String PKG = "com.hpl.mds.test.warning.";

    private static final String PATH = "com/hpl/mds/test/warning/";

    private static final JCompiler COMPILER = JCompiler.getInstance();

    private ParserConfig config;

    @Before
    public void beforeTest() {
        config = new ParserConfig();
    }

    @Test
    public void shouldLogErrorWhenSchemaExtendsNonSchemaType() throws Exception {
        COMPILER.compileSchema(PATH + "InheritanceNonRecordSchema.java");
        compileSchema("InheritanceExtendsNonRecord", "non-record-schema type: " + PKG + "InheritanceNonRecordSchema");
    }

    @Test
    public void shouldWarmingWhenInvalidMethodWithPrivateProtectedRecord() {
        String className = "InstanceMethodRecordParam";
        COMPILER.compileSchema(PATH + "InvalidVisibility" + "Schema.java");
        COMPILER.compileSchema(PATH + className + "Schema.java");
        compileSchema(className, "non public record parameter");
    }

    @Test
    public void shouldWarmingWhenInvalidVisivilityAttributesForField() {
        compileSchema("InvalidVisibility", "Ignoring annotation", "Visibility value already set: GETTER");
    }

    @Test
    public void shouldWarmingOnIllegalVisibilityLevels() throws Exception {
        String className = "WarningsVisibility";

        addProtected(addField(FIELD_INT, className, "duplicatedField", "intField", "duplicated"));
        addProtected(addField(FIELD_INT, className, "noAllField", "intField", "noAll"));
        addProtected(addField(FIELD_INT, className, "noDefaultField", "intField", "noDefault"));
        addProtected(addField(FIELD_INT, className, "noFieldField", "intField", "noField"));
        addProtected(addField(FIELD_INT, className, "noFieldAndAccessorsField", "intField", "noFieldAndAccessors"));

        ByteArrayOutputStream err = new ByteArrayOutputStream();
        testValidSchema(className, PKG + className, err);
        err.writeTo(System.err);
        String error = err.toString();
        assertTrue(error.contains("Visibility value already set"));
        String errorMsg = "illegal visibility value:";
        int indexOfVisibilityError = error.indexOf(errorMsg);
        for (int i = 0; i < 4; i++) {
            assertTrue(indexOfVisibilityError > 0);
            indexOfVisibilityError = error.indexOf(errorMsg, indexOfVisibilityError);
        }
    }

    private FieldDesc addField(String type, String typeParam, String name, String createionMethod, String mdsType) {
        FieldDesc fieldInfo = new FieldDesc(type, typeParam, name, createionMethod, "\"" + mdsType + "\"");
        config.addField(fieldInfo);
        return fieldInfo;
    }

    private void addProtected(FieldDesc addField) {
        config.addProtected(addField);
    }

    private void testValidSchema(String className, String mdsType, OutputStream err)
            throws ClassNotFoundException, Exception, ParseException, IOException {
        config.setMdsType(mdsType);
        config.setClassName(className);
        COMPILER.compileSchema(err, PATH + className + "Schema.java");
        String javaSrcFile = PATH + className + ".java";
        COMPILER.compileLoadRecord(javaSrcFile);
        COMPILER.parse(javaSrcFile, config);
    }

    private void compileSchema(String javaSrcFile, String... errorMsgs) {
        ByteArrayOutputStream err = new ByteArrayOutputStream();
        COMPILER.compileSchema(err, PATH + javaSrcFile + "Schema.java");
        String errLog = err.toString();
        System.err.print(errLog);
        int lastIndex = 0;
        for (String errorMsg : errorMsgs) {
            lastIndex = errLog.indexOf(errorMsg, lastIndex) + 1;
            assertTrue(lastIndex > 1);
        }
    }
}
