/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processors;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class ParserConfig {

    private boolean abstractRecord = false;
    private String mdsType;
    private List<FieldDesc> fields = new ArrayList<>();
    private List<FieldDesc> protectedFields = new ArrayList<>();
    private List<FieldDesc> privateFields = new ArrayList<>();
    private List<FieldDesc> publicFields = new ArrayList<>();
    private List<MethodDesc> protectedMethods = new ArrayList<>();
    private List<MethodDesc> privateMethods = new ArrayList<>();
    private List<MethodDesc> publicMethods = new ArrayList<>();
    private List<MethodDesc> constructors = new ArrayList<>();
    private List<MethodDesc> publicCreationMethods = new ArrayList<>();
    private List<MethodDesc> creationMethodsImpl = new ArrayList<>();
    private List<MethodDesc> protectedCreationMethods = new ArrayList<>();
    private List<MethodDesc> privateCreationMethods = new ArrayList<>();
    private List<MethodDesc> publicStaticMethods = new ArrayList<>();
    private List<MethodDesc> protectedStaticMethods = new ArrayList<>();
    private List<MethodDesc> privateStaticMethods = new ArrayList<>();
    private List<MethodDesc> ambiguousMethods = new ArrayList<>();
    private String parent;
    private String className;
    private List<String> superInterfaces = Collections.emptyList();

    public void setParent(String parent) {
        this.parent = parent;
    }

    public String getParent() {
        return parent;
    }

    public String getMdsType() {
        return mdsType;
    }

    public void setMdsType(String mdsType) {
        this.mdsType = mdsType;
    }

    public List<FieldDesc> getFields() {
        return fields;
    }

    public List<FieldDesc> getProtectedFields() {
        return protectedFields;
    }

    public List<FieldDesc> getPrivateFields() {
        return privateFields;
    }

    public List<FieldDesc> getPublicFields() {
        return publicFields;
    }

    public List<MethodDesc> getProtectedMethods() {
        return protectedMethods;
    }

    public List<MethodDesc> getPrivateMethods() {
        return privateMethods;
    }

    public List<MethodDesc> getPublicMethods() {
        return publicMethods;
    }

    public List<MethodDesc> getConstructors() {
        return constructors;
    }

    public void addConstructor(MethodDesc methodDesc) {
        constructors.add(methodDesc);
    }

    public void addProtected(MethodDesc methodDesc) {
        protectedMethods.add(methodDesc);
    }

    public void addPublic(MethodDesc methodDesc) {
        publicMethods.add(methodDesc);
    }

    public void addPrivate(MethodDesc methodDesc) {
        privateMethods.add(methodDesc);
    }

    public void addField(FieldDesc fieldInfo) {
        fields.add(fieldInfo);
    }

    public void addProtected(FieldDesc fieldInfo) {
        protectedFields.add(fieldInfo);
    }

    public void addPublic(FieldDesc fieldInfo) {
        publicFields.add(fieldInfo);
    }

    public void addPrivate(FieldDesc fieldInfo) {
        privateFields.add(fieldInfo);
    }

    public void addPublicCreationMethod(MethodDesc methodDesc) {
        publicCreationMethods.add(methodDesc);
    }

    public List<MethodDesc> getPublicCreationMethods() {
        return publicCreationMethods;
    }

    public void addCreationMethodImpl(MethodDesc methodDesc) {
        creationMethodsImpl.add(methodDesc);
    }

    public List<MethodDesc> getCreationMethodsImpl() {
        return creationMethodsImpl;
    }

    public void addProtectedCreationMethod(MethodDesc methodDesc) {
        protectedCreationMethods.add(methodDesc);
    }

    public List<MethodDesc> getProtectedCreationMethods() {
        return protectedCreationMethods;
    }

    public void addPrivateCreationMethod(MethodDesc methodDesc) {
        privateCreationMethods.add(methodDesc);
    }

    public List<MethodDesc> getPrivateCreationMethods() {
        return privateCreationMethods;
    }

    public void setAbstractRecord(boolean abstractRecord) {
        this.abstractRecord = abstractRecord;
    }

    public boolean isAbstractRecord() {
        return abstractRecord;
    }

    public void addStaticPublic(MethodDesc methodDesc) {
        publicStaticMethods.add(methodDesc);
    }

    public List<MethodDesc> getPublicStaticMethods() {
        return publicStaticMethods;
    }

    public void addStaticProtected(MethodDesc methodDesc) {
        protectedStaticMethods.add(methodDesc);
    }

    public List<MethodDesc> getProtectedStaticMethods() {
        return protectedStaticMethods;
    }

    public void addStaticPrivate(MethodDesc methodDesc) {
        privateStaticMethods.add(methodDesc);
    }

    public List<MethodDesc> getPrivateStaticMethods() {
        return privateStaticMethods;
    }

    public void setClassName(String className) {
        this.className = className;
    }

    public String getClassName() {
        return className;
    }

    public void addAmbiguousMethod(MethodDesc ambiguousMethod) {
        ambiguousMethods.add(ambiguousMethod);
    }

    public List<MethodDesc> getAmbiguousMethods() {
        return ambiguousMethods;
    }

    public void setSuperInterfaces(String... superInterfaces) {
        this.superInterfaces = Arrays.asList(superInterfaces);
    }
    
    public List<String> getSuperInterfaces() {
        return superInterfaces;
    }
}