/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processor.generator;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroup;

import com.hpl.mds.annotations.processor.RecordInfo.DataType;
import com.hpl.mds.annotations.processor.RecordInfo.FieldInfo;
import com.hpl.mds.annotations.processor.RecordInfo.VarInfo;
import com.hpl.mds.annotations.processor.RecordInfo.Visibility;
import com.hpl.mds.annotations.processor.generator.TypeProp.Properties;

/**
 * Generates all code related to fields in managed records including getters and
 * setters
 *
 * @author Abraham Alcantara
 */
public class FieldRenderer {

    private static final String TEMPLATE_FIELD_MEMBER = "fieldMember";
    private static final String TEMPLATE_FIELD_DEF = "fieldDef";
    private static final String TYPE_MEMBER = ".TypeDef.TYPE";

    private static final String TEMPLATE_GETTER_IMPL = "getterImpl";
    private static final String TEMPLATE_GETTER_DECLARATION = "getterDeclaration";
    private static final String TEMPLATE_MODIFIER_IMPL = "modifierImpl";
    private static final String TEMPLATE_MODIFIER_DECLARATION = "modifierDeclaration";
    private static final String TEMPLATE_MODIFIER_DECLARATION_NO_ARGS = "modifierDeclarationNoArgs";
    private static final String TEMPLATE_MODIFIER_IMPL_NO_ARGS = "modifierImplNoArgs";

    /**
     * Reference to string template group for rendering
     */
    private final STGroup stGroup;
    
    /**
     * 
     */
    private final ST recordTemplate;

    /**
     * field data types renderer
     */
    private final DataTypeRenderer dataTypeRenderer;

    /**
     * Simple name of the managed record being rendered
     */
    private final String recordSimpleName;
    
    /**
     * Information of the fields to render
     */
    private final List<FieldInfo> fields;

    /*
     * Methods and fields being rendered
     */
    private List<String> fieldsDef = Collections.emptyList();
    private List<String> declaredFields = Collections.emptyList();
    private List<String> privateFields = Collections.emptyList();
    private List<String> protectedFields = Collections.emptyList();
    private List<String> publicFields = Collections.emptyList();

    private List<String> privateMethods = Collections.emptyList();
    private List<String> protectedMethods = Collections.emptyList();
    private List<String> publicMethods = Collections.emptyList();

    /**
     * 
     * @param dataTypeRenderer
     *            render for data types
     * @param fields
     *            collection of fields to render
     * @param recordSimpleName
     *            simple name of managed record
     * @param stGroup
     *            string template group
     * @param recordTemplate
     *            string template for a managed record
     */
    public FieldRenderer(DataTypeRenderer dataTypeRenderer, List<FieldInfo> fields, String recordSimpleName,
            STGroup stGroup, ST recordTemplate) {
        this.dataTypeRenderer = dataTypeRenderer;
        this.fields = fields;
        this.recordSimpleName = recordSimpleName;
        this.stGroup = stGroup;
        this.recordTemplate = recordTemplate;
    }

    private void addFieldDef(String render) {
        if (fieldsDef.isEmpty()) {
            fieldsDef = new ArrayList<>();
        }
        fieldsDef.add(render);
    }

    private void addDeclaredFields(String render) {
        if (declaredFields.isEmpty()) {
            declaredFields = new ArrayList<>();
        }
        declaredFields.add(render);
    }

    private void addPrivateFields(String render) {
        if (privateFields.isEmpty()) {
            privateFields = new ArrayList<>();
        }
        privateFields.add(render);
    }

    private void addProtectedFields(String render) {
        if (protectedFields.isEmpty()) {
            protectedFields = new ArrayList<>();
        }
        protectedFields.add(render);
    }

    private void addPublicFields(String render) {
        if (publicFields.isEmpty()) {
            publicFields = new ArrayList<>();
        }
        publicFields.add(render);
    }

    private void addPrivateMethods(String render) {
        if (privateMethods.isEmpty()) {
            privateMethods = new ArrayList<>();
        }
        privateMethods.add(render);
    }

    private void addProtectedMethods(String render) {
        if (protectedMethods.isEmpty()) {
            protectedMethods = new ArrayList<>();
        }
        protectedMethods.add(render);
    }

    private void addPublicMethods(String render) {
        if (publicMethods.isEmpty()) {
            publicMethods = new ArrayList<>();
        }
        publicMethods.add(render);
    }

    /**
     * Renders all class members related to fields
     */
    public void render() {
        for (FieldInfo fieldInfo : fields) {
            VarInfo varInfo = fieldInfo.getVarInfo();
            DataType dataType = varInfo.getType();
            if (DataType.RECORD.equals(dataType)) {
                renderFieldRecord(fieldInfo, TypeProp.RECORD);
            } else if (DataType.ARRAY.equals(dataType)) {
                renderFieldArray(fieldInfo);
            } else {
                Properties properties = dataTypeRenderer.getProperties(dataType);
                if (properties.isCollection()) {
                    renderFieldCollection(fieldInfo, properties);
                } else {
                    renderFieldPrimitive(fieldInfo, properties);
                }
            }
        }

        addCodeToManagedRecord();
    }

    /**
     * fills the managed record template with the generated content
     */
    private void addCodeToManagedRecord() {
        recordTemplate.add("fields", fieldsDef);
        recordTemplate.add("declaredFields", declaredFields);
        recordTemplate.add("privateFields", privateFields);
        recordTemplate.add("protectedFields", protectedFields);
        recordTemplate.add("publicFields", publicFields);
    }

    public List<String> getPublicMethods() {
        return publicMethods;
    }

    public List<String> getProtectedMethods() {
        return protectedMethods;
    }

    public List<String> getPrivateMethods() {
        return privateMethods;
    }

    /**
     * Renders all field members generated for a managed record type field
     * 
     * @param fieldInfo
     *            information of the field
     * @param dataType
     *            the properties of the data type
     */
    private void renderFieldRecord(FieldInfo fieldInfo, Properties dataType) {
        VarInfo varInfo = fieldInfo.getVarInfo();
        String recordType = varInfo.getComplexType();
        List<String> typeParams = Arrays.asList(recordSimpleName, recordType);
        renderFieldRecordDef(fieldInfo, dataType, typeParams);
        renderFieldMembers(fieldInfo, dataType.getFieldType().getCanonicalName(), typeParams);
        renderFieldGetters(fieldInfo, recordType);
        renderFieldModifier(varInfo.getName(), fieldInfo.getSetterVisibility(), TypeProp.SET_FIELD_VALUE_METHOD,
                recordType, firstCharUpperCase(fieldInfo.getMdsName()));
    }

    /**
     * Generates field definition for record type field
     * 
     * @param fieldInfo
     *            information of the field
     * @param dataType
     *            data type properties
     * @param typeParams
     *            type parameter types
     */
    private void renderFieldRecordDef(FieldInfo fieldInfo, Properties dataType, List<String> typeParams) {
        VarInfo varInfo = fieldInfo.getVarInfo();
        ST template = stGroup.getInstanceOf(TEMPLATE_FIELD_DEF);
        assert template != null; // ensure template exists
        template.add("type", dataType.getFieldType().getCanonicalName());
        template.add("typeParams", typeParams);
        template.add("name", varInfo.getName());
        template.add("creationMethod", dataType.getCreateFieldMethod());
        template.add("methodArgs", new String[] { getMDSName(fieldInfo), varInfo.getComplexType() + TYPE_MEMBER });
        addFieldDef(template.render());
    }

    /**
     * @param fieldInfo
     *            information of the field
     * @return the MDS name of the field as a string
     */
    private String getMDSName(FieldInfo fieldInfo) {
        return "\"" + fieldInfo.getMdsName() + "\"";
    }

    /**
     * Renders field declaration at the correct visibility level
     * 
     * @param fieldInfo
     *            information of the field
     * @param type
     *            type of the field
     * @param typeParams
     *            type parameters of the field
     */
    private void renderFieldMembers(FieldInfo fieldInfo, String type, List<String> typeParams) {
        ST fieldMemberTemplate = stGroup.getInstanceOf(TEMPLATE_FIELD_MEMBER);
        assert fieldMemberTemplate != null; // ensure template exists
        fieldMemberTemplate.add("type", type);
        fieldMemberTemplate.add("typeParams", typeParams);
        fieldMemberTemplate.add("name", fieldInfo.getVarInfo().getName());
        fieldMemberTemplate.add("recordType", recordSimpleName);
        String render = fieldMemberTemplate.render();
        addDeclaredFields(render);
        switch (fieldInfo.getFieldVisibility()) {
        case PRIVATE:
            addPrivateFields(render);
            break;
        case PROTECTED:
            addProtectedFields(render);
            break;
        case PUBLIC:
            addPublicFields(render);
            break;
        default:
            throw new IllegalStateException("Unsupported visibility type");
        }
    }

    /**
     * Renders getter methods for the given managed data type
     * 
     * @param fieldInfo
     * @param managedType
     */
    private void renderFieldGetters(FieldInfo fieldInfo, String managedType) {
        String getterName = getGetterName(fieldInfo);
        renderFieldGetter(fieldInfo, managedType, TypeProp.GET_MNG_VALUE_METHOD, getterName);
        renderFieldGetter(fieldInfo, managedType, TypeProp.PEEK_MNG_VALUE_METHOD,
                getPeekGetterName(getterName));
    }

    private String getGetterName(FieldInfo fieldInfo) {
        String getterNameFormat = fieldInfo.getGetterNameFormat();
        String fieldName;
        if (getterNameFormat.startsWith("%s")) {
            fieldName = fieldInfo.getMdsName();
        } else {
            fieldName = firstCharUpperCase(fieldInfo.getMdsName());
        }
        return String.format(getterNameFormat, fieldName);
    }

    /**
     * Renders getter definition and declaration at different visibility levels
     * 
     * @param fieldInfo
     *            information of the field
     * @param type
     *            return data type of the getters
     * @param getValueMethod
     *            the name of the method to retrieve the field's value
     * @param getterName
     *            the name of the getter
     */
    private void renderFieldGetter(FieldInfo fieldInfo, String type, String getValueMethod, String getterName) {
        Visibility getterVisibility = fieldInfo.getGetterVisibility();
        if (!Visibility.NO.equals(getterVisibility)) {
            addPrivateMethods(
                    renderFieldGetterImpl(fieldInfo.getVarInfo().getName(), type, getValueMethod, getterName));
            switch (getterVisibility) {
            case PROTECTED:
                addProtectedMethods(getFieldGetterDeclaration(type, getterName));
                break;
            case PUBLIC:
                addPublicMethods(getFieldGetterDeclaration(type, getterName));
                break;
            case PRIVATE: // ignored, getters are already defined in
                          // private
                break;
            default:
                throw new IllegalStateException("Unsupported visibility type");
            }
        }
    }

    /**
     * @param fieldName
     *            name of the field
     * @param type
     *            field data type
     * @param getValueMethod
     *            method name to retrieve the field's value
     * @param getterName
     *            the name of the getter method
     * @return render of a getter implementation method of a field
     */
    private String renderFieldGetterImpl(String fieldName, String type, String getValueMethod, String getterName) {
        ST getterTemplate = stGroup.getInstanceOf(TEMPLATE_GETTER_IMPL);
        assert getterTemplate != null; // ensure template exists
        getterTemplate.add("type", type);
        getterTemplate.add("getterName", getterName);
        getterTemplate.add("fieldName", fieldName);
        getterTemplate.add("getValueMethod", getValueMethod);
        getterTemplate.add("recordName", recordSimpleName);
        return getterTemplate.render();
    }

    /**
     * @param type
     *            the return type of the getter
     * @param getterName
     *            the name of the getter
     * @return the render of a getter declaration
     */
    private String getFieldGetterDeclaration(String type, String getterName) {
        ST getterDecTemplate = stGroup.getInstanceOf(TEMPLATE_GETTER_DECLARATION);
        assert getterDecTemplate != null; // ensure template exists
        getterDecTemplate.add("type", type);
        getterDecTemplate.add("getterName", getterName);
        return getterDecTemplate.render();
    }

    private String getPeekGetterName(String getterName) {
      if (getterName.startsWith("get") || getterName.startsWith("has")) {
        return "peek"+getterName.substring(3);
      } else if (getterName.startsWith("is")) {
        return "peek"+getterName.substring(2);
      } else {
        return "peek" + firstCharUpperCase(getterName);
      }
    }

    /**
     * Generates modifier method implementation and declaration at the given
     * visibility level
     * 
     * @param fieldName
     *            field name
     * @param visibility
     *            visibility of the modifier method
     * @param methodName
     *            method name of the field and prefix of the generated modifier
     * @param typeParam
     *            parameter type
     * @param modifierSuffix
     *            suffix of method's name
     */
    private void renderFieldModifier(String fieldName, Visibility visibility, String methodName, String typeParam,
            String modifierSuffix) {
        if (!Visibility.NO.equals(visibility)) {
            String getAndMethodName = "getAnd"+firstCharUpperCase(methodName);
            String modifierName = methodName + modifierSuffix;
            String getAndModifierName = "getAnd"+firstCharUpperCase(modifierName);
            addPrivateMethods(renderModifierImpl(fieldName, methodName, typeParam, modifierName));
            addPrivateMethods(renderModifierImpl(fieldName, getAndMethodName, typeParam, getAndModifierName));
            switch (visibility) {
            case PUBLIC:
                addPublicMethods(getFieldNumericModifierDeclaration(typeParam, modifierName));
                addPublicMethods(getFieldNumericModifierDeclaration(typeParam, getAndModifierName));
                break;
            case PROTECTED:
                addProtectedMethods(getFieldNumericModifierDeclaration(typeParam, modifierName));
                addProtectedMethods(getFieldNumericModifierDeclaration(typeParam, getAndModifierName));
                break;
            case PRIVATE:// ignored, default implementation is at this
                         // level
                break;
            default:
                throw new IllegalStateException("Unsupported visibility type");
            }
        }
    }

    /**
     * Generates numeric field modifier declaration method
     * 
     * @param typeParam
     *            parameter type
     * @param modifierName
     *            the name of the method
     * @return the render of the method
     */
    private String getFieldNumericModifierDeclaration(String typeParam, String modifierName) {
        ST declarationTemplate = stGroup.getInstanceOf(TEMPLATE_MODIFIER_DECLARATION);
        assert declarationTemplate != null; // ensure template exists
        declarationTemplate.add("typeParam", typeParam);
        declarationTemplate.add("modifierName", modifierName);
        return declarationTemplate.render();
    }

    /**
     * Generates the modifier default implementation
     * 
     * @param fieldName
     *            field name
     * @param fieldMethod
     *            field method name to modify the value
     * @param typeParam
     *            parameter type
     * @param modifierName
     *            modifier method name
     * 
     * @return the result of the rendering
     */
    private String renderModifierImpl(String fieldName, String fieldMethod, String typeParam, String modifierName) {
        ST implTemplate = stGroup.getInstanceOf(TEMPLATE_MODIFIER_IMPL);
        assert implTemplate != null; // ensure template exists
        implTemplate.add("typeParam", typeParam);
        implTemplate.add("modifierName", modifierName);
        implTemplate.add("fieldName", fieldName);
        implTemplate.add("fieldMethod", fieldMethod);
        implTemplate.add("recordName", recordSimpleName);
        return implTemplate.render();
    }

    /**
     * @param string
     * @return the given string with its first character in upper case
     */
    private String firstCharUpperCase(String string) {
        return string.substring(0, 1).toUpperCase() + string.substring(1);
    }

    /**
     * Renders all class members for array fields
     * 
     * @param fieldInfo
     *            field information
     */
    private void renderFieldArray(FieldInfo fieldInfo) {
        DataType paramType = fieldInfo.getVarInfo().getTypeParams().get(0).getType();
        Properties dataTypeProps = dataTypeRenderer.getArrayProperties(paramType);
        if (dataTypeProps != null) {
            renderFieldArray(fieldInfo, dataTypeProps);
        } else {
            renderFieldCollection(fieldInfo, TypeProp.ARRAY_GENERIC);
        }
    }

    /**
     * Renders a no-generic field array
     * 
     * @param fieldInfo
     *            information of the field to render
     * @param dataTypeProps
     *            data type properties of the array
     */
    private void renderFieldArray(FieldInfo fieldInfo, Properties dataTypeProps) {
        String canonicalName = dataTypeProps.getFieldType().getCanonicalName();
        renderFieldPrimitiveDef(fieldInfo, canonicalName, dataTypeProps.getCreateFieldMethod());
        renderFieldMembers(fieldInfo, canonicalName, Arrays.asList(recordSimpleName));
        String managedType = dataTypeProps.getMngType().getCanonicalName();
        renderFieldGetters(fieldInfo, managedType);
        Visibility setterVisibility = fieldInfo.getSetterVisibility();
        renderFieldModifier(fieldInfo.getVarInfo().getName(), setterVisibility, TypeProp.SET_FIELD_VALUE_METHOD,
                managedType, firstCharUpperCase(fieldInfo.getMdsName()));
    }

    /**
     * Renders the definition of a primitive data type field
     * 
     * @param fieldInfo
     *            information of the field
     * @param type
     *            data type of the field
     * @param creationMethod
     *            method name to create the field
     */
    private void renderFieldPrimitiveDef(FieldInfo fieldInfo, String type, String creationMethod) {
        ST template = stGroup.getInstanceOf(TEMPLATE_FIELD_DEF);
        assert template != null; // ensure template exists
        template.add("type", type);
        template.add("typeParams", new String[] { recordSimpleName });
        template.add("name", fieldInfo.getVarInfo().getName());
        template.add("creationMethod", creationMethod);
        template.add("methodArgs", new String[] { getMDSName(fieldInfo) });
        addFieldDef(template.render());
    }

    /**
     * Renders the generated members of a collection type field
     * 
     * @param fieldInfo
     *            information of the field
     * @param dataType
     *            the properties of the data type
     */
    private void renderFieldCollection(FieldInfo fieldInfo, Properties dataType) {
        List<String> types = dataTypeRenderer.getTypes(fieldInfo.getVarInfo().getTypeParams());
        List<String> typeParams = getFieldCollectionTypeParams(recordSimpleName, types);
        renderFieldCollectionDef(fieldInfo, dataType, types, typeParams);
        renderFieldMembers(fieldInfo, dataType.getFieldType().getCanonicalName(), typeParams);
        String fullType = dataTypeRenderer.renderTypeWithParameters(dataType.getMngType().getCanonicalName(), types);
        renderFieldGetters(fieldInfo, fullType);
        renderFieldModifier(fieldInfo.getVarInfo().getName(), fieldInfo.getSetterVisibility(),
                TypeProp.SET_FIELD_VALUE_METHOD, fullType, firstCharUpperCase(fieldInfo.getMdsName()));
    }

    /**
     * @param recordName
     *            record simple name
     * @param types
     *            parameter data types of the collection
     * @return the parameter types of a collection type field
     */
    private List<String> getFieldCollectionTypeParams(String recordName, List<String> types) {
        List<String> typeParams = new ArrayList<>(types.size() + 1);
        typeParams.add(recordName);
        typeParams.addAll(types);
        return typeParams;
    }

    /**
     * Generates field definition for a collection type field
     * 
     * @param fieldInfo
     *            information of the field
     * @param dataType
     *            data type properties of the collection
     * @param argTypes
     *            data types arguments for the creation method
     * @param typeParams
     *            data type parameters of the collection
     */
    private void renderFieldCollectionDef(FieldInfo fieldInfo, Properties dataType, List<String> argTypes,
            List<String> typeParams) {
        ST template = stGroup.getInstanceOf(TEMPLATE_FIELD_DEF);
        assert template != null; // ensure template exists
        template.add("type", dataType.getFieldType().getCanonicalName());
        template.add("typeParams", typeParams);
        template.add("name", fieldInfo.getVarInfo().getName());
        template.add("creationMethod", dataType.getCreateFieldMethod());
        template.add("methodArgs", getFieldCollectionMethodArgs(fieldInfo, argTypes));
        addFieldDef(template.render());
    }

    /**
     * @param fieldInfo
     *            information of the field
     * @param types
     *            parameter data types of the collection
     * @return the arguments for the creation of a collection type field
     */
    private List<String> getFieldCollectionMethodArgs(FieldInfo fieldInfo, List<String> types) {
        List<String> methodArgs = new ArrayList<>(types.size() + 1);
        methodArgs.add(getMDSName(fieldInfo));
        for (String type : types) {
            methodArgs.add(type + TypeProp.TYPE_MNG_MEMBER);
        }
        return methodArgs;
    }

    /**
     * Renders all field members generated for a primitive type field
     * 
     * @param fieldInfo
     *            information of the field
     * @param dataType
     *            the properties of the data type
     */
    private void renderFieldPrimitive(FieldInfo fieldInfo, Properties dataType) {
        String canonicalName = dataType.getFieldType().getCanonicalName();
        renderFieldPrimitiveDef(fieldInfo, canonicalName, dataType.getCreateFieldMethod());
        renderFieldMembers(fieldInfo, canonicalName, Arrays.asList(recordSimpleName));
        renderFieldPrimitiveGetters(fieldInfo, dataType);
        String methodSuffix = firstCharUpperCase(fieldInfo.getMdsName());
        renderFieldPrimitiveSetters(fieldInfo, dataType, methodSuffix);
        if (dataType.isNumeric()) {
            renderFieldPrimitiveNumericModifiers(fieldInfo, dataType, methodSuffix);
        }
    }

    /**
     * Renders the getters for a primitive data type field
     * 
     * @param fieldInfo
     *            information of the field
     * @param dataType
     *            the properties of the data type
     */
    private void renderFieldPrimitiveGetters(FieldInfo fieldInfo, Properties dataType) {
        String fieldName = fieldInfo.getMdsName();
        String managedGetter;
        String primitiveGetter;
        if (fieldInfo.getVarInfo().isManaged()) {
            managedGetter = fieldName;
            primitiveGetter = "prim" + firstCharUpperCase(fieldName);
        } else {
            managedGetter = "managed" + firstCharUpperCase(fieldName);
            primitiveGetter = fieldName;
        }
        String getterNameFormat = fieldInfo.getGetterNameFormat();
        if (!getterNameFormat.startsWith("%s")) {
            managedGetter = firstCharUpperCase(managedGetter);
            primitiveGetter = firstCharUpperCase(primitiveGetter);
        }
        managedGetter = String.format(getterNameFormat, managedGetter);
        primitiveGetter = String.format(getterNameFormat, primitiveGetter);
        String managedType = dataType.getMngType().getCanonicalName();
        renderFieldGetter(fieldInfo, managedType, TypeProp.GET_MNG_VALUE_METHOD, managedGetter);
        renderFieldGetter(fieldInfo, managedType, TypeProp.PEEK_MNG_VALUE_METHOD,
                getPeekGetterName(managedGetter));
        renderFieldGetter(fieldInfo, dataType.getPrimitiveType(), dataType.getGetPrimitiveValueMethod(),
                primitiveGetter);
        renderFieldGetter(fieldInfo, dataType.getPrimitiveType(), dataType.getPeekPrimitiveValueMethod(),
                getPeekGetterName(primitiveGetter));
    }

    /**
     * Generates setters for primitive type fields
     * 
     * @param fieldInfo
     *            information of the field
     * @param dataType
     *            data type properties
     * @param modifierSuffix
     *            suffix of method's name
     */
    private void renderFieldPrimitiveSetters(FieldInfo fieldInfo, Properties dataType, String modifierSuffix) {
        String primitiveType = dataType.getPrimitiveType();
        String managedType = dataType.getMngType().getCanonicalName();
        String fieldName = fieldInfo.getVarInfo().getName();
        Visibility setterVisibility = fieldInfo.getSetterVisibility();
        renderFieldModifier(fieldName, setterVisibility, TypeProp.SET_FIELD_VALUE_METHOD, managedType, modifierSuffix);
        renderFieldModifier(fieldName, setterVisibility, TypeProp.SET_FIELD_VALUE_METHOD, primitiveType,
                modifierSuffix);
    }

    /**
     * generates all modifiers for numeric type fields: inc, dec, mult and div.
     * 
     * @param fieldInfo
     *            information of the field
     * @param dataType
     *            data type properties
     * @param modifierSuffix
     *            suffix of method's name
     */
    private void renderFieldPrimitiveNumericModifiers(FieldInfo fieldInfo, Properties dataType, String modifierSuffix) {
        String primitiveType = dataType.getPrimitiveType();
        String managedType = dataType.getMngType().getCanonicalName();
        String name = fieldInfo.getVarInfo().getName();
        renderFieldModifierNoArgs(name, fieldInfo.getIncVisibility(), "inc", primitiveType, modifierSuffix);
        renderFieldModifier(name, fieldInfo.getIncVisibility(), "inc", primitiveType, modifierSuffix);
        renderFieldModifier(name, fieldInfo.getIncVisibility(), "inc", managedType, modifierSuffix);
        renderFieldModifierNoArgs(name, fieldInfo.getDecVisibility(), "dec", primitiveType, modifierSuffix);
        renderFieldModifier(name, fieldInfo.getDecVisibility(), "dec", primitiveType, modifierSuffix);
        renderFieldModifier(name, fieldInfo.getDecVisibility(), "dec", managedType, modifierSuffix);
        renderFieldModifier(name, fieldInfo.getMulVisibility(), "mult", primitiveType, modifierSuffix);
        renderFieldModifier(name, fieldInfo.getMulVisibility(), "mult", managedType, modifierSuffix);
        renderFieldModifier(name, fieldInfo.getDivVisibility(), "div", primitiveType, modifierSuffix);
        renderFieldModifier(name, fieldInfo.getDivVisibility(), "div", managedType, modifierSuffix);
    }

    /**
     * Generates no arguments modifier method implementation and declaration at
     * the given visibility level
     * 
     * @param fieldName
     *            field name
     * @param visibility
     *            visibility of the modifier method
     * @param methodName
     *            method name of the field and prefix of the generated modifier
     * @param primitiveType
     *            parameter type for casting
     * @param modifierSuffix
     *            suffix of method's name
     */
    private void renderFieldModifierNoArgs(String fieldName, Visibility visibility, String methodName,
            String primitiveType, String modifierSuffix) {
        if (!Visibility.NO.equals(visibility)) {
            String modifierName = methodName + modifierSuffix;
            addPrivateMethods(renderModifierImplNoArgs(fieldName, methodName, modifierName, primitiveType));
            switch (visibility) {
            case PUBLIC:
                addPublicMethods(getFieldNumericModifierDeclarationNoArgs(modifierName, primitiveType));
                break;
            case PROTECTED:
                addProtectedMethods(getFieldNumericModifierDeclarationNoArgs(modifierName, primitiveType));
                break;
            case PRIVATE:// ignored, default implementation is at this
                         // level
                break;
            default:
                throw new IllegalStateException("Unsupported visibility type");
            }
        }
    }

    /**
     * Generates the modifier default implementation with no arguments
     * 
     * @param fieldName
     *            field name
     * @param fieldMethod
     *            field method name to modify the value
     * @param modifierName
     *            modifier method name
     * @param primitiveType
     *            type for casting constant
     * 
     * @return the result of the rendering
     */
    private String renderModifierImplNoArgs(String fieldName, String fieldMethod, String modifierName,
            String primitiveType) {
        ST implTemplate = stGroup.getInstanceOf(TEMPLATE_MODIFIER_IMPL_NO_ARGS);
        assert implTemplate != null; // ensure template exists
        implTemplate.add("modifierName", modifierName);
        implTemplate.add("fieldName", fieldName);
        implTemplate.add("fieldMethod", fieldMethod);
        implTemplate.add("numType", primitiveType);
        implTemplate.add("recordName", recordSimpleName);
        return implTemplate.render();
    }

    /**
     * Generates no argument numeric field modifier method declaration
     * 
     * @param modifierName
     *            the name of the method
     * @param numType
     *            data type of the return value
     * @return the render of the method
     */
    private String getFieldNumericModifierDeclarationNoArgs(String modifierName, String numType) {
        ST declarationTemplate = stGroup.getInstanceOf(TEMPLATE_MODIFIER_DECLARATION_NO_ARGS);
        assert declarationTemplate != null; // ensure template exists
        declarationTemplate.add("modifierName", modifierName);
        declarationTemplate.add("typeParam", numType);
        return declarationTemplate.render();
    }

}
