/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processor.generator;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.annotation.processing.Messager;
import javax.tools.Diagnostic.Kind;

import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroup;

import com.hpl.mds.annotations.processor.RecordInfo;
import com.hpl.mds.annotations.processor.RecordInfo.DataType;
import com.hpl.mds.annotations.processor.RecordInfo.MethodInfo;
import com.hpl.mds.annotations.processor.RecordInfo.VarInfo;
import com.hpl.mds.annotations.processor.RecordInfo.Visibility;
import com.hpl.mds.annotations.processor.generator.TypeProp.Properties;

/**
 * Generates all source code related to methods in managed records including
 * instance methods, static methods, constructors and creation methods
 * 
 * @author Abraham Alcantara
 */
public class MethodRenderer {

    /**
     * Renders a method at the required visibility level
     * 
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the call to the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param methodInfo
     *            information of the method to render
     * 
     * @author Abraham Alcantara
     */
    private interface Renderer {
        void render(String parameters, List<String> arguments, String[] renders, MethodInfo methodInfo);
    }

    private static final String VOID = "void";
    private static final String EMPTY = "";
    private static final char SIGNATURE_SEPARATOR = '#';
    private static final String PRIVATE = "Private";
    private static final String PROTECTED = "Protected";
    private static final String RETURN = "return ";

    private static final String ERROR_METHODS_SIGNATURE = "A method with the same signature has already been generated";

    private static final String TEMPLATE_METHOD_IMPL = "methodImplementation";
    private static final String TEMPLATE_METHOD_DECLARATION = "methodDeclaration";
    private static final String TEMPLATE_USER_CONSTRUCTOR = "userConstructor";
    private static final String TEMPLATE_DEFAULT_CONSTRUCTOR = "defaultConstructor";
    private static final String TEMPLATE_CREATION_METHOD_IMPL = "creationMethodImpl";
    private static final String TEMPLATE_CREATION_METHOD_DEC = "creationMethodDec";
    private static final String TEMPLATE_AMBIGUOUS_METHOD = "ambiguousMethod";
    private static final String TEMPLATE_STATIC_METHOD = "staticMethod";

    private static final int PRIM = 0;
    private static final int MNG = 1;
    private static final int METHOD_NAME = 0;
    private static final int RETURN_TYPE = 1;
    private static final int CAST_START = 2;
    private static final int CAST_END = 3;

    /**
     * To display localized messages to the user
     */
    private final Messager messager;

    /**
     * For data type rendering of arguments, parameters and return types
     */
    private final DataTypeRenderer dataTypeRenderer;

    /**
     * Reference to string template group for rendering
     */
    private final STGroup stGroup;

    /**
     * Reference to managed record template
     */
    private final ST recordTemplate;

    /**
     * Information of the record that is being rendered
     */
    private final RecordInfo recordInfo;

    /*
     * All rendered methods
     */
    private List<String> privateMethods = Collections.emptyList();
    private List<String> protectedMethods = Collections.emptyList();
    private List<String> publicMethods = Collections.emptyList();
    private List<String> userConstructors = Collections.emptyList();
    private List<String> creationMethodsImpl = Collections.emptyList();
    private List<String> publicCreationMethods = Collections.emptyList();
    private List<String> protectedCreationMethods = Collections.emptyList();
    private List<String> privateCreationMethods = Collections.emptyList();
    private List<String> publicStaticMethods = Collections.emptyList();
    private List<String> protectedStaticMethods = Collections.emptyList();
    private List<String> privateStaticMethods = Collections.emptyList();
    private List<String> ambiguousMethods = Collections.emptyList();

    /**
     * 
     * @param messager
     *            to display error messages to the user
     * @param dataTypeRenderer
     *            render for data types
     * @param recordInfo
     *            information of the managed record to render
     * @param stGroup
     *            string template group
     * @param recordTemplate
     *            string template for a managed record
     */
    public MethodRenderer(Messager messager, DataTypeRenderer dataTypeRenderer, RecordInfo recordInfo, STGroup stGroup,
            ST recordTemplate) {
        super();
        this.messager = messager;
        this.dataTypeRenderer = dataTypeRenderer;
        this.recordInfo = recordInfo;
        this.stGroup = stGroup;
        this.recordTemplate = recordTemplate;
    }

    private void addPrivateMethod(String render) {
        if (privateMethods.isEmpty()) {
            privateMethods = new ArrayList<>();
        }
        privateMethods.add(render);
    }

    private void addProtectedMethod(String render) {
        if (protectedMethods.isEmpty()) {
            protectedMethods = new ArrayList<>();
        }
        protectedMethods.add(render);
    }

    private void addPublicMethod(String render) {
        if (publicMethods.isEmpty()) {
            publicMethods = new ArrayList<>();
        }
        publicMethods.add(render);
    }

    private void addUserConstructor(String render) {
        if (userConstructors.isEmpty()) {
            userConstructors = new ArrayList<>();
        }
        userConstructors.add(render);
    }

    private void addCreationMethodsImpl(String render) {
        if (creationMethodsImpl.isEmpty()) {
            creationMethodsImpl = new ArrayList<>();
        }
        creationMethodsImpl.add(render);
    }

    private void addPublicCreationMethod(String render) {
        if (publicCreationMethods.isEmpty()) {
            publicCreationMethods = new ArrayList<>();
        }
        publicCreationMethods.add(render);
    }

    private void addProtectedCreationMethod(String render) {
        if (protectedCreationMethods.isEmpty()) {
            protectedCreationMethods = new ArrayList<>();
        }
        protectedCreationMethods.add(render);
    }

    private void addPrivateCreationMethod(String render) {
        if (privateCreationMethods.isEmpty()) {
            privateCreationMethods = new ArrayList<>();
        }
        privateCreationMethods.add(render);
    }

    private void addPpublicStaticMethod(String render) {
        if (publicStaticMethods.isEmpty()) {
            publicStaticMethods = new ArrayList<>();
        }
        publicStaticMethods.add(render);
    }

    private void addProtectedStaticMethod(String render) {
        if (protectedStaticMethods.isEmpty()) {
            protectedStaticMethods = new ArrayList<>();
        }
        protectedStaticMethods.add(render);
    }

    private void addPrivateStaticMethod(String render) {
        if (privateStaticMethods.isEmpty()) {
            privateStaticMethods = new ArrayList<>();
        }
        privateStaticMethods.add(render);
    }

    private void addAmbiguousMethod(String render) {
        if (ambiguousMethods.isEmpty()) {
            ambiguousMethods = new ArrayList<>();
        }
        ambiguousMethods.add(render);
    }

    public List<String> getPrivateMethods() {
        return privateMethods;
    }

    public List<String> getProtectedMethods() {
        return protectedMethods;
    }

    public List<String> getPublicMethods() {
        return publicMethods;
    }

    /**
     * Renders all instance methods, constructors and creation methods
     */
    public void render() {
        Set<String> signatures = new HashSet<>();
        List<MethodInfo> methods = recordInfo.getMethods();
        if (!methods.isEmpty()) {
            for (MethodInfo methodInfo : methods) {
                renderMethodMembers(methodInfo, signatures, this::renderInstanceMethodMembers, "this");
            }
        }
        List<MethodInfo> staticMethods = recordInfo.getStaticMethods();
        if (!staticMethods.isEmpty()) {
            String firstArgRender = recordInfo.getSimpleName() + ".StaticMethod.instance";
            for (MethodInfo methodInfo : staticMethods) {
                String firstArg = null;
                if (methodInfo.omitFirstParam()) {
                    firstArg = firstArgRender;
                }
                renderMethodMembers(methodInfo, signatures, this::renderStaticMethodMembers, firstArg);
            }
        }
        List<MethodInfo> constructors = recordInfo.getUserConstructor();
        if (!constructors.isEmpty()) {
            for (MethodInfo methodInfo : constructors) {
                renderConstructor(methodInfo, signatures);
            }
        }
        if (userConstructors.isEmpty()) {
            renderDefaultConstructor();
        }

        addContentToTemplate();
    }

    private void addContentToTemplate() {
        recordTemplate.add("userConstructors", userConstructors);
        recordTemplate.add("ambiguousMethods", ambiguousMethods);
        recordTemplate.add("creationMethodsImpl", creationMethodsImpl);
        recordTemplate.add("publicCreationMethods", publicCreationMethods);
        recordTemplate.add("protectedCreationMethods", protectedCreationMethods);
        recordTemplate.add("privateCreationMethods", privateCreationMethods);
        recordTemplate.add("publicStaticMethods", publicStaticMethods);
        recordTemplate.add("protectedStaticMethods", protectedStaticMethods);
        recordTemplate.add("privateStaticMethods", privateStaticMethods);
    }

    /**
     * Renders all class members of an instance method
     * 
     * @param methodInfo
     *            information of the method to render
     * @param signatures
     *            schema's full qualified name
     */
    private void renderMethodMembers(MethodInfo methodInfo, Set<String> signatures, Renderer renderer,
            String firstArg) {

        List<VarInfo> parameters = methodInfo.getParameters();
        int[] renderIndex = new int[parameters.size()];
        boolean[] emittedTwiceIndex = new boolean[parameters.size()];
        String[][] paramTypes = new String[parameters.size()][2];
        String[][] rendersArguments = new String[parameters.size()][2];
        for (int i = 0; i < parameters.size(); i++) {
            VarInfo varInfo = parameters.get(i);
            emittedTwiceIndex[i] = varInfo.isEmittedTwice();
            renderArgumentAndParameterType(varInfo, paramTypes, rendersArguments, i);
        }

        StringBuilder methodSignature = new StringBuilder();
        List<String> argsSelected = new ArrayList<>(parameters.size() + 1);
        StringBuilder parametersRender = new StringBuilder();

        String[][] renderMethod = renderMethodProperties(methodInfo);
        do {
            argsSelected.clear();
            if (firstArg != null) {
                argsSelected.add(firstArg);
            }
            renderArgumentsAndParameters(methodInfo, parameters, renderIndex, paramTypes, rendersArguments,
                    methodSignature, argsSelected, parametersRender);
            if (signatures.add(methodSignature.toString())) {
                for (String[] renders : renderMethod) {
                    renderer.render(parametersRender.toString(), argsSelected, renders, methodInfo);
                }
            } else {
                messager.printMessage(Kind.ERROR, ERROR_METHODS_SIGNATURE, methodInfo.getMethod());
            }
        } while (increment(renderIndex, emittedTwiceIndex));
    }

    /**
     * Renders a parameter of an instance method
     * 
     * @param varInfo
     *            parameter to render
     * @param rendersParams
     *            to store the render of the parameter
     * @param rendersArguments
     *            to store the arguments related to this parameter
     * @param index
     *            the position to store the parameter in the given arrays
     */
    private void renderArgumentAndParameterType(VarInfo varInfo, String[][] rendersParams, String[][] rendersArguments,
            int index) {
        String name = varInfo.getName();
        if (varInfo.isEmittedTwice()) {
            DataType dataType = varInfo.getType();
            if (DataType.RECORD.equals(dataType)) {
                String complexType = varInfo.getComplexType();
                String record = complexType.substring(0, complexType.lastIndexOf('.'));
                rendersParams[index][0] = record;
                rendersParams[index][1] = complexType;
                rendersArguments[index][0] = "(" + complexType + ")" + name;
                rendersArguments[index][1] = name;
            } else {
                Properties properties = dataTypeRenderer.getProperties(dataType);
                Class<?> mngType = properties.getMngType();
                rendersParams[index][0] = properties.getPrimitiveType();
                rendersParams[index][1] = mngType.getCanonicalName();
                if (varInfo.isManaged()) {
                    rendersArguments[index][0] = mngType.getCanonicalName() + TypeProp.VALUE_OF + "(" + name + ")";
                    rendersArguments[index][1] = name;
                } else {
                    rendersArguments[index][0] = name;
                    rendersArguments[index][1] = name + " == null ? null : " + name + "."
                            + properties.getAsPrimitiveValueMethod();
                }
            }
        } else {
            rendersParams[index][0] = renderVarType(varInfo);
            rendersArguments[index][0] = name;
        }
    }

    /**
     * Render method properties, including: name, return type and casting
     * 
     * @param methodInfo
     *            information of the method to render
     * @return rendered properties
     */
    private String[][] renderMethodProperties(MethodInfo methodInfo) {
        VarInfo returnType = methodInfo.getReturnType();
        String methodName = methodInfo.getName();
        if (returnType.isEmittedTwice()) {
            String[][] renders = new String[2][4];
            Properties properties = dataTypeRenderer.getProperties(returnType.getType());
            Class<?> mngType = properties.getMngType();
            renders[PRIM][RETURN_TYPE] = properties.getPrimitiveType();
            renders[PRIM][CAST_START] = RETURN;
            renders[MNG][RETURN_TYPE] = mngType.getCanonicalName();
            if (returnType.isManaged()) {
                renders[PRIM][METHOD_NAME] = "prim" + firstCharUpperCase(methodName);
                renders[PRIM][CAST_END] = "." + properties.getAsPrimitiveValueMethod();
                renders[MNG][METHOD_NAME] = methodName;
                renders[MNG][CAST_START] = RETURN;
                renders[MNG][CAST_END] = EMPTY;
            } else {
                renders[PRIM][METHOD_NAME] = methodName;
                renders[PRIM][CAST_END] = EMPTY;
                renders[MNG][METHOD_NAME] = "managed" + firstCharUpperCase(methodName);
                renders[MNG][CAST_START] = RETURN + mngType.getCanonicalName() + TypeProp.VALUE_OF + "(";
                renders[MNG][CAST_END] = ")";
            }
            return renders;
        } else {
            String castStart = DataType.VOID.equals(returnType.getType()) ? EMPTY : RETURN;
            return new String[][] { { methodName, renderVarType(methodInfo.getReturnType()), castStart, EMPTY } };
        }
    }

    /**
     * @param string
     * @return the given string with its first character in upper case
     */
    private String firstCharUpperCase(String string) {
        return string.substring(0, 1).toUpperCase() + string.substring(1);
    }

    /**
     * Renders an instance method at the required visibility level
     * 
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the call to the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param methodInfo
     *            information of the method to render
     */
    private void renderInstanceMethodMembers(String parameters, List<String> arguments, String[] renders,
            MethodInfo methodInfo) {
        if (!methodInfo.isAbstract()) {
            addPrivateMethod(renderDefaultMethodImpl(parameters, arguments, renders, methodInfo.getName()));
            if (methodInfo.isAmbiguous()) {
                addAmbiguousMethod(renderAmbiguousMethodImpl(parameters, arguments, renders, methodInfo.getName()));
            }
        }
        switch (methodInfo.getVisibility()) {
        case PUBLIC:
            addPublicMethod(renderMethodDeclaration(renders[RETURN_TYPE], renders[METHOD_NAME], parameters));
            break;
        case PROTECTED:
            addProtectedMethod(renderMethodDeclaration(renders[RETURN_TYPE], renders[METHOD_NAME], parameters));
            break;
        case PRIVATE:
            if (methodInfo.isAbstract()) {
                addPrivateMethod(renderMethodDeclaration(renders[RETURN_TYPE], renders[METHOD_NAME], parameters));
            }
            break; // ignore, default implementation is at this level
        default:
            break;
        }
    }

    /**
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param schemaMethod
     *            name of the method in the schema
     * @return render of an instance method implementation for a class
     */
    private String renderAmbiguousMethodImpl(String parameters, List<String> arguments, String[] renders,
            String schemaMethod) {
        return renderMehodImpl(parameters, arguments, renders, schemaMethod, TEMPLATE_AMBIGUOUS_METHOD);
    }

    /**
     * Renders a static method at the required visibility level
     * 
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the call to the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param methodInfo
     *            information of the method to render
     */
    private void renderStaticMethodMembers(String parameters, List<String> arguments, String[] renders,
            MethodInfo methodInfo) {
        addPrivateStaticMethod(renderDefaultMethodImpl(parameters, arguments, renders, methodInfo.getName()));
        switch (methodInfo.getVisibility()) {
        case PUBLIC:
            addPpublicStaticMethod(renderMethodDeclaration(renders[RETURN_TYPE], renders[METHOD_NAME], parameters));
            addPublicMethod(renderStaticMethod(parameters, arguments, renders, methodInfo.getName()));
            break;
        case PROTECTED:
            addProtectedStaticMethod(renderMethodDeclaration(renders[RETURN_TYPE], renders[METHOD_NAME], parameters));
            break;
        case PRIVATE:
            break; // ignore, default implementation is at this level
        default:
            break;
        }

    }

    /**
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param schemaMethod
     *            name of the method in the schema
     * @return render of an instance method implementation for an interface
     */
    private String renderDefaultMethodImpl(String parameters, List<String> arguments, String[] renders,
            String schemaMethod) {
        return renderMehodImpl(parameters, arguments, renders, schemaMethod, TEMPLATE_METHOD_IMPL);
    }

    /**
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param schemaMethod
     *            name of the method in the schema
     * @return render of the static method for an interface
     */
    private String renderStaticMethod(String parameters, List<String> arguments, String[] renders,
            String schemaMethod) {
        return renderMehodImpl(parameters, arguments, renders, schemaMethod, TEMPLATE_STATIC_METHOD);
    }

    /**
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param schemaMethod
     *            name of the method in the schema
     * @param templateName
     *            name of the schema for the render
     * @return render of an instance method implementation
     */
    private String renderMehodImpl(String parameters, List<String> arguments, String[] renders, String schemaMethod,
            String templateName) {
        ST template = stGroup.getInstanceOf(templateName);
        assert template != null; // this template should always exists
        template.add("methodName", renders[METHOD_NAME]);
        template.add("returnType", renders[RETURN_TYPE]);
        template.add("parameters", parameters);
        template.add("schema", recordInfo.getSchema());
        template.add("schemaMethod", schemaMethod);
        template.add("arguments", arguments);
        template.add("castStart", renders[CAST_START]);
        template.add("castEnd", renders[CAST_END]);
        return template.render();
    }

    /**
     * @param returnType
     *            return type of the method
     * @param name
     *            method name
     * @param parameters
     *            method parameters
     * @return render of an instance method declaration
     */
    private String renderMethodDeclaration(String returnType, String name, String parameters) {
        ST template = stGroup.getInstanceOf(TEMPLATE_METHOD_DECLARATION);
        assert template != null; // this template should always exists
        template.add("returnType", returnType);
        template.add("methodName", name);
        template.add("parameters", parameters);
        return template.render();
    }

    /**
     * Renders all members associated with the given constructor
     * 
     * @param constructor
     *            constructor to render
     * @param signatures
     *            methods signatures
     */
    private void renderConstructor(MethodInfo constructor, Set<String> signatures) {
        List<VarInfo> parameters = constructor.getParameters();
        String[] rendersParams = new String[parameters.size()];
        String[] rendersArguments = new String[parameters.size()];
        for (int i = 0; i < parameters.size(); i++) {
            VarInfo varInfo = parameters.get(i);
            String name = varInfo.getName();
            rendersParams[i] = renderVarType(varInfo) + " " + name;
            rendersArguments[i] = name;
        }
        addUserConstructor(renderConstructor(rendersParams, rendersArguments));
        if (!recordInfo.isAbstract()) {
            renderCreationMethods(constructor, signatures);
        }
    }

    /**
     * @param varInfo
     * @return the render of the data type of a {@link VarInfo} as original
     *         declared
     */
    private String renderVarType(VarInfo varInfo) {
        DataType dataType = varInfo.getType();

        // if record or unknown datatype
        if (dataType == null || DataType.RECORD.equals(dataType)) {
            return varInfo.getComplexType();
        }

        // if void
        if (DataType.VOID.equals(dataType)) {
            return VOID;
        }

        // if array type
        if (DataType.ARRAY.equals(dataType)) {
            String complexType = varInfo.getComplexType();
            if (complexType != null) {
                return complexType;
            } else {
                String type = TypeProp.ARRAY_GENERIC.getMngType().getCanonicalName();
                return dataTypeRenderer.renderTypeWithParams(type, varInfo.getTypeParams());
            }
        }

        Properties properties = dataTypeRenderer.getProperties(dataType);

        // if collection with parameters
        if (dataType.getRequiredParams() > 0) {
            final String typeName;
            if (varInfo.isManaged()) {
                typeName = properties.getMngType().getCanonicalName();
            } else {
                typeName = properties.getPrimitiveType();
            }
            return dataTypeRenderer.renderTypeWithParams(typeName, varInfo.getTypeParams());
        }

        // any other case
        if (varInfo.isManaged()) {
            return properties.getMngType().getCanonicalName();
        }
        return properties.getPrimitiveType();
    }

    /**
     * @param parameters
     *            rendered method parameters
     * @param arguments
     *            rendered arguments for the schema method
     * @return Render of a constructor
     */
    private String renderConstructor(String[] parameters, String[] arguments) {
        ST template = stGroup.getInstanceOf(TEMPLATE_USER_CONSTRUCTOR);
        assert template != null; // this template should always exists
        template.add("recordName", recordInfo.getSimpleName());
        template.add("parameters", parameters);
        template.add("schema", recordInfo.getSchema());
        template.add("arguments", arguments);
        return template.render();
    }

    /**
     * Renders creation methods for the given constructor
     * 
     * @param constructor
     *            information of the constructor
     * @param signatures
     *            method signatures
     */
    private void renderCreationMethods(MethodInfo constructor, Set<String> signatures) {
        List<VarInfo> parameters = constructor.getParameters();
        int[] renderIndex = new int[parameters.size()];
        boolean[] emittedTwiceIndex = new boolean[parameters.size()];
        String[][] paramTypes = new String[parameters.size()][2];
        String[][] rendersArguments = new String[parameters.size()][2];
        for (int i = 0; i < parameters.size(); i++) {
            VarInfo varInfo = parameters.get(i);
            emittedTwiceIndex[i] = varInfo.isEmittedTwice();
            renderArgumentAndParameterType(varInfo, paramTypes, rendersArguments, i);
        }

        StringBuilder methodSignature = new StringBuilder();
        List<String> argsSelected = new ArrayList<>(parameters.size());
        StringBuilder parametersRender = new StringBuilder();
        Visibility visibility = constructor.getVisibility();

        do {
            argsSelected.clear();
            renderArgumentsAndParameters(constructor, parameters, renderIndex, paramTypes, rendersArguments,
                    methodSignature, argsSelected, parametersRender);
            if (signatures.add(methodSignature.toString())) {
                renderCreationMethodMembers(parametersRender.toString(), argsSelected, visibility);
            } else {
                messager.printMessage(Kind.ERROR, ERROR_METHODS_SIGNATURE, constructor.getMethod());
            }
        } while (increment(renderIndex, emittedTwiceIndex));
    }

    /**
     * Renders the parameters of a method and the arguments used to call the
     * corresponding schema method
     * 
     * @param method
     *            information of the method being rendered
     * @param parameters
     *            parameters information
     * @param renderIndex
     *            the position index of parameters and arguments to render
     * @param paramTypes
     *            renders of parameters
     * @param rendersArguments
     *            renders of arguments
     * @param methodSignature
     *            to store the signature of the method being rendered
     * @param argsSelected
     *            to store the arguments used for the render of this method
     * @param parametersRender
     *            to store the rendered parameters
     */
    private void renderArgumentsAndParameters(MethodInfo method, List<VarInfo> parameters, int[] renderIndex,
            String[][] paramTypes, String[][] rendersArguments, StringBuilder methodSignature,
            List<String> argsSelected, StringBuilder parametersRender) {
        methodSignature.setLength(0); // cleaning the content first
        methodSignature.append(method.getName()).append(SIGNATURE_SEPARATOR);
        parametersRender.setLength(0); // cleaning the content first
        String separator = EMPTY;
        for (int i = 0; i < renderIndex.length; i++) {
            String paramType = paramTypes[i][renderIndex[i]];
            parametersRender.append(separator).append(paramType).append(" ").append(parameters.get(i).getName());
            methodSignature.append(paramType).append(SIGNATURE_SEPARATOR);
            argsSelected.add(rendersArguments[i][renderIndex[i]]);
            separator = ", ";
        }
    }

    /**
     * Renders creation method implementation and declarations at the given
     * visibility level
     * 
     * @param parameters
     *            rendered creation method parameters
     * @param arguments
     *            rendered arguments for the implementation
     * @param visibility
     *            the visibility level of the creation method
     */
    private void renderCreationMethodMembers(String parameters, List<String> arguments, Visibility visibility) {
        addCreationMethodsImpl(renderCreationMethodImpl(parameters, arguments));
        switch (visibility) {
        case PUBLIC:
            addPublicCreationMethod(renderCreationMethodDec(parameters));
            // public also renders protected and private
        case PROTECTED:
            addProtectedCreationMethod(renderCreationMethodDecWithType(parameters, PROTECTED));
            // protected also renders private
        case PRIVATE:
            addPrivateCreationMethod(renderCreationMethodDecWithType(parameters, PRIVATE));
            break;
        default:
            break;
        }
    }

    /**
     * Tries to increment the counter of the indexes
     * 
     * @param renderIndex
     *            index to increment
     * @param emittedTwiceIndex
     *            flags for index that cannot be incremented
     * @return true if the index was incremented
     */
    private boolean increment(int[] renderIndex, boolean[] emittedTwiceIndex) {
        for (int i = 0; i < renderIndex.length; i++) {
            if (emittedTwiceIndex[i]) {
                if (renderIndex[i] == 0) {
                    renderIndex[i] = 1;
                    return true;
                } else {
                    renderIndex[i] = 0;
                }
            }
        }
        return false;
    }

    /**
     * 
     * @param parameters
     *            rendered method parameters
     * @param arguments
     *            rendered arguments for the schema method
     * @return Implementation of a creation method
     */
    private String renderCreationMethodImpl(String parameters, List<String> arguments) {
        ST template = stGroup.getInstanceOf(TEMPLATE_CREATION_METHOD_IMPL);
        assert template != null; // this template should always exists
        template.add("recordName", recordInfo.getSimpleName());
        template.add("parameters", parameters);
        template.add("arguments", arguments);
        return template.render();
    }

    /**
     * @param parameters
     *            rendered method parameters
     * @param type
     *            for the return type
     * @return Render of a creation method declaration with the given type
     */
    private String renderCreationMethodDecWithType(String parameters, String type) {
        String returnType = recordInfo.getSimpleName() + "." + type;
        return renderCreationMethodDec(parameters, returnType);
    }

    /**
     * @param parameters
     *            rendered method parameters
     * @return Render of a creation method declaration with the record type as
     *         return type
     */
    private String renderCreationMethodDec(String parameters) {
        return renderCreationMethodDec(parameters, recordInfo.getSimpleName());
    }

    /**
     * @param parameters
     *            rendered method parameters
     * @param returnType
     *            the rendered return type of the method
     * @return Render of a creation method declaration with the given return
     *         type
     */
    private String renderCreationMethodDec(String parameters, String returnType) {
        ST template = stGroup.getInstanceOf(TEMPLATE_CREATION_METHOD_DEC);
        assert template != null; // this template should always exists
        template.add("returnType", returnType);
        template.add("parameters", parameters);
        return template.render();
    }

    /**
     * Renders the default no argument constructor
     */
    private void renderDefaultConstructor() {
        ST template = stGroup.getInstanceOf(TEMPLATE_DEFAULT_CONSTRUCTOR);
        assert template != null; // this template should always exists
        template.add("recordName", recordInfo.getSimpleName());
        addUserConstructor(template.render());
        if (!recordInfo.isAbstract()) {
            renderCreationMethodMembers(EMPTY, Collections.emptyList(), Visibility.PUBLIC);
        }
    }

}
