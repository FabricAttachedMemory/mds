/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processor.parser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

import javax.annotation.processing.Messager;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic.Kind;

import com.hpl.mds.annotations.Emitted;
import com.hpl.mds.annotations.Paradigm;
import com.hpl.mds.annotations.processor.RecordInfo.GetterFormatInfo;
import com.hpl.mds.annotations.processor.RecordInfo.Visibility;

/**
 * Parses and traverses referenced paradigms of a record schema
 *
 * @author Abraham Alcantara
 */
public class ParadigmParser {

    /**
     * Stores all the information of a parsed paradigm
     * 
     * @author Abraham Alcantara
     */
    private static class ParadigmInfo {

        /**
         * Declared visibilities
         */
        private Map<Emitted, Visibility> visibilities;

        /**
         * Parent paradigms
         */
        private List<String> parents;

        /**
         * Declared format for getters
         */
        private GetterFormatInfo getterFormatInfo;

        public void setVisibilities(Map<Emitted, Visibility> visibilities) {
            this.visibilities = visibilities;
        }

        public Map<Emitted, Visibility> getVisibilities() {
            return visibilities;
        }

        public void setParents(List<String> parents) {
            this.parents = parents;
        }

        public List<String> getParents() {
            return parents;
        }

        public void setGetterFormatInfo(GetterFormatInfo getterFormatInfo) {
            this.getterFormatInfo = getterFormatInfo;
        }

        public GetterFormatInfo getGetterFormatInfo() {
            return getterFormatInfo;
        }
    }

    private static final String PKG_DELIMITER = ".";

    /**
     * To display localized messages to the user
     */
    private final Messager messager;

    /**
     * Utilities for source code elements
     */
    private final Elements elementUtils;

    /**
     * Utilities for source code types
     */
    private final Types typeUtil;

    /*
     * Parsers to extract specific data
     */
    private final VisibilitiesParser visibilitiesParser;
    private final GetterNameParser getterNameParser;

    /**
     * Paradigm cache to avoid re-parsing of paradigms
     */
    private final Map<String, ParadigmInfo> paradigmsInfo = new HashMap<>();

    public ParadigmParser(Messager messager, Elements elementUtils, Types typeUtil,
            VisibilitiesParser visibilitiesParser, GetterNameParser getterNameParser) {
        super();
        this.messager = messager;
        this.elementUtils = elementUtils;
        this.typeUtil = typeUtil;
        this.visibilitiesParser = visibilitiesParser;
        this.getterNameParser = getterNameParser;
    }

    /**
     * Traverses the paradigms of the given schema and adds up the inherited
     * information for the schema
     * 
     * @param schema
     *            with the declared paradigm
     * @param context
     *            context information of the schema used to store inherited
     *            values
     * @param inheritedVisibilities
     *            schema visibilities used to store paradigm inherited values
     */
    public void traverseParadigms(Element schema, SchemaContext context,
            List<Map<Emitted, Visibility>> inheritedVisibilities) {
        traverseParadigms(parseParadigms(schema), getParadigmHandler(inheritedVisibilities, context), schema);
    }

    /**
     * @param schema
     * @return the names of the paradigms declared in the given schema
     */
    private List<String> parseParadigms(Element schema) {
        Paradigm paradigm = schema.getAnnotation(Paradigm.class);
        if (paradigm != null) {
            String[] values = paradigm.value();
            if (values.length > 0) {
                return Arrays.asList(values);
            } else {
                messager.printMessage(Kind.ERROR, "Empty value for: " + Paradigm.class.getName(), schema);
            }
        }
        return Collections.emptyList();
    }

    /**
     * @param inheritedVisibilities
     * @param context
     * @return function that will receive the information from the paradigms
     */
    private Consumer<ParadigmInfo> getParadigmHandler(List<Map<Emitted, Visibility>> inheritedVisibilities,
            SchemaContext context) {
        return (paradigmInfo) -> {
            // set getter name format if no already set
            if (context.getGetterNameFormat() == null) {
                context.setGetterNameFormat(paradigmInfo.getGetterFormatInfo());
            }

            // adds to the list of visibilities
            inheritedVisibilities.add(paradigmInfo.getVisibilities());
        };
    }

    /**
     * Traverses paradigms, so the information can be consumed by the given
     * handler
     * 
     * @param paradigmNames
     *            qualified names of the paradigms
     * @param handler
     *            will be invoked for each found Paradigm
     * @param schema
     *            used to localize error messages
     */
    private void traverseParadigms(List<String> paradigmNames, Consumer<ParadigmInfo> handler, Element schema) {
        for (String paradigmName : paradigmNames) {

            // construct paradigm qualified name
            String qualifiedName;
            if (paradigmName.indexOf(PKG_DELIMITER) > 0) {
                qualifiedName = paradigmName;
            } else {
                qualifiedName = schema.getEnclosingElement().toString() + PKG_DELIMITER + paradigmName;
            }

            // retrieve the TypeElement by its qualified name
            TypeElement typeElement = elementUtils.getTypeElement(qualifiedName);
            if (typeElement == null) {
                messager.printMessage(Kind.ERROR, "paradigm not found: " + qualifiedName, schema);
                continue;
            }

            // verify its a paradigm
            if (typeElement.getAnnotation(Paradigm.class) == null) {
                messager.printMessage(Kind.ERROR, "ignoring referenced class: " + paradigmName + ", not a paradigm",
                        schema);
                continue;
            }

            // extract the paradigm information and its parents
            ParadigmInfo paradigmInfo = getParadigmInfo(typeElement);
            handler.accept(paradigmInfo);
            traverseParadigms(paradigmInfo.getParents(), handler, schema);
        }
    }

    /**
     * Retrieves the information of given paradigm, parsing it if required
     * 
     * @param paradigm
     * @return the paradigm's information of the given element
     */
    private ParadigmInfo getParadigmInfo(TypeElement paradigm) {

        // look for it in cache
        ParadigmInfo paradigmInfo = paradigmsInfo.get(paradigm.toString());
        if (paradigmInfo == null) {

            // parse the information
            paradigmInfo = new ParadigmInfo();
            paradigmInfo.setVisibilities(visibilitiesParser.parse(paradigm, Emitted.ALL));
            paradigmInfo.setParents(parseParadigmParentNames(paradigm));
            paradigmInfo.setGetterFormatInfo(getterNameParser.parse(paradigm));
            paradigmsInfo.put(paradigm.toString(), paradigmInfo);
        }
        return paradigmInfo;
    }

    /**
     * @param paradigm
     * @return parents' qualified names of the given paradigm
     */
    private List<String> parseParadigmParentNames(Element paradigm) {
        List<String> parents = null;

        // retrieve all parents of this class
        List<? extends TypeMirror> directSupertypes = typeUtil.directSupertypes(paradigm.asType());
        for (TypeMirror typeMirror : directSupertypes) {

            // retrieve element by qualified name
            Element element = typeUtil.asElement(typeMirror);

            // if this is paradigm
            if (element.getAnnotation(Paradigm.class) != null) {
                if (parents == null) {
                    parents = new ArrayList<>();
                }
                parents.add(element.toString());
            }
        }
        if (parents != null) {
            return parents;
        }
        return Collections.emptyList();
    }

}
