/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */



package com.hpl.mds.task;

import java.util.Collections;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

import org.apache.log4j.Logger;

import com.hpl.mds.Field;
import com.hpl.mds.IsolationContext;
import com.hpl.mds.ManagedObject;
import com.hpl.mds.ManagedRecord;
import com.hpl.mds.impl.ArrayProxy;
import com.hpl.mds.impl.ChangeBase;

public class Task {

    private static final Logger log = Logger.getLogger(Task.class);

    /** Task.current_ is InheritableThreadLocal for multi-thread support. 
     *  It enables multiple threads to run different tasks safely in parallel 
     *  within the same IsolationContext; 
     *  giving each thread its own view of currentTask.
     *  It also enables one thread to run a task 
     *  that can spawn another thread which runs its own task;
     *  again giving each thread its own view of Task.current.
     */
    private static InheritableThreadLocal<Task> current_ = 
        new InheritableThreadLocal<>();
	
    private String id; // Every task must have a unique id
    private TaskInterface taskCode;
    private Set<ChangeBase> writeSet = Collections.newSetFromMap(new ConcurrentHashMap<ChangeBase, Boolean>());
    private Set<ChangeBase>  readSet = Collections.newSetFromMap(new ConcurrentHashMap<ChangeBase, Boolean>());
    Set<Task> dependentTasks;
    
    private IsolationContext runTaskContext;  //the context in which this task has been run
    
    // for task rerun only: 
    // prevWriteSet: writeSet from last run, kept to compare with writeSet for this run
    Set<ChangeBase> prevWriteSet;

    //tmp: while do some TaskTest tests...
    // private static List<TaskInterface> taskList = new ArrayList<>();
    
    
    // Task.current_ access methods
    public static Task current() {
        return current_.get();
    }

    public static void setCurrent(Task task) {
        current_.set(task);
    }    
    
    
    public Task(String id, TaskInterface taskCode) {
    	this.id = id;
    	this.taskCode = taskCode;
    	taskInit();
    }
    
    // Initialize task bookkeeping before initial run and before each rerun
    private void taskInit() {
    	// writeSet = Collections.synchronizedMap(new HashMap<>());
    	// readSet = Collections.synchronizedMap(new HashMap<>());
        // dependentTasks = Collections.synchronizedSet(new HashSet<>());    	    	
    	// writeSet = new ConcurrentHashMap<>();
    	// readSet = new ConcurrentHashMap<>();
    	writeSet = Collections.newSetFromMap(new ConcurrentHashMap<ChangeBase, Boolean>());
    	readSet  = Collections.newSetFromMap(new ConcurrentHashMap<ChangeBase, Boolean>());
        dependentTasks = Collections.newSetFromMap(new ConcurrentHashMap<Task, Boolean>()); 	
    }
    
    // Re-initialize task bookkeeping before each rerun
    // preserving writeSet from previous run first, for comparison
    private void taskReinit() {
    	prevWriteSet = writeSet;
    	taskInit();
    }
    
    //////
    
    // public static Task currentTask() {
    // 	IsoContextProxy currentContext = (IsoContextProxy)IsolationContext.current();
    // 	return currentContext.currentTask();
    // }
    
//
//    private static Task currentTask = null;
//    
//    public static Task current() { 
//    	return currentTask;
//    }
//
//    public static String currentId() { 
//        return currentTask.id;
//    }
//    
    //////


    public String id() {
        return id;
    }

    public Set<Task> dependentTasks() {
    	return dependentTasks;
    }

    public void addDependentTask(Task task) {
        dependentTasks.add(task);
    }
    
    public void setContext(IsolationContext runTaskContext) {
    	this.runTaskContext = runTaskContext;
    }

  static final AtomicLong nextSerialNumber = new AtomicLong(1);

  static String genTaskName() {
    return String.format("Task%08d", nextSerialNumber.getAndIncrement());
  }

    /** 
     * runTask - create and register new Task
     *         - set as current task and run it
     * @param taskId
     * @param taskInterface - the code to run when executing this task
     */
    public static void runTask(String taskId, TaskInterface taskInterface) {
        // System.out.println("runTask: id = " + taskId);
        // create new task, register it with context, run task
        Task currentTask = task(taskId, taskInterface);
        currentTask.run();
    }

    public static void runTask(TaskInterface taskInterface) {
      runTask(null, taskInterface);
    }
    /** 
     * task - create and register new Task (but don't run it)
     * @param taskId
     * @param taskInterface - the code to run when executing this task
     * @return Task
     */
    public static Task task(String taskId, TaskInterface taskInterface) {
      if(taskId == null) {
        taskId = genTaskName();
      }
       // taskList.add(taskInterface); 
        Task newTask = new Task(taskId, taskInterface);
        
    	IsolationContext.addTask(newTask);
    	
    	return newTask;
    }

    public static Task task(TaskInterface taskInterface) {
      return task(null, taskInterface);
    }
 
    /**
     * run the code associated with this Task, in the current IsolationContext.
     */
    public void run() {
    	//log.debug("Task.run: in context: " + IsolationContext.current());
    	
    	// record context in which task is run
        // register task as Task.current 
        IsolationContext currentContext = IsolationContext.current();
        setContext(currentContext);
        // ((IsoContextProxy)currentContext).setCurrentTask(this);
        setCurrent(this);
        
        // execute the code of the current task
    	taskCode.run(); 

        // unset current task when code execution is complete
        // ((IsoContextProxy)currentContext).setCurrentTask(null);
        setCurrent(null);
    }
    
    /** 
     * Rerun the code associated with this Task, in the same IsolationContext as the original run.
     */
    public void reRun() {
    	// log.debug("Task.rerun: invoked in context: " + IsolationContext.current());
    	// log.debug("Task.reRun: runTaskContext = " + runTaskContext);
    	
    	runTaskContext.clearConflicts();  // tmp call to clear conflicts while mark_resolved not called to do this properly

        // Re-initialize task bookkeeping before rerun
    	taskReinit();
    	
		runTaskContext.call(() -> {
	    	// log.debug("Task.reRun: calling code in context: " + IsolationContext.current());
			taskCode.run();
		});
    }
    
    public static <RT extends ManagedRecord, FT extends ManagedObject>
    void addRead(RT record, Field<RT,FT> field) {
        // add (currentId, fieldHandle) pair to current task read set
    	// Only track reads if we're executing code within a Task
    	// log.debug("Task.addRead:");
    	// Task currentTask = currentTask();
    	Task currentTask = current();
    	if (currentTask != null) {
    		log.debug("Task.addRead: currentTask = " + currentTask.id() + " fieldname: " + field.name());
    		ChangeBase change = field.createChange(record);
    		currentTask.addRead(change);
    	}
    }    
    
    public static <ET extends ManagedObject>
    void addRead(ArrayProxy<ET> array, long index) {
    	Task currentTask = current();
    	if (currentTask != null) {
    		ChangeBase change = array.createChange(index);
    		currentTask.addRead(change);
    	}
    }
    
//    public static void addRead(ManagedArray arr, int slot) {
//    	Task currentTask = current();
//    	if (currentTask != null) {
//    		log.debug("Task.addRead: currentTask = " + currentTask.id() + " arrayslot: " + slot);
//    		ChangeBase change = arr.createChange(slot);
//    		currentTask.addRead(change);
//    }

    public static <RT extends ManagedRecord, FT extends ManagedObject>
    void addWrite(RT record, Field<RT,FT> field) {
    	// Only track writes if we're executing code within a Task
    	// log.debug("Task.addWrite:");
    	// Task currentTask = currentTask();
    	Task currentTask = current();
    	if (currentTask != null) {
    		log.debug("Task.addWrite: currentTask = " + currentTask.id() + " fieldname: " + field.name());
    		ChangeBase change = field.createChange(record);
	    	currentTask.addWrite(change);
    	}
    }

    public static <ET extends ManagedObject>
    void addWrite(ArrayProxy<ET> array, long index) {
    	Task currentTask = current();
    	if (currentTask != null) {
    		ChangeBase change = array.createChange(index);
    		currentTask.addWrite(change);
    	}
    }

    public static <RT extends ManagedRecord, FT extends ManagedObject> 
    void addReadWrite(RT record, Field<RT,FT> field) {
    	// Only track reads, writes if we're executing code within a Task
    	// log.debug("Task.addReadWrite:");
    	// Task currentTask = currentTask();
    	Task currentTask = current();
    	if (currentTask != null) {
    		log.debug("Task.addReadWrite: currentTask = " + currentTask.id() + " fieldname: " + field.name());
    		ChangeBase change = field.createChange(record);
	    	currentTask.addRead(change);
	    	currentTask.addWrite(change);    	}
    }

    public static <ET extends ManagedObject>
    void addReadWrite(ArrayProxy<ET> array, long index) {
    	Task currentTask = current();
    	if (currentTask != null) {
    		ChangeBase change = array.createChange(index);
    		currentTask.addRead(change);
    		currentTask.addWrite(change);
    	}
    }

    /**
     * addWrite
     * - add (recordID, fieldName) pair to current Task write set
     * - add (recordID, fieldName)->Task mapping to current IsolationContext 
     */
    public void addWrite(ChangeBase write) {
    	// add this write to this task's writeSet, if the writeSet doesn't already contain it
    	if ( addChange(write, writeSet) ) {
    	    // addChange returns true if writeSet didn't already contain this change
    		// now add write->task mapping to current IsolationContext for future reference
    		log.debug("Task.addWrite: now adding task-write mapping to context");
	    	IsolationContext.addTaskWrite(this, write);    
    	}
    	// else if writeSet already contains given change
		//     there's no need to add taskWrite mapping to the current IsolationContext 
		//     because it should already be there too.
    }

    
    
    /**
     * addRead 
     * - add (recordID, fieldName) pair to current Task read set
     * - add (recordID, fieldName)->Task mapping to current IsolationContext 
     */
    public void addRead(ChangeBase read) {
    	// capture dependency if this read reads a location that was last written by a different task
        Task lastWriter = IsolationContext.lastWriterTask(read);   
        if (lastWriter != null) {
            if ( ! (this.equals(lastWriter)) ) { 
                // "this" task and lastWriter task are not the same task:
                //     adding this "readerTask" task to 
                //     the list of dependentTasks associated with 
                //     the lastWriter task to write to the same location
                lastWriter.addDependentTask(this);
            }    	
        }

    	// add this read to this task's readSet, if the readSet doesn't already contain it
    	if (addChange(read, readSet) ) {
    	    // addChange returns true if readSet didn't already contain read
    	    // now add read->task mapping to current IsolationContext for future reference
            log.debug("Task.addRead: now adding loctask mapping to context");
            IsolationContext.addTaskRead(this, read);    
            
        }  
    	// else readSet, current IsolationContext already contain given read
    }

    
    // addChange adds a Change to a Map representing a writeSet or readSet
    // returns true if it did add the change; false if the set already contained given change
    public boolean addChange(ChangeBase change, Set<ChangeBase> changeSet) {    	
    	return changeSet.add(change);
    }

    


    /** 
     * setRerunState
     * For this task to be rerun: 
     * for every conflicted location in this Task's writeSet: 
     *   setToParent
     */
	public void setRerunState() {
		for (ChangeBase write : writeSet) {
        	log.debug("setRerunState: write: " + write);
        	runTaskContext.call(() -> {
        		write.setToParent();
        	});
		}
	}
		

  
} // end class Task
