/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */


package com.hpl.mds.task;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;


// Tree of task nodes 
// Tree is populated with tasks in a way which 
//   captures the dependencies between tasks to be rerun.
// Iterating through tree, top to bottom, left to right, 
//   generates correct ordering of execution for tasks to be rerun.

public class TaskNode {
	
	private static final Logger log = Logger.getLogger(TaskNode.class);
	
    public enum TaskType {
        ROOT,
    	CONFLICTED,
    	DEPENDENT
    }
    
    private Task task;
    private TaskType taskType;
   
    // private TaskNode       parent;
    private List<TaskNode> parents;
    private List<TaskNode> children;
    
    // root node constructor
    public TaskNode() {
        this.task = null;  // the root node has no task itself, but may have children
        this.taskType = TaskType.ROOT;
        this.parents = null; // the root node has no parents!
        this.children = new LinkedList<>();
    }


    // non-root node constructor
    public TaskNode(Task task, TaskType taskType, TaskNode parent) {
    	this.task = task;
    	this.taskType = taskType;
        this.parents = new LinkedList<>();
        this.parents.add(parent);
        this.children = new LinkedList<>();
    }
    

    public Task task() {
        return task;
    }

    public TaskType taskType() {
        return taskType;
    }

    public List<TaskNode> parents() {
        return parents;
    }

    public List<TaskNode> children() {
        return children;
    }

    public void addParent(TaskNode parent) {
    	this.parents.add(parent);
    }

    // add(Task):
    // Only for use when we already know the given task is not in children
    // Returns newly created TaskNode
    // 
    // if adding to the top-level of the task graph, 
    // where current TaskNode.TaskType == ROOT, 
    // then add task as TaskType.CONFLICTED;
    // else adding to children in lower-level node of the task graph, 
    // which means that given task must be TaskType.DEPENDENT
    // (even if it started out conflicted, 
    //  it has also been identified as dependent on another task).
    // 
    public TaskNode add(Task task) {
    	TaskNode newNode = null;
        if (this.taskType == TaskType.ROOT) {
            newNode = new TaskNode(task, TaskType.CONFLICTED, this);
        }
        else {
            newNode = new TaskNode(task, TaskType.DEPENDENT, this);
        }
        children.add(newNode);
        return newNode;
    }

    // addTasksAndDependencies
    // 
    // If tasks not already in taskGraph, 
    //   add tasks to given parentTaskNode in taskGraph
    // else if task already in taskGraph
    //   set parentTaskNode to TaskNode in taskGraph containing this task and
    //   iterate through dependencies, adding them to taskGraph as necessary
    // 
    // Initially, given empty taskGraph and set of conflicted tasks,
    //   iterates through conflicted tasks, adding each one to taskGraph.
    // Recursively, for each task now in graph, 
    //   iterates through set of dependent tasks adding each one 
    // 
    public static void addTasksAndDependencies(
        TaskNode taskGraph, TaskNode parentTaskNode, Set<Task> tasks) 
    {
    	log.debug("TaskNode.addTasksAndDeps: Set tasks size: " + tasks.size());
    	for (Task currentTask : tasks) {
            // Search the whole taskGraph for the currentTask
            // (not just the graph from the parentTaskNode down)
            TaskNode currentTaskNode = taskGraph.getNode(currentTask.id());
            if (currentTaskNode != null) {
                // task already in the taskGraph

                // if the task we're trying to add is a conflicted task
                // it does not have a parent task it's dependent on;
                // just add its dependencies to the currentTaskNode.

                // if the task we're trying to add is a dependent task
                // we need to add its parent to the list of parent tasks 
                // that the currentTaskNode is dependent on.
                currentTaskNode.addParent(parentTaskNode);
                log.debug("TaskNode.addTasksAndDeps: existingTask: " + 
                   currentTask.id() + 
                   " addParent: " + parentTaskNode.task().id()); 
            }
            else {
                // task not already in the taskGraph
                // so add it as child of parentTaskNode
                currentTaskNode = parentTaskNode.add(currentTask);
                log.debug("TaskNode.addTasksAndDeps: addTask: " + 
                   currentTask.id());
            }
 
            // recursively add dependent tasks
            if (currentTask.dependentTasks() != null) {
                parentTaskNode = currentTaskNode; //just illustrating transition
                TaskNode.addTasksAndDependencies(
                    taskGraph, parentTaskNode, currentTask.dependentTasks());
            }
        }
    }

    // addConflicted: 
    // only add given conflicted task 
    // if existing list of conflicted tasks doesn't already contain it
    public boolean addConflicted(Task task) {
        // log.debug("TaskNode.addConflicted: task: " + task.id());
        if (! containsChild(task.id()) ) {
            children.add(new TaskNode(task, TaskType.CONFLICTED, this));
            return true;
        }
        return false;
    }

    public void addAllConflicted(Collection<Task> tasks) {
        tasks.forEach( (task) -> {
                addConflicted(task);
        });
    }

    public void addChild(Task task) {
        children.add(new TaskNode(task, TaskType.DEPENDENT, this));
    }

    public void addChild(TaskNode taskNode) {
    	taskNode.addParent(this);
        children.add(taskNode);
    }

    public void removeChild(TaskNode taskNode) {
        children.remove(taskNode);
    }

    // iterate through children and return true if list of children already contains task with given id
    public boolean containsChild(String id) {
    	for (TaskNode node : children) {
	        if ( id.equals(node.task().id()) ) {
	            return true;
	        }
    	}
        return false;
    }

    // iterate through all tasks reachable from this node and 
    // return true if this task graph already contains task with given id 
    public boolean contains(String id) {
        for (TaskIterator tasks = new TaskIterator(this); tasks.hasNext();) {
            task = tasks.next();
            if ( id.equals(task.id()) ) {
                return true;
            }
        }
        return false;
    }

    public Task getTask(String id) {
        for (TaskIterator tasks = new TaskIterator(this); tasks.hasNext();) {
            task = tasks.next();
            if ( id.equals(task.id()) ) {
                return task;
            }
        }
        return null;
    }

    public TaskNode getNode(String id) {
        for (TaskNodeIterator nodes = new TaskNodeIterator(this); nodes.hasNext();) {
            TaskNode node = nodes.next();
            if ( id.equals(node.task().id()) ) {
                return node;
            }
        }
        return null;
    }
    
    // nbr of TaskNodes in this graph
    public int size() {
    	int size = 0;
    	for (TaskNodeIterator nodes = new TaskNodeIterator(this); nodes.hasNext();) {
            @SuppressWarnings("unused")
			TaskNode node = nodes.next(); // this call to next() is necessary to enable progression!
            size++;
        }
        return size;
    }
    
}

