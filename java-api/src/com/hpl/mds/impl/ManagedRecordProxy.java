/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.impl;

import com.hpl.mds.ManagedComposite;
import com.hpl.mds.ManagedObject;
import com.hpl.mds.ManagedRecord;
import com.hpl.mds.NativeLibraryLoader;
import com.hpl.mds.RecordType;
import com.hpl.mds.naming.Namespace;
import com.hpl.mds.naming.Prior;

public abstract class ManagedRecordProxy extends Proxy implements ManagedRecord {
	
  private static final NativeLibraryLoader NATIVE_LIB_LOADER = NativeLibraryLoader.getInstance();
  
  protected final RecordTypeProxy<? extends ManagedRecord> type;
  private ManagedRecordProxy forward_;
  private boolean behavedWhileTypeInferred = false;
  
  private static final Proxy.Table<ManagedRecordProxy> 
  proxyTable = new Proxy.Table.WithLargeCache<>(ManagedRecordProxy::release);
  
  @Override
  protected Object domain() {
    return ManagedRecordProxy.class;
  }

  private static native void release(long index);
  private static native long createRecord(long recTypeHandle, long ctxtHandle);
  private static native boolean isIdentical(long aHandle, long bHandle);
  private static native boolean isSameObject(long aHandle, long bHandle);
  private static native boolean isSameViewOfSameObject(long aHandle, long bHandle, long ctxtHandle);
  private static native long recordTypeIndex(long handle);
  static native long getUUID(long recHandle);
  
  @Override
  void releaseHandleIndex(long index) {
    /*
     * If we have a forward, it's the forward that does the release. 
     * Since we hold a reference to it, it will necessarily outlive 
     * us.
     */
    if (forward_ == null || forward_ == this) {
      proxyTable.release(index);
    }
  }
  
  public enum FromHandle { FROM_HANDLE};

  protected ManagedRecordProxy(FromHandle keyword, long handle, RecordType<? extends ManagedRecord> type) {
    super(handle);
    RecordTypeProxy<? extends ManagedRecord> rtp = RecordTypeProxy.downcast(type);
    RecordTypeProxy<? extends ManagedRecord> rtpf = rtp.forward();
    if (rtpf == null) {
      forward_ = null;
      this.type = rtp;
    } else {
      forward_ = this;
      this.type = rtpf;
    }
  }
  
  public ManagedRecordProxy(RecordType<? extends ManagedRecord> type)
  {
	  this(FromHandle.FROM_HANDLE,
			  createRecord(RecordTypeProxy.downcast(type).handleIndex(), IsoContextProxy.current().handleIndex()),
			  type);
  }

  

//  public ManagedRecordProxy(RecordType<? extends ManagedRecord> type) 
//  {
//    this(FromHandle.FROM_HANDLE, 
//         createRecord(RecordTypeProxy.downcast(type).handleIndex(), IsoContextProxy.current().handleIndex()),
//         type);
//  }
  
  protected <R extends ManagedRecord> R forwardsTo() {
    ManagedRecordProxy mrp = forward_;
    if (forward_ == null) {
      synchronized (this) {
        /*
         * It's possible that somebody else might've done it
         * while we were waiting.
         */
        if (forward_ == null) {
          RecordTypeProxy<? extends ManagedRecord> f = type.forward();
          if (f != null) {
            mrp = forward_ = (ManagedRecordProxy) f.createFromRecordHandle(handleIndex_);
            /*
             * Now we need to make sure that it's the one in the table.  fromHandle() checks
             * the forward, but if the original gets collected, we won't be able to find
             * the new one.
             */
            proxyTable.replace(handleIndex_, mrp);
          } else {
            mrp = this;
          }
        } else {
          mrp = forward_;
        }
      }
    }
    @SuppressWarnings("unchecked")
    R mr = (R) mrp;
    return mr;
  }
  
  static <RT extends ManagedRecord> 
  RT fromHandle(long handle, RecordTypeProxy<RT> typeBound) {
    ManagedRecordProxy mrp = proxyTable.fromIndex(handle, (i) -> {
      /*
       * We only get here if the handle wasn't in the table.  Calling
       * RTP.fromHandle will create the type proxy if it doesn't exist
       */
      long rti = recordTypeIndex(handle);
      RecordTypeProxy<? extends ManagedRecord> rt = RecordTypeProxy.fromHandle(rti);
      ManagedRecord mr =  rt.createFromRecordHandle(handle);
      return (ManagedRecordProxy)mr;
    });
    if (mrp == null) {
    	return null;
    }
    /*
     * It's possible it was forwarded.
     */
    if (mrp.forward_ != null) {
      mrp = mrp.forward_;
    }
    /*
     * TODO: Make sure it's compatible with typeBound.  (Maybe 
     * just on creation)
     */
    @SuppressWarnings("unchecked")
    RT downcast = (RT)mrp;
    return downcast;
  }
  

  protected <R extends ManagedRecord> RecordTypeProxy<R> narrowedType(Class<R> clss, R self) {
    /*
     * The notion is that this will only be called as narrowedType(R.class, this), so R is
     * necessarily in the hierarchy. and so the object must have been constructed with a type
     * parameter of RecordTypeProxy<? extends R>.  We're fudging a bit, but it looks as
     * though it should be legal.
     */
    @SuppressWarnings("unchecked")
    RecordTypeProxy<R> t = (RecordTypeProxy<R>)type;
    return t;
  }

  public static <T extends ManagedRecord> RecordType<? extends T> typeOf(T rec) {
	  // By construction, this has to work, since the constructors are required to narrow at each level, so T's constructor
	  // would require a RecordType<? extends T>
	  ManagedRecordProxy mrb = (ManagedRecordProxy)rec;
	  @SuppressWarnings("unchecked")
	  RecordType<? extends T> type = (RecordType<? extends T>)mrb.type;
	  return type;
	}
  
  public static <T extends ManagedRecord> long handleOf(T rec) {
    ManagedRecordProxy mrb = (ManagedRecordProxy)rec;
    return mrb == null ? 0 : mrb.handleIndex();
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    } else if (o == null) {
      return false;
    } else if (!(o instanceof ManagedComposite)) {
      return false;
    }
    return isSameViewOfSameObject((ManagedComposite)o);
  }


  @Override
  public boolean isIdentical(ManagedComposite other) {
    if (this == other) { 
      return true; 
    } else if (other == null) { 
      return false; 
    } else if (!(other instanceof ManagedRecordProxy)) { 
      return false; 
    }
    return isIdentical(handleIndex_, ((ManagedRecordProxy)other).handleIndex());
  }
  
  @Override
  public boolean isSameObject(ManagedComposite other) {
    if (this == other) { 
      return true; 
    } else if (other == null) { 
      return false; 
    } else if (!(other instanceof ManagedRecordProxy)) { 
      return false; 
    }
    return isSameObject(handleIndex_, ((ManagedRecordProxy)other).handleIndex());
  }

  @Override
  public boolean isSameViewOfSameObject(ManagedComposite other) {
    if (this == other) { 
      return true; 
    } else if (other == null) { 
      return false; 
    } else if (!(other instanceof ManagedRecordProxy)) { 
      return false; 
    }
    return isSameViewOfSameObject(handleIndex_, ((ManagedRecordProxy)other).handleIndex(),
                                  IsoContextProxy.current().handleIndex());
  }
  
  public long getUUID() {
    return getUUID(handleIndex_);
  }

  @Override
  public RecordType<? extends ManagedRecord> type() {
    return type;
  }

  @Override
  public ManagedRecord bindName(Prior prior, Namespace ns, CharSequence name) {
    return narrowedType(ManagedRecord.class, this).bindIn(ns, name, this, prior);
  }

  @Override
  public String toString() {
    return String.format("Record[%,d (%x) %s]",
			 handleIndex_,
			 System.identityHashCode(this),
			 getClass().getCanonicalName());
  }

}
