/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.impl;

import java.lang.ref.WeakReference;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.function.LongConsumer;
import java.util.function.LongFunction;

import com.hpl.erk.util.ArrayUtils;

public abstract class Proxy {

	protected final long handleIndex_;
    abstract void releaseHandleIndex(long index);
    
    @Override
    protected void finalize() throws Throwable {
      releaseHandleIndex(handleIndex_);
    }

	protected Proxy(long hi) {
		this.handleIndex_ = hi;
	}
	
	public long handleIndex() {
		return handleIndex_;
	}

  /*
   * The domain is an object that will be the same for all elements
   * that share the same handles.  Normally, this will be the actual
   * class created.  For ManagedRecordProxy, it will that class, so
   * that all subclasses are seen as being in the same domain.
   */
  protected Object domain() {
    return getClass();
  }
	
	public boolean proxiesToSame(Proxy other) {
	  // A better approach would probably be to cache the underlying 
	  // object hash as a long in the proxy.  Then we can compare
	  // hashes when the indexes aren't the same.
	  return (other != null
		  && (handleIndex_ == other.handleIndex_)
		  && (domain() == other.domain()));
	}
	
	@Override
	public int hashCode() {
		// Arguably, we should use the actual underlying object hash, 
		// since Long.hashCode() is terrible
		return domain().hashCode() ^ Long.hashCode(handleIndex_);
	}

	
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (!(obj instanceof Proxy)) {
			return false;
		}
		return proxiesToSame((Proxy)obj);
	}
	
	static protected class Table<P extends Proxy> {
	  static final int DEFAULT_CACHE_SIZE_BITS = 8;
	  final int cache_size;
	  final int cache_mask;

      final ThreadLocalCache threadLocalCache = new ThreadLocalCache();
      final ConcurrentMap<Long, WeakReference<P>> globalMap = new ConcurrentHashMap<>();
      final LongConsumer releaser;
      
	  public Table(LongConsumer releaser, int cache_size_bits) {
	    super();
	    this.releaser = releaser;
	    cache_size = 1 << cache_size_bits;
	    cache_mask = cache_size-1;
	  }
	  public Table(LongConsumer releaser) {
	    this(releaser, DEFAULT_CACHE_SIZE_BITS);
	  }
	  class ThreadLocalCache extends ThreadLocal<WeakReference<P>[]> {
	    @Override
	    protected WeakReference<P>[] initialValue() {
	    	// If we do a single assignment to WeakReference<P>[], javac complains that it's unchecked,
	    	// and Eclipse complains that suppressing unchecked is unnecessary.
	      WeakReference<?>[] a = ArrayUtils.newArray(WeakReference.class, cache_size);
	      @SuppressWarnings("unchecked")
	      WeakReference<P>[] array = (WeakReference<P>[])a;
	      return array;
	    }
	  }

	  static final protected class WithTinyCache<P extends Proxy> extends Table<P> {
	    WithTinyCache(LongConsumer releaser) {
	      super(releaser, 4);
	    }
	  }

	  static final protected class WithSmallCache<P extends Proxy> extends Table<P> {
	    WithSmallCache(LongConsumer releaser) {
	      super(releaser, 8);
	    }
	  }
	  static final protected class WithLargeCache<P extends Proxy> extends Table<P> {
	    WithLargeCache(LongConsumer releaser) {
	      super(releaser, 16);
	    }
	  }
	  static final protected class WithHugeCache<P extends Proxy> extends Table<P> {
	    WithHugeCache(LongConsumer releaser) {
	      super(releaser, 20);
	    }
	  }


	  final void release(long index) {
	    releaser.accept(index);
	  }
	  
	  /*
	   * It's assumed that there's a reference held on this index,
	   * so we don't worry about it going away, and we can assume that
	   * if we have it in a cache, it's the right one.  We also count on
	   * the finalizer removing of a created proxy removing the last 
	   * reference associated with the fromIndex() call that created it.
	   */
	  final P fromIndex(long index, LongFunction<? extends P> creator) {
	    if (index == 0) {
	      return null;
	    }
	    int slot = (int)(index & cache_mask);
	    WeakReference<P>[] c = threadLocalCache.get();
	    WeakReference<P> wr = c[slot];
	    P res = null;
	    if (wr != null && (res = wr.get()) != null && res.handleIndex_ == index) {
	      /*
	       *  We have it in the local cache.  We don't need our reference,
	       *  because we will use the one in the proxy we found.
	       */
	      releaser.accept(index);
	      return res;
	    }
	    
        /*
         * It's not in the local cache, so we look in the global cache.
         */
        wr = globalMap.get(index);
        if (wr != null && (res = wr.get()) != null) {
          /*
           *  We have it in the global cache.  We don't need our reference,
           *  because we will use the one in the proxy we found.  We do,
           *  however, need to add it to the local cache.
           */
          releaser.accept(index);
          c[slot] = wr;
          return res;
        }
        /*
         * It was in neither cache, so we create one.  The proxy will be
         * responsible for the reference we hold, so we don't release, even
         * if we wind up dropping this proxy on the floor because we use a
         * proxy added to the global cache by a racing thread.
         * 
         * We do this adding in a loop because a racing thread may also be
         * adding at the same time.  wr, at all times holds the last thing
         * we think 
	     */
        res = creator.apply(index);
        WeakReference<P> newWR = new WeakReference<>(res);
	    while (true) {
          if (wr == null) {
            wr = globalMap.putIfAbsent(index, newWR);
            if (wr == null) {
              c[slot] = newWR;
              return res;
            }
            /*
             * Otherwise wr holds the next value
             */
          } else if (globalMap.replace(index, wr, newWR)) {
            c[slot] = newWR;
            return res;
          } else {
            wr = globalMap.get(index);
          }
          /*
           * We didn't install it, but wr now holds the current value
           */
          P curr = wr == null ? null : wr.get();
          if (curr != null) {
            c[slot] = wr;
            return curr;
          }
          /*
           * If we got here, it was created by a racing thread, but it's already
           * been collected, so the WeakRef that was installed is invalid.
           */
	    }
	  }

	  final public void replace(long handleIndex_, P replacement) {
	    /*
	     * This is done within a synchronized block on the object being replaced,
	     * so we can do the replacement unconditionally.
	     * 
	     * Note that the original value may still be in thread-local caches,
	     * so the logic of the call to fromIndex() should be that it checks
	     * to see whether what's returned was forwarded.
	     */
	    globalMap.replace(handleIndex_, new WeakReference<>(replacement));
	  }
	}

}
